<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>前端工程化 | HarryPangPang</title>
  <meta name="description" content="前端工程化至上 目录 版本说明 目录结构 初始化项目 webpack react 配置loader(sass,jsx) 引入babel 使用HtmlWebpackPlugin 使用webpack-dev-server 多入口页面配置 ref&#x3D;“http:&#x2F;&#x2F;www.imooc.com&#x2F;article&#x2F;details&#x2F;id&#x2F;291278#entry”&gt;如何理解entry point(bundl">
<meta property="og:type" content="article">
<meta property="og:title" content="前端工程化">
<meta property="og:url" content="https://harrypangpang.github.io/2021/01/17/react16%E9%85%8D%E7%BD%AE/index.html">
<meta property="og:site_name" content="HarryPangPangBlog">
<meta property="og:description" content="前端工程化至上 目录 版本说明 目录结构 初始化项目 webpack react 配置loader(sass,jsx) 引入babel 使用HtmlWebpackPlugin 使用webpack-dev-server 多入口页面配置 ref&#x3D;“http:&#x2F;&#x2F;www.imooc.com&#x2F;article&#x2F;details&#x2F;id&#x2F;291278#entry”&gt;如何理解entry point(bundl">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-17T06:06:45.000Z">
<meta property="article:modified_time" content="2023-02-20T06:46:49.569Z">
<meta property="article:author" content="HarryPangPang">
<meta property="article:tag" content="实践">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="https://harrypangpang.github.io/2021/01/17/react16%E9%85%8D%E7%BD%AE/index.html">
  
    <link rel="alternate" href="/atom.xml" title="HarryPangPangBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css">
  
<meta name="generator" content="Hexo 6.0.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/HarryPangPang" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">HarryPangPang</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">web developer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> 上海, 中国</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/HarryPangPang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://github.com/HarryPangPang/HarryPangPang.github.io/issues/4" target="_blank" title="Email" data-toggle=tooltip data-placement=top><i class="icon icon-email"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      

    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E8%B7%B5/" rel="tag">实践</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/" rel="tag">日常踩坑</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%90%E7%BB%B4/" rel="tag">运维</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 13px;">前端</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 13.5px;">后端</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 13px;">安全</a> <a href="/tags/%E5%AE%9E%E8%B7%B5/" style="font-size: 14px;">实践</a> <a href="/tags/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/" style="font-size: 13px;">日常踩坑</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 13.5px;">源码</a> <a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 13px;">运维</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/03/06/webpack5%E5%86%85vue%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6%E6%8A%A5%E9%94%99-md/" class="title">webpack5内vue递归组件报错.md</a>
              </p>
              <p class="item-date">
                <time datetime="2023-03-06T10:23:13.000Z" itemprop="datePublished">2023-03-06</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/02/23/centos%E5%AE%89%E8%A3%85node%E7%8E%AF%E5%A2%83(docker)/" class="title">centos安装node和docker</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-23T03:15:00.000Z" itemprop="datePublished">2023-02-23</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/02/21/xss%E6%94%BB%E5%87%BB/" class="title">xss攻击</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-21T02:41:21.000Z" itemprop="datePublished">2023-02-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/02/20/%E7%9F%AD%E9%93%BE%E6%8E%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="title">短链接实现原理</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-20T03:41:21.000Z" itemprop="datePublished">2023-02-20</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/02/17/Gitlab%20cicd/" class="title">Gitlab ci/cd</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-17T06:06:45.000Z" itemprop="datePublished">2022-02-17</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-react16配置" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      前端工程化
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/01/17/react16%E9%85%8D%E7%BD%AE/" class="article-date">
	  <time datetime="2021-01-17T06:06:45.000Z" itemprop="datePublished">2021-01-17</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/%E5%AE%9E%E8%B7%B5/" rel="tag">实践</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/01/17/react16%E9%85%8D%E7%BD%AE/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>前端工程化至上</p>
<p>目录</p>
<p>版本说明<br />
目录结构<br />
初始化项目<br />
webpack<br />
react<br />
配置loader(sass,jsx)<br />
引入babel<br />
使用HtmlWebpackPlugin<br />
使用webpack-dev-server<br />
多入口页面配置<br />
ref=“<a target="_blank" rel="noopener" href="http://www.imooc.com/article/details/id/291278#entry">http://www.imooc.com/article/details/id/291278#entry</a>”&gt;如何理解entry point(bundle),chunk,module<br />
多入口页面html配置<br />
redux<br />
使用react-router<br />
使用redux-thunk<br />
模块热替换（Hot Module Replacement）<br />
使用ESLint<br />
使用axios和async/await<br />
Code Splitting<br />
使用CommonsChunkPlugin<br />
版本说明</p>
<p>由于构建相关例如webpack，babel，react-router等更新的较快，所以本文档以下面各种模块的版本号为主，各位安装的时候需要注意一下或者可以直接执行npm i将模块都安装好。</p>
<p>“dependencies”: {<br />
“babel-core”: “^6.26.3”,<br />
“babel-eslint”: “^8.2.3”,<br />
“babel-loader”: “^7.1.4”,<br />
“babel-plugin-transform-async-to-generator”: “^6.24.1”,<br />
“babel-plugin-transform-runtime”: “^6.23.0”,<br />
“babel-preset-es2015”: “^6.24.1”,<br />
“babel-preset-react”: “^6.24.1”,<br />
“babel-preset-stage-0”: “^6.24.1”,<br />
“babel-preset-stage-3”: “^6.24.1”,<br />
“css-loader”: “^0.28.11”,<br />
“eslint”: “^4.19.1”,<br />
“eslint-loader”: “^2.0.0”,<br />
“eslint-plugin-react”: “^7.9.1”,<br />
“file-loader”: “^1.1.11”,<br />
“history”: “^4.7.2”,<br />
“html-webpack-plugin”: “^3.2.0”,<br />
“react”: “^16.6.0”,<br />
“react-dom”: “^16.6.0”,<br />
“react-hot-loader”: “^4.3.12”,<br />
“react-redux”: “^6.0.0”,<br />
“react-router”: “^4.3.1”,<br />
“react-router-dom”: “^4.3.1”,<br />
“redux”: “^4.0.1”,<br />
“sass-loader”: “^7.0.3”,<br />
“style-loader”: “^0.21.0”,<br />
“url-loader”: “^1.0.1”,<br />
“webpack”: “^4.12.0”,<br />
“webpack-cli”: “^3.0.3”,<br />
“webpack-dev-server”: “^3.1.1”<br />
}<br />
目录结构</p>
<p>开发和发布版本的配置文件是分开的，多入口页面的目录结构。</p>
<p>react-family/<br />
|<br />
|──dist/                                    * 发布版本构建输出路径<br />
|<br />
|──dev/                                     * 调试版本构建输出路径<br />
|<br />
|──src/                                     * 工具函数<br />
|     |<br />
|     |—— component/                        * 各页面公用组件<br />
|     |<br />
|     |—— page/                             * 页面代码<br />
|     |      |—— index/                     * 页面代码<br />
|     |      |        |—— Main/             * 组件代码<br />
|     |      |        |       |—— Main.jsx  * 组件jsx<br />
|     |      |        |       |—— Main.scss * 组件css<br />
|     |      |<br />
|     |      |—— detail/                    * 页面代码<br />
|     |<br />
|     |—— static/                           * 静态文件js，css<br />
|<br />
|<br />
|──webpack.config.build.js                  * 发布版本使用的webpack配置文件<br />
|──webpack.config.dev.js                    * 调试版本使用的webpack配置文件<br />
|──.eslint                                  * eslint配置文件<br />
|__.babelrc                                 * babel配置文件<br />
初始化项目</p>
<p>创建文件夹<br />
mkdir react-family-bucket<br />
初始化npm<br />
cd react-family-bucket<br />
npm init<br />
如果有特殊需要，可以填入自己的配置，一路回车下来，会生成一个package.json，里面是你项目的基本信息，后面的npm依赖安装也会配置在这里。</p>
<p>webpack</p>
<p>安装webpack<br />
npm install webpack --save<br />
or<br />
npm install webpack --g<br />
–save是将当前webpack安装到react-family-bucket下的/node_modules。</p>
<p>–g是将当前webpack安装到全局下面，可以在node的安装目录下找到全局的/node_modules。</p>
<p>配置webopack配置文件<br />
touch webpack.config.dev.js<br />
新建一个app.js</p>
<p>touch app.js<br />
写入基本的webpack配置，可以参考这里：</p>
<p>const path = require(‘path’);<br />
const srcRoot = ‘./src’;<br />
module.exports = {</p>
<pre><code>// 输入配置
entry: [
  './app.js'
],,

// 输出配置
output: &#123;
    path: path.resolve(__dirname, './dev'),

    filename: 'bundle.min.js'
&#125;,
</code></pre>
<p>};<br />
3, 执行webpack命令<br />
如果是全局安装：</p>
<p>webpack --config webpack.config.dev.js<br />
如果是当前目录安装：</p>
<p>./node_modules/.bin/webpack --config webpack.config.dev.js<br />
在package.json中添加执行命令：</p>
<p>“scripts”: {<br />
“dev”: “./node_modules/.bin/webpack --config webpack.config.dev.js”,<br />
},<br />
执行npm run dev命令之后，会发现需要安装webpack-cli，（webpack4之后需要安装这个）</p>
<p>npm install webpack-cli --save<br />
去除WARNING in configuration警告,在webpack.config.dev.js增加一个配置即可：</p>
<p>…<br />
mode: ‘development’<br />
…<br />
成功之后会在dev下面生成bundle.min.js代表正常。</p>
<p>如果想要动态监听文件变化需要在命令后面添加 --watch</p>
<p>react</p>
<p>安装react<br />
npm install react react-dom --save<br />
创建page目录和index页面文件：<br />
mkdir src<br />
mkdir page<br />
cd page<br />
创建index</p>
<p>mkdir index<br />
cd index &amp; touch index.js &amp; touch index.html<br />
index.js</p>
<p>import ReactDom from ‘react-dom’;<br />
import Main from ‘./Main/Main.jsx’;</p>
<p>ReactDom.render(<Main />, document.getElementById(‘root’));<br />
index.html</p>
<!DOCTYPE html>
<html>
<head>
    <title>index</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
</head>
<body>
<div id="root"></div>
</body>
</html>
<p>创建Main组件<br />
import React from ‘react’;</p>
<p>class Main extends React.Component {</p>
<pre><code>constructor(props) &#123;
    super(props);

&#125;

render() &#123;

    return (&lt;div&gt;Main&lt;/div&gt;);
&#125;
</code></pre>
<p>}</p>
<p>export default Main;</p>
<p>export 和 export default区别：</p>
<p>export可以有多个</p>
<p>xx.js:<br />
export const test1 = ‘a’<br />
export function test2() {}</p>
<p>yy.js:<br />
import { test1, test2 } from ‘xx.js’;<br />
export default只能有1个</p>
<p>xx.js:<br />
let test1 = ‘a’;<br />
export default test1;</p>
<p>yy.js:<br />
import test1 from ‘xx.js’;<br />
export 和 module.exports<br />
let exports = module.exports;<br />
修改webpack配置入口文件<br />
entry: [<br />
path.resolve(srcRoot,‘./page/index/index.js’)<br />
],<br />
配置loader</p>
<p>处理样式文件需要这些loader:<br />
css-loader<br />
sass-loader<br />
style-loader</p>
<p>npm install css-loader sass-loader style-loader file-loader --save<br />
配置：</p>
<p>module: {<br />
// 加载器配置<br />
rules: [<br />
{ test: /.css/, use: ['style-loader', 'css-loader'], include: path.resolve(srcRoot)},
            { test: /\.scss/, use: [‘style-loader’, ‘css-loader’, ‘sass-loader’], include: path.resolve(srcRoot)}<br />
]<br />
},</p>
<p>url-loader处理处理静态文件<br />
npm install url-loader --save</p>
<p>配置：</p>
<pre><code>module: &#123;
    // 加载器配置
    rules: [
        &#123; test: /\.(png|jpg|jpeg)$/, use: 'url-loader?limit=8192&amp;name=images/[name].[hash].[ext]', include: path.resolve(srcRoot)&#125;
    ]
&#125;,
</code></pre>
<p>limit:表示超过多少就使用base64来代替，单位是byte</p>
<p>name:可以设置图片的路径，名称和是否使用hash 具体参考这里</p>
<p>引入babel</p>
<p>bebel是用来解析es6语法或者是es7语法分解析器，让开发者能够使用新的es语法，同时支持jsx，vue等多种框架。</p>
<p>安装babel<br />
babel-core<br />
babel-loader<br />
npm install babel-core babel-loader --save<br />
配置：</p>
<p>module: {<br />
// 加载器配置<br />
rules: [<br />
{ test: /.(js|jsx)$/, use: [{loader:‘babel-loader’}] ,include: path.resolve(srcRoot)},<br />
]<br />
},<br />
babel配置文件：.babelrc</p>
<p>touch .babelrc</p>
<p>配置：</p>
<p>{<br />
“presets”: [<br />
“es2015”,<br />
“react”,<br />
“stage-0”<br />
],<br />
“plugins”: []<br />
}<br />
babel支持自定义的预设(presets)或插件(plugins),只有配置了这两个才能让babel生效，单独的安装babel是无意义的</p>
<p>presets：代表babel支持那种语法(就是你用那种语法写)，优先级是从下往上,state-0|1|2|…代表有很多没有列入标准的语法回已state-x表示,参考这里</p>
<p>plugins:代表babel解析的时候使用哪些插件，作用和presets类似，优先级是从上往下。<br />
依次安装：</p>
<p>babel-preset-es2015<br />
babel-preset-react<br />
babel-preset-stage-0</p>
<p>npm install babel-preset-es2015 babel-preset-react babel-preset-stage-0 --save<br />
babel-polyfill是什么？</p>
<p>我们之前使用的babel，babel-loader 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。<br />
npm install --save babel-polyfill<br />
使用：</p>
<p>import “babel-polyfill”;<br />
transform-runtime有什么区别？</p>
<p>当使用babel-polyfill时有一些问题：<br />
默认会引入所有babel支持的新语法，这样就会导致你的文件代码非常庞大。<br />
通过向全局对象和内置对象的prototype上添加方法来达成目的,造成全局变量污染。</p>
<p>这时就需要transform-runtime来帮我们有选择性的引入</p>
<p>npm install --save babel-plugin-transform-runtime<br />
配置文件：</p>
<p>{<br />
“plugins”: [<br />
[“transform-runtime”, {<br />
“helpers”: false,<br />
“polyfill”: false,<br />
“regenerator”: true,<br />
“moduleName”: “babel-runtime”<br />
}]<br />
]<br />
}<br />
使用HtmlWebpackPlugin</p>
<p>记得我们之前新建的index.html么 我们执行构建命令之后并没有将index.html打包到dev目录下 我们需要HtmlWebpackPlugin来将我们output的js和html结合起来</p>
<p>npm install html-webpack-plugin --save<br />
配置：</p>
<p>const HtmlWebpackPlugin = require(‘html-webpack-plugin’);<br />
…<br />
plugins: [<br />
new HtmlWebpackPlugin({<br />
filename: path.resolve(devPath, ‘index.html’),<br />
template: path.resolve(srcRoot, ‘./page/index/index.html’),<br />
})<br />
]<br />
filename:可以设置html输出的路径和文件名</p>
<p>template:可以设置已哪个html文件为模版<br />
更多参数配置可以参考这里</p>
<p>使用webpack-dev-server</p>
<p>webpack-dev-server是一个小型的Node.js Express服务器,它使用webpack-dev-middleware来服务于webpack的包。</p>
<p>安装<br />
npm install webpack-dev-server --save<br />
修改在package.json中添加的执行命令：</p>
<p>“scripts”: {<br />
“dev”: “./node_modules/.bin/webpack-dev-server --config webpack.config.dev.js”,<br />
},<br />
配置webpack配置文件：<br />
devServer: {<br />
“contentBase”: devPath,<br />
“compress”: true,<br />
},<br />
contentBase 表示server文件的根目录<br />
compress 表示开启gzip<br />
更多的配置文档参考这里</p>
<p>webpack-dev-server默认情况下会将output的内容放在内存中，是看不到物理的文件的，如果想要看到物理的dev下面的文件可以安装write-file-webpack-plugin这个插件。<br />
webpack-dev-server默认会开启livereload功能<br />
devtool功能：</p>
<p>具体来说添加了devtool: 'inline-source-map’之后，利用source-map你在chrome控制台看到的source源码都是真正的源码，未压缩，未编译前的代码，没有添加，你看到的代码是真实的压缩过，编译过的代码，更多devtool的配置可以参考这里<br />
多入口文件配置</p>
<p>在之前的配置中，都是基于单入口页面配置的，entry和output只有一个文件，但是实际项目很多情况下是多页面的，在配置多页面时，有2中方法可以选择：</p>
<p>在entry入口配置时，传入对象而不是单独数组,output时利用[name]关键字来区分输出文件例如：<br />
entry: {<br />
index: [path.resolve(srcRoot,‘./page/index/index1.js’),path.resolve(srcRoot,‘./page/index/index2.js’)],<br />
detail: path.resolve(srcRoot,‘./page/detail/detail.js’),<br />
home: path.resolve(srcRoot,‘./page/home/home.js’),<br />
},<br />
output: {<br />
path: path.resolve(__dirname, ‘./dev’),</p>
<pre><code>filename: '[name].min.js'
</code></pre>
<p>},</p>
<p>通过node动态遍历需要entry point的目录，来动态生成entry：<br />
const pageDir = path.resolve(srcRoot, ‘page’);<br />
function getEntry() {<br />
let entryMap = {};</p>
<pre><code>fs.readdirSync(pageDir).forEach((pathname)=&gt;&#123;
    let fullPathName = path.resolve(pageDir, pathname);
    let stat = fs.statSync(fullPathName);
    let fileName = path.resolve(fullPathName, 'index.js');

    if (stat.isDirectory() &amp;&amp; fs.existsSync(fileName)) &#123;
        entryMap[pathname] = fileName;
    &#125;

&#125;);

return entryMap;
</code></pre>
<p>}<br />
{<br />
…<br />
entry: getEntry()<br />
…<br />
}<br />
本demo采用的是第二中写法，能够更加灵活。</p>
<p>如何理解entry point(bundle),chunk,module</p>
<p>在webpack中，如何理解entry point(bundle),chunk,module?先看看下图：</p>
<p>根据图上的表述，我这里简单说一下结论：</p>
<p>配置中每个文件例如index1.js,index2.js,detail.js,home.js都属于entry point.<br />
entry这个配置中，每个key值,index,detail,home都相当于chunk。<br />
我们在代码中的require或者import的都属于module，这点很好理解。<br />
chunk的分类比较特别，有entry chunk,initial chunk,normal chunk,参考这个文章<br />
正常情况下，一个chunk对应一个output,在使用了CommonsChunkPlugin或者require.ensure之后，chunk就变成了initial chunk,normal chunk，这时，一个chunk对应多个output。</p>
<p>理解这些概念对于后续使用webpack插件有很大的帮助。<br />
多入口页面html配置</p>
<p>之前我们配置HtmlWebpackPlugin时，同样采用的是但页面的配置，这里我们将进行多页面改造,entryMap是上一步得到的entry：</p>
<p>function htmlAarray(entryMap) {<br />
let htmlAarray = [];</p>
<pre><code>Object.keys(entryMap).forEach(function(key)&#123;
    let fullPathName = path.resolve(pageDir, key);
    let fileName = path.resolve(fullPathName, key + '.html')
    if (fs.existsSync(fileName)) &#123;
        htmlAarray.push(new HtmlWebpackPlugin(&#123;
            chunks: key, // 注意这里的key就是chunk
            filename: key + '.html',
            template: fileName,
            inlineSource:  '.(js|css)'
        &#125;))
    &#125;
&#125;);

return htmlAarray;
</code></pre>
<p>}<br />
修改plugin配置：</p>
<p>plugins: [<br />
…<br />
].concat(htmlMap)<br />
redux</p>
<p>关于redux的使用可以参考阮一峰老师的入门教程</p>
<p>安装redux<br />
redux<br />
react-redux<br />
npm install redux react-redux --save<br />
新建reducers，actions目录和文件<br />
|—— index/<br />
|—— Main/                   * 组件代码<br />
|       |—— Main.jsx        * 组件jsx<br />
|       |—— Main.scss       * 组件css<br />
|<br />
|—— actions/<br />
|       |—— actionTypes.js  * action常量<br />
|       |—— todoAction.js   * action<br />
|<br />
|—— reducers/<br />
|       |—— todoReducer.js  * reducer<br />
|       |—— main.js         * 将所有reducer进行combin，store.js只引入这个<br />
|<br />
|—— store.js<br />
|<br />
|—— index.js</p>
<p>修改代码，引入redux,这里以一个redux todo为demo例子：<br />
index.js</p>
<p>import ReactDom from ‘react-dom’;<br />
import React from ‘react’;<br />
import Main from ‘./Main/Main.jsx’;<br />
import store from ‘./store.js’;<br />
import { Provider } from ‘react-redux’;</p>
<p>ReactDom.render(<br />
<Provider store={store}><br />
<Main /><br />
</Provider><br />
, document.getElementById(‘root’));<br />
store.js</p>
<p>import { createStore } from ‘redux’;<br />
import todoReducer from ‘./reducers/todoReducer.js’;</p>
<p>const store = createStore(todoReducer);</p>
<p>export default store;<br />
tabReducer.js</p>
<p>import { ADD_TODO } from ‘…/actions/actionTypes.js’;</p>
<p>const initialState = {<br />
todoList: []<br />
};</p>
<p>const addTodo = (state, action) =&gt; {</p>
<p>return { …state, todoList: state.todoList.concat(action.obj) }<br />
}</p>
<p>const todoReducer = (state = initialState, action) =&gt; {<br />
switch(action.type) {<br />
case ADD_TODO: return addTodo(state, action);<br />
default: return state;<br />
}<br />
};<br />
export default todoReducer;<br />
Main.jsx</p>
<p>import React from ‘react’;<br />
import { connect } from ‘react-redux’;<br />
import { addTodo } from ‘…/actions/todoAction.js’;</p>
<p>class Main extends React.Component {</p>
<pre><code>onClick()&#123;
    let text = this.refs.input;

    this.props.dispatch(addTodo(&#123;
        text: text.value
    &#125;))
&#125;
render() &#123;
    return (
        &lt;div&gt;
            &lt;input ref=&quot;input&quot; type=&quot;text&quot;&gt;&lt;/input&gt;
            &lt;button onClick=&#123;()=&gt;this.onClick()&#125;&gt;提交&lt;/button&gt;
            &lt;ul&gt;
            &#123;this.props.todoList.map((item, index)=&gt;&#123;
                return &lt;li key=&#123;index&#125;&gt;&#123;item.text&#125;&lt;/li&gt;
            &#125;)&#125;
            &lt;/ul&gt;
        &lt;/div&gt;
    );
&#125;
</code></pre>
<p>}</p>
<p>export default connect(<br />
state =&gt; ({<br />
todoList: state.todoList<br />
})<br />
)(Main);<br />
todoAction.js</p>
<p>import { ADD_TODO } from ‘./actionTypes.js’;</p>
<p>export const addTodo = (obj) =&gt; {<br />
return {<br />
type: ADD_TODO,<br />
obj: obj<br />
};<br />
};<br />
使用react-router</p>
<p>react-router强大指出在于方便代码管理，结合redux使用更加强大，同时支持web，native更多参考这里</p>
<p>安装react-router-dom<br />
npm install react-router-dom --save<br />
如果项目中用了redux，可以安装connected-react-router<br />
npm install connected-react-router history --save</p>
<p>修改代码：</p>
<p>index.js:<br />
import ReactDom from ‘react-dom’;<br />
import React from ‘react’;<br />
import Container from ‘./Main/Container.jsx’;<br />
import { store, history } from ‘./store.js’;</p>
<p>import { Provider } from ‘react-redux’;</p>
<p>import { ConnectedRouter } from ‘connected-react-router’;</p>
<p>ReactDom.render(<br />
<Provider store={store}><br />
<ConnectedRouter history={history}><br />
<Container /><br />
</ConnectedRouter><br />
</Provider><br />
, document.getElementById(‘root’));<br />
结合history,react-router一共有3中不同的router：</p>
<p>BrowserRouter通过history/createBrowserHistory引入:当切换时，url会动态更新，底层使用的时html5的pushState。<br />
HashRouter通过history/createHashHistory引入:当切换时，动态修改hash，利用hashchange事件。<br />
MemoryRouter通过history/createMemoryHistory引入:将路径，路由相关数据存入内存中，不涉及url相关更新，兼容性好。<br />
更多配置可以参考这里</p>
<p>如果想要在代码逻辑中获取当前的route的location信息需要在main.js中添加router的reducer:</p>
<p>新建main.js:<br />
import { combineReducers } from ‘redux’;<br />
import { connectRouter } from ‘connected-react-router’<br />
import todoReducer from ‘./todoReducer.js’;</p>
<p>const reducers = (history) =&gt; combineReducers({<br />
todoReducer,<br />
router: connectRouter(history)<br />
});<br />
export default reducers;<br />
编写store.js:</p>
<p>import { createStore } from ‘redux’;<br />
import mainReducer from ‘./reducers/main.js’;<br />
import createHistory from ‘history/createHashHistory’;</p>
<p>export const history = createHistory();</p>
<p>const store = createStore(<br />
createRootReducer(history),<br />
);</p>
<p>export default store;<br />
然后就可以在this.props.router里面获取到相关的location路径信息，其实就是将router对象放在组件的props里面。</p>
<p>如果需要自己通过dispatch一个action来触发router的跳转，需要引入routerMiddleware:<br />
import { createStore,applyMiddleware,compose } from ‘redux’;<br />
import mainReducer from ‘./reducers/main.js’;<br />
import createHistory from ‘history/createHashHistory’;<br />
import { routerMiddleware } from “connected-react-router”;</p>
<p>export const history = createHistory();</p>
<p>const store = createStore(<br />
createRootReducer(history),<br />
compose(applyMiddleware(routerMiddleware(history)))<br />
);</p>
<p>export default store;<br />
最后，将改动同步在index.js长这样：</p>
<p>index.js:</p>
<p>import ReactDom from ‘react-dom’;<br />
import React from ‘react’;<br />
import Container from ‘./Main/Container.jsx’;<br />
import store, { history } from ‘./store.js’;</p>
<p>import { Provider } from ‘react-redux’;</p>
<p>import { ConnectedRouter } from ‘connected-react-router’;</p>
<p>ReactDom.render(<br />
<Provider store={store}><br />
<ConnectedRouter history={history}><br />
<Container /><br />
</ConnectedRouter><br />
</Provider><br />
, document.getElementById(‘root’));<br />
看到这里，大家可能会对react-router，react-router-dom，connected-react-router，history这些东西给搞晕了，在这里解释一下：</p>
<p>react-router：是react-router的核心逻辑，并不涉及到UI，必须引入。<br />
react-router-dom：是react-router的DOM绑定模块，只有用了react-router-dom才能用类似,这些组件，必须引入。<br />
history：是一个让你灵活控制或者模拟浏览器的历史操作的一个库，包括BrowserHistory，HashHistory，MemoryHistory，他可以脱离React使用，也可以结合React使用，可选引入。<br />
connected-react-router：简单来说就是你的项目如果用的React和Redux，如果想要用router的话就可以引入connected-react-router，它能帮你把router的状态放在store里来管理(注意根据你使用的react-router版本不同，会使用不同的版本，它的前身是react-router-redux，官方已经不再维护了)，可选引入。<br />
使用Route和Link和withRouter:</p>
<p>先说说都是干嘛的：<br />
Route:component里面的内容即是tab的主要内容，这个从react-router4开始生效：<br />
<Route exact path="/" component={Div1}></Route><br />
<Route path="/2" component={Div2}></Route><br />
Link:通常也可以用NavLink，相当于tab按钮，控制router的切换,activeClass表示当前tab处于激活态时应用上的class。<br />
withRouter:如果你用了redux，那么你一定要引入它。<br />
export default withRouter(connect(<br />
state =&gt; ({<br />
todoList: state.todoReducer.todoList<br />
})<br />
)(Main));<br />
如果你在使用hash时遇到Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack错误，可以将push改为replace即</p>
<p><NavLink
    replace={true}
    to="/2"
    activeClassName="selected"
    >切换到2号</NavLink><br />
设置初始化路由：<br />
BrowserRouter和HashRouter:<br />
const history = createHistory();<br />
history.push(‘2’);<br />
MemoryRouter:<br />
const history = createMemoryHistory({<br />
initialEntries: [‘/2’]<br />
});<br />
使用redux-thunk</p>
<p>redux-thunk 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过 fetch通用远程 API 这些场景，那么久应该使用 redux-thunk 了。redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响。</p>
<p>安装redux-thunk:<br />
npm install redux-thunk --save<br />
修改store.js:<br />
import { createStore,applyMiddleware } from ‘redux’;<br />
import thunk from ‘redux-thunk’;<br />
import mainReducer from ‘./reducers/main’;<br />
…<br />
const store = createStore(mainReducer, applyMiddleware(thunk));<br />
…<br />
export default store;</p>
<p>在action.js使用redux-thunk：<br />
export const getData = (obj) =&gt; (dispatch, getState) =&gt; {<br />
setTimeout(()=&gt;{<br />
dispatch({<br />
type: GET_DATA,<br />
obj: obj<br />
});<br />
},1000);<br />
};<br />
模块热替换（Hot Module Replacement）</p>
<p>模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新,很高大上有木有！</p>
<p>下面说一下配置方法，它需要结合devServer使用：</p>
<p>devServer: {<br />
hot: true // 开启HMR<br />
},<br />
开启plugin：</p>
<p>const webpack = require(‘webpack’);<br />
plugins: [<br />
new webpack.NamedModulesPlugin(),<br />
new webpack.HotModuleReplacementPlugin(),<br />
].concat(htmlMap)<br />
结合React一起使用：</p>
<p>安装react-hot-loader,<br />
npm install react-hot-loader --save<br />
并新建一个Container.jsx:</p>
<p>import React from ‘react’;<br />
import Main from ‘./Main.jsx’;<br />
import { hot } from ‘react-hot-loader’</p>
<p>class Container extends React.Component {</p>
<pre><code>render() &#123;
    return &lt;Main /&gt;
&#125;
</code></pre>
<p>}<br />
export default hot(module)(Container);<br />
结合redux：如果项目没有使用redux，可以无需配置后面2步</p>
<ol start="2">
<li>修改store.js新增下面代码，为了让reducer也能实时热替换</li>
</ol>
<p>if (module.hot) {<br />
module.hot.accept(‘./reducers/todoReducer.js’, () =&gt; {<br />
const nextRootReducer = require(‘./reducers/todoReducer.js’).default;<br />
store.replaceReducer(nextRootReducer);<br />
});<br />
}</p>
<p>修改index.js<br />
import ReactDom from ‘react-dom’;<br />
import React from ‘react’;<br />
import Container from ‘./Main/Container.jsx’;<br />
import store from ‘./store.js’;</p>
<p>import { Provider } from ‘react-redux’;</p>
<p>ReactDom.render(<br />
<Provider store={store}><br />
<Container /><br />
</Provider><br />
, document.getElementById(‘root’));<br />
当控制台看到[WDS] Hot Module Replacement enabled.代表开启成功</p>
<p>使用ESLint</p>
<p>ESLint 是众多 Javascript Linter 中的其中一种，其他比较常见的还有 JSLint 跟 JSHint，之所以用 ESLint 是因为他可以自由选择要使用哪些规则，也有很多现成的 plugin 可以使用，另外他对 ES6 还有 JSX 的支持程度跟其他 linter 相比之下也是最高的。</p>
<p>安装ESLint<br />
npm install eslint eslint-loader babel-eslint --save<br />
其中eslint-loader是将webpack和eslint结合起来在webpack的配置文件中新增一个eslint-loader种，修改如下</p>
<p>{ test: /.(js|jsx)$/, use: [{loader:‘babel-loader’},{loader:‘eslint-loader’}] ,include: path.resolve(srcRoot)},<br />
新建.eslintrc配置文件,将parser配置成babel-eslint<br />
{<br />
“extends”: [“eslint:recommended”],</p>
<pre><code>&quot;parser&quot;: &quot;babel-eslint&quot;,

&quot;globals&quot;: &#123;
&#125;,
&quot;rules&quot;: &#123;
&#125;
</code></pre>
<p>}<br />
安装eslint-plugin-react:<br />
npm install eslint-plugin-react --save<br />
说明一下，正常情况下每个eslint规则都是需要在rule下面配置，如果什么都不配置，其实本身eslint是不生效的。<br />
eslint本身有很多默认的规则模版，可以通过extends来配置，默认可以使用eslint:recommended。<br />
在使用react开发时可以安装eslint-plugin-react来告知使用react专用的规则来lint<br />
修改.eslintrc配置文件,增加rules，更多rules配置可以参考这里<br />
{<br />
“extends”: [“eslint:recommended”,“plugin:react/recommended”],</p>
<pre><code>&quot;parser&quot;: &quot;babel-eslint&quot;,

&quot;globals&quot;: &#123;
    &quot;window&quot;: true,
    &quot;document&quot;: true,
    &quot;module&quot;: true,
    &quot;require&quot;: true
&#125;,
&quot;rules&quot;: &#123;
    &quot;react/prop-types&quot; : &quot;off&quot;,
    &quot;no-console&quot; : &quot;off&quot;
&#125;
</code></pre>
<p>}<br />
使用axios和async/await</p>
<p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端：</p>
<p>从浏览器中创建 XMLHttpRequest<br />
从 node.js 发出 http 请求<br />
支持 Promise API<br />
自动转换JSON数据<br />
安装axios:<br />
npm install axios --save<br />
在action中使用axios：<br />
import axios from ‘axios’;<br />
export const getData = (obj) =&gt; (dispatch, getState) =&gt; {<br />
axios.get(‘/json/comments.json’).then((resp)=&gt;{<br />
dispatch({<br />
type: GET_DATA,<br />
obj: resp<br />
});<br />
});<br />
};<br />
async/await：</p>
<p>Javascript的回调地狱，相信很多人都知道，尤其是在node端，近些年比较流行的是Promise的解决方案，但是随着 Node 7 的发布，编程终级解决方案的 async/await应声而出。</p>
<p>function resolveAfter2Seconds() {<br />
return new Promise(resolve =&gt; {<br />
setTimeout(() =&gt; {<br />
resolve(‘resolved’);<br />
}, 2000);<br />
});<br />
}</p>
<p>async function asyncCall() {<br />
var result = await resolveAfter2Seconds();<br />
}</p>
<p>asyncCall();<br />
async/await的用途是简化使用 promises 异步调用的操作，并对一组 Promises执行某些操作。await前提是方法返回的是一个Promise对象，正如Promises类似于结构化回调，async/await类似于组合生成器和 promises。</p>
<p>async/await需要安装babel-plugin-transform-async-to-generator。<br />
npm install babel-plugin-transform-async-to-generator --save<br />
在.babelrc中增加配置：<br />
“plugins”: [<br />
“transform-async-to-generator”<br />
]<br />
这样做仅仅是将async转换generator，如果你当前的浏览器不支持generator，你将会收到一个Uncaught ReferenceError: regeneratorRuntime is not defined的错误，你需要：</p>
<ol start="3">
<li>安装babel-plugin-transform-runtime:</li>
</ol>
<p>npm install babel-plugin-transform-async-to-generator --save<br />
修改.babelrc中的配置(可以去掉之前配置的transform-async-to-generator)：<br />
“plugins”: [<br />
“transform-runtime”<br />
]<br />
如果不想引入所有的polyfill(参考上面对babel的解释),可以增加配置：<br />
“plugins”: [<br />
“transform-runtime”,<br />
{<br />
“polyfill”: false,</p>
<pre><code>            &quot;regenerator&quot;: true,
        &#125;
]
</code></pre>
<p>结合axios使用：<br />
import axios from ‘axios’;<br />
export const getData = (obj) =&gt; async (dispatch, getState) =&gt; {<br />
let resp = axios.get(‘/json/comments.json’);<br />
dispatch({<br />
type: GET_DATA,<br />
obj: resp<br />
});<br />
};<br />
Code Splitting</p>
<p>对于webpack1，2之前，你可以使用require.ensure来控制一个组件的懒加载：<br />
require.ensure([], _require =&gt; {<br />
let Component = _require(‘./Component.jsx’);<br />
},‘lazyname’)<br />
在webpack4中，官方已经不再推荐使用require.ensure来使用懒加载功能Dynamic Imports，取而代之的是ES6的import()方法：<br />
import(<br />
/* webpackChunkName: “my-chunk-name” <em>/<br />
/</em> webpackMode: “lazy” */<br />
‘module’<br />
);<br />
不小小看注释里的代码，webpack在打包时会动态识别这里的代码来做相关的配置，例如chunk name等等。<br />
3. Prefetching/Preloading modules:</p>
<p>webpack 4.6.0+支持了Prefetching/Preloading的写法:</p>
<p>//…<br />
import(/* webpackPreload: true */ ‘ChartingLibrary’);<br />
结合React-Router使用:<br />
react-loadable对上述的功能做了封装，丰富了一些功能，结合React-Router起来使用更加方便。</p>
<p>npm install react-loadable --save<br />
在react-router里使用：</p>
<p>function Loading() {<br />
return <div>Loading…</div>;<br />
}</p>
<p>let Div2 = Loadable({<br />
loader: () =&gt; import(‘./Div2’),<br />
loading: Loading,<br />
});</p>
<p><Route path="/2" component={Div2}></Route><br />
使用CommonsChunkPlugin</p>
<p>CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。</p>
<p>在webpack4之前的用法：<br />
new webpack.optimize.CommonsChunkPlugin({<br />
name: ‘common’,<br />
chunks: [‘page1’,‘page2’],<br />
minChunks: 3<br />
})<br />
name: string: 提出出的名称<br />
chunks: string[]: webpack会从传入的chunk里面提取公共代码,默认从所有entry里提取<br />
minChunks: number|infinity|function(module,count)-&gt;boolean: 如果传入数字或infinity(默认值为3)，就是告诉webpack，只有当模块重复的次数大于等于该数字时，这个模块才会被提取出来。当传入为函数时，所有符合条件的chunk中的模块都会被传入该函数做计算，返回true的模块会被提取到目标chunk。<br />
更多的参数配置，可以参考这里<br />
在webpack4之后的用法：<br />
module.exports = {<br />
//…<br />
optimization: {<br />
splitChunks: {<br />
chunks: ‘async’,<br />
minSize: 30000,<br />
minChunks: 1,<br />
maxAsyncRequests: 5,<br />
maxInitialRequests: 3,<br />
automaticNameDelimiter: ‘~’,<br />
name: true,<br />
cacheGroups: {<br />
vendors: {<br />
test: /[\/]node_modules[\/]/,<br />
priority: -10<br />
},<br />
default: {<br />
minChunks: 2,<br />
priority: -20,<br />
reuseExistingChunk: true<br />
}<br />
}<br />
}<br />
}<br />
};<br />
splitChunks: 配置一个分离chunk(代替老版本的CommonsChunkPlugin)<br />
cacheGroups: 自定义配置主要使用它来决定生成的文件:<br />
test: 限制范围<br />
name: 生成文件名<br />
priority: 优先级<br />
minSize: number: 最小尺寸必须大于此值，默认30000B<br />
minChunks: 其他entry引用次数大于此值，默认1<br />
maxInitialRequests: entry文件请求的chunks不应该超过此值（请求过多，耗时）<br />
maxAsyncRequests: 异步请求的chunks不应该超过此值<br />
automaticNameDelimiter: 自动命名连接符<br />
chunks: 值为&quot;initial&quot;, “async”（默认） 或 “all”:<br />
initial: 入口chunk，对于异步导入的文件不处理<br />
async: 异步chunk，只对异步导入的文件处理<br />
all: 全部chunk</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://harrypangpang.github.io/2021/01/17/react16%E9%85%8D%E7%BD%AE/" title="前端工程化" target="_blank" rel="external">https://harrypangpang.github.io/2021/01/17/react16配置/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/HarryPangPang" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/HarryPangPang" target="_blank"><span class="text-dark">HarryPangPang</span><small class="ml-1x">web developer</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
           
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/01/17/vue-router%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/" title="vue-router实现"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/01/14/vuex%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/" title="vuex简单版学习"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/HarryPangPang" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://github.com/HarryPangPang/HarryPangPang.github.io/issues/4" target="_blank" title="Email" data-toggle=tooltip data-placement=top><i class="icon icon-email"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"> -->
  <script src="//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '109cd41cf54566dc4c4c',
    clientSecret: 'e5b1bc7f8bb1c5a376d23cb52e00d951b310dac4',
    repo: 'HarryPangPang.github.io',
    owner: 'HarryPangPang',
    admin: ['HarryPangPang'],
    id: md5(location.pathname),
    distractionFreeMode: true,
    language: 'zh-CN',
    enableHotKey: 'true'
  })
  gitalk.render('comments')
  </script>
      







</body>
</html>